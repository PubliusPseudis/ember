========================================
--- FILE: index.html
========================================
<!-- FILE: index.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>üî•Ember - The Ephemeral Social Network ‚Äì Where Posts Live and Die</title>
  <script type="module" src="main.js"></script>
  <link rel="stylesheet" href="style.css">
</head>
<body>
    
  <div id="identity-creation-overlay" class="loading-overlay" style="display: none;">
    <div id="identity-modal-content">
      <h2>Securing Your Identity</h2>
      <p>To protect the network, we need to perform a quick, one-time setup.</p>
      
      <div id="identity-step-0-disclaimer">
          <div class="risk-disclaimer">
              <h3>Welcome to a Public P2P Network</h3>
              <p><strong>This is not a private messenger.</strong> Please acknowledge the following to continue:</p>
              <ul>
                  <li>Your IP address may be visible to other users.</li>
                  <li>Messages are not end-to-end encrypted and can be read by peers who relay your posts.</li>
                  <li>Your activity is traceable.</li>
              </ul>
          </div>
          <button id="acknowledge-button" class="primary-button">I Understand, Continue</button>
      </div>
      
      <div id="identity-step-1-calibrate" style="display: none;">
          <div class="spinner"></div>
          <div id="identity-status-text"><strong>Step 1/2:</strong> Calibrating network difficulty...</div>
      </div>

      <div id="identity-step-2-pow" style="display: none;"></div>
      <div id="identity-step-3-prompt" style="display: none;"></div>
    </div>
  </div>

  <div id="loading" class="loading-overlay">
    <div class="loading-content">
      <div class="spinner"></div>
      <div>üî• Igniting the Ember Network...</div>
      <div style="font-size:12px;margin-top:10px;color:#ff8c42">No servers, just flames</div>
    </div>
  </div>

  <!-- =============================================== -->
  <!-- == NEW: Profile Modal Overlay                == -->
  <!-- =============================================== -->
  <div id="profile-modal-overlay" class="loading-overlay" style="display: none;">
    <div id="profile-modal">
      <button class="close-profile-button" onclick="closeProfile()">‚úï</button>
      <div id="profile-content">
        <!-- Profile content will be rendered here by ui.js -->
        <div class="spinner"></div>
        <div>Loading profile...</div>
      </div>
    </div>
  </div>

  <div id="app-container">

    <div class="app-column" id="column-controls">
     
        <h1>üî• Ember</h1>
        <p class="tagline">Fan the flames or watch them die</p>
        
          <!-- User Profile Section -->
          <div id="user-profile-section" class="user-profile-section" style="display: block;">
            <div class="user-profile-header" onclick="window.openProfileForHandle(window.state.myIdentity.handle)">
              <div id="user-profile-pic" class="user-profile-pic">
                <div class="profile-picture-placeholder-small">üë§</div>
              </div>
              <div class="user-profile-info">
                <div id="user-profile-handle" class="user-profile-handle"></div>
                <div class="user-profile-hint">View profile</div>
              </div>
            </div>
          </div>
              <div id="controls-footer">
        <button id="theme-toggle-button" class="secondary-button">‚òÄÔ∏è Light Mode</button>
      </div>
      
              <div id="compose">
          <textarea id="post-input" placeholder="Write something ephemeral‚Ä¶" maxlength="500"></textarea>
          <div class="image-preview" id="image-preview" style="display:none;">
            <img id="preview-img" />
            <button onclick="removeImage()">‚úï</button>
          </div>
          <div class="compose-footer">
            <input type="file" id="image-input" accept="image/*" style="display:none;" onchange="handleImageSelect(this)" />
            <button onclick="document.getElementById('image-input').click()" class="image-button">üì∑</button>
            <span class="char-count"><span id="char-current">0</span>/1120</span>
            <button id="send-button" class="primary-button" onclick="createPostWithTopics()">üî•</button>
          </div>
        </div>
      <div id="status">
        <span><span class="status-indicator" id="status-dot"></span>Connected to <span id="peer-count">0</span> peers</span>
        <span><span id="post-count">0</span> posts alive</span>
      </div>
      <div class="network-info" id="network-info" style="display:none">
        <strong>Your Network ID:</strong> <code id="network-id"></code><br />
        <small>Share this with friends to connect directly</small>
      </div>

        <button id="clear-data-button" class="secondary-button" onclick="clearLocalData()">
  üóëÔ∏è Clear Local Data
</button>

        
        <footer>
    <p class="network-notice">
        ‚ö†Ô∏è Public Network: Do not share sensitive information.
    </p>
</footer>
        
    </div>

    <div class="app-column" id="column-feed">
      <div class="column-header">
        <h2>The Void</h2>
      </div>
      <div class="topics-section">
        <h3>üì° Topics</h3>
<div class="subscribed-topics" id="subscribed-topics">
          </div>
        <div class="topic-input-wrapper">
          <input type="text" id="topic-input" placeholder="Subscribe to #topic" />
          <button onclick="subscribeToTopic()" class="subscribe-button">+</button>
        </div>
        <div class="topic-stats" id="topic-stats"></div>
      </div>

      <div class="feed-controls">
        <div class="topic-filter">
          <label>Filter by topic:</label>
          <select id="topic-filter" onchange="filterByTopic()">
            <option value="">All Topics</option>
            <option value="#general">#general</option>
            <option value="#ember">#ember</option>
          </select>
        </div>
        <div class="feed-mode">
          <button class="mode-button active" onclick="setFeedMode('all')">All Posts</button>
          <button class="mode-button" onclick="setFeedMode('topics')">My Topics</button>
        </div>
      </div>
      
      <div id="posts"></div>
    </div>

    <div class="app-column" id="column-bonfire">
      <div class="column-header">
        <h2 id="drawer-title">The Bonfire</h2>
        <div class="drawer-tabs">
          <button class="drawer-tab active" data-drawer="bonfire" onclick="switchDrawer('bonfire')">
            <span class="tab-icon">üî•</span>
            <span class="tab-label">Bonfire</span>
          </button>
          <button class="drawer-tab" data-drawer="inbox" onclick="switchDrawer('inbox')">
            <span class="tab-icon">üíå</span>
            <span class="tab-label">Messages</span>
            <span class="unread-badge" id="inbox-unread-badge" style="display: none;">0</span>
          </button>
          <button class="drawer-tab" data-drawer="network" onclick="switchDrawer('network')">
            <span class="tab-icon">üåê</span>
            <span class="tab-label">Network</span>
          </button>
        </div>
      </div>
      
      <!-- Drawer Contents -->
      <div class="drawer-container">
        <!-- Bonfire Drawer -->
        <div id="bonfire-drawer" class="drawer-content active">
          <div id="bonfire-content"></div>
        </div>
        
        <!-- Inbox Drawer -->
        <div id="inbox-drawer" class="drawer-content">
          <div id="dm-inbox">
            <div class="dm-conversations" id="dm-conversations">
              <div class="dm-empty-state">
                No messages yet. Send a DM to start a conversation!
              </div>
            </div>
          </div>
        </div>
        
        <!-- Network Stats Drawer -->
        <div id="network-drawer" class="drawer-content">
          <div id="network-stats">
            <div class="network-visualization">
              <canvas id="network-canvas"></canvas>
            </div>
            <div class="network-details">
              <h4>Network Health</h4>
              <div id="network-metrics"></div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div id="dm-panel" style="display: none;">
    <div class="dm-header">
      <h3>Chat with <span id="dm-recipient"></span></h3>
      <div class="dm-header-controls">
        <button class="minimize-button" onclick="toggleDMMinimize()">‚Äì</button>
        <button class="close-button" onclick="closeDMPanel()">‚úï</button>
      </div>
    </div>
    <div id="dm-messages" class="dm-messages"></div>
    <div class="dm-compose">
      <textarea id="dm-input" placeholder="Type a message..." rows="1" 
        onkeypress="if(event.key === 'Enter' && !event.shiftKey) { event.preventDefault(); sendDM(); }"
        oninput="autoResizeDMInput(this)"></textarea>
      <button onclick="sendDM()" class="primary-button">Send</button>
    </div>
  </div>
</body>
</html>


========================================
--- FILE: test-safety.html
========================================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Content Safety Test</title>
    <style>
        body { font-family: sans-serif; background-color: #282c34; color: white; padding: 20px; }
        textarea { width: 100%; height: 150px; margin-bottom: 10px; font-size: 16px; }
        button { padding: 10px 15px; font-size: 16px; cursor: pointer; }
        pre { background-color: #1e1e1e; padding: 15px; border-radius: 5px; white-space: pre-wrap; word-wrap: break-word; }
        h2 { color: #61dafb; }
    </style>
</head>
<body>

    <h1>Content Safety Lite Tester</h1>
    <p>Enter text below to check for violations.</p>

    <textarea id="text-input" placeholder="Enter text here..."></textarea>
    <button id="check-button">Check Content</button>

    <h2>Result:</h2>
    <pre id="result-output">The JSON result will appear here.</pre>

    <script type="module">
        console.log('[HTML DEBUG] Script module starting');
        
        try {
            console.log('[HTML DEBUG] About to import content safety module');
            console.log('[HTML DEBUG] Import path: ./services/content-safety-lite.js');
            
            // Check if the path exists by trying to fetch it first
            fetch('./services/content-safety-lite.js')
                .then(response => {
                    console.log('[HTML DEBUG] Fetch response status:', response.status);
                    console.log('[HTML DEBUG] Fetch response ok:', response.ok);
                    return response.text();
                })
                .then(text => {
                    console.log('[HTML DEBUG] File content length:', text.length);
                    console.log('[HTML DEBUG] First 200 chars:', text.substring(0, 200));
                    
                    // Check if the file contains any 'fs' references
                    if (text.includes("'fs'") || text.includes('"fs"') || text.includes('`fs`')) {
                        console.error('[HTML DEBUG] Found "fs" reference in the file!');
                        console.log('[HTML DEBUG] Context around fs:', 
                            text.substring(Math.max(0, text.indexOf('fs') - 50), text.indexOf('fs') + 50)
                        );
                    }
                })
                .catch(err => {
                    console.error('[HTML DEBUG] Error fetching file:', err);
                });
            
        } catch (error) {
            console.error('[HTML DEBUG] Error before import:', error);
        }

        // Use dynamic import() instead of static import
        console.log('[HTML DEBUG] Attempting dynamic import...');
        
        import('./services/content-safety-lite.js')
            .then(module => {
                console.log('[HTML DEBUG] Import successful!', module);
                
                // Get the contentSafety from the module
                const { contentSafety } = module;
                console.log('[HTML DEBUG] contentSafety object:', contentSafety);
                
                const textInput = document.getElementById('text-input');
                const checkButton = document.getElementById('check-button');
                const resultOutput = document.getElementById('result-output');

                checkButton.addEventListener('click', async () => {
                    console.log('[HTML DEBUG] Check button clicked');
                    const text = textInput.value;
                    if (!text) {
                        resultOutput.textContent = 'Please enter some text.';
                        return;
                    }

                    try {
                        console.log('[HTML DEBUG] Calling checkContent method');
                        // Call the checkContent method directly
                        const result = await contentSafety.checkContent(text);
                        console.log('[HTML DEBUG] checkContent result:', result);

                        // Display the full result object as a formatted JSON string
                        resultOutput.textContent = JSON.stringify(result, null, 2);
                    } catch (error) {
                        console.error('[HTML DEBUG] Error calling checkContent:', error);
                        resultOutput.textContent = 'Error: ' + error.message;
                    }
                });
            })
            .catch(error => {
                console.error('[HTML DEBUG] Import failed:', error);
                console.error('[HTML DEBUG] Error stack:', error.stack);
                document.getElementById('result-output').textContent = 'Failed to load content safety module: ' + error.message;
            });
    </script>

</body>
</html>


========================================
--- FILE: style.css
========================================
/* FILE: style.css */
/*
  ==========================================================================
  THEME VARIABLES
  This section defines the colors for both the default (dark) and light themes.
  ==========================================================================
*/

:root {
  /* Backgrounds */
  --background-gradient: linear-gradient(to bottom, #0a0a0a, #000);
  --background-column: transparent;
  --background-compose-area: rgba(10, 10, 10, 0.5);
  --background-status-area: rgba(10, 10, 10, 0.5);
  --background-input: #0a0a0a;
  --background-button-primary: #ff8c42;
  --background-button-primary-hover: #ff6b4a;
  --background-button-disabled: #4a0e0e;
  --background-bonfire-item: rgba(255, 107, 74, 0.05);
  --background-bonfire-item-hover: rgba(255, 107, 74, 0.15);
  --background-notification: #333;
  --background-loading-overlay: rgba(0, 0, 0, .8);
  --background-scrollbar-track: #0a0a0a;
  --background-scrollbar-thumb: #333;
  --background-scrollbar-thumb-hover: #ff8c42;

  /* Text Colors */
  --text-primary: #e0e0e0;
  --text-secondary: #888;
  --text-tertiary: #666;
  --text-accent: #ff8c42;
  --text-accent-hot: #ff6b4a;
  --text-button-primary: #000;
  --text-button-disabled: #666;
  --text-bonfire-preview: #ccc;
  --text-bonfire-heat: #fff5e6;
  --text-notification: #fff;
  
  /* Borders & Gradients */
  --border-color-dark: #222;
  --border-color-light: #333;
  --border-color-accent: #ff8c42;
  --border-image-post: linear-gradient(to right, #ff6b4a, #cc2936);
  --border-image-post-hot: linear-gradient(to right, #fff5e6, #ff6b4a);
  --border-image-post-inferno: linear-gradient(to right, #fff, #ffeb3b, #ff6b4a);
  --border-image-post-dying: linear-gradient(to right, #4a0e0e, #0a0a0a);
  --border-thread-line: linear-gradient(to bottom, #ff8c42, transparent);

  /* Shadows & Glows */
  --shadow-color-accent: rgba(255, 140, 66, 0.3);
  --shadow-color-header: #ff6b4a, 0 0 20px #cc2936;
  --shadow-color-button-hover: #ff8c42;
  --shadow-color-ember-glow-1: rgba(255,107,74,0.7);
  --shadow-color-ember-glow-2: rgba(255,140,66,0.5);
  --shadow-color-ember-glow-inset: rgba(255,245,230,0.2);
  --shadow-color-ember-glow-1-hover: rgba(255,107,74,0.9);
  --shadow-color-ember-glow-2-hover: rgba(255,140,66,0.7);
  --shadow-color-ember-glow-inset-hover: rgba(255,245,230,0.3);
  --shadow-color-inferno-1: rgba(255,255,255,0.8);
  --shadow-color-inferno-2: rgba(255,235,59,0.6);
  --shadow-color-inferno-3: rgba(255,107,74,0.4);
  --shadow-color-inferno-1-hover: rgba(255,255,255,1);
  --shadow-color-inferno-2-hover: rgba(255,235,59,0.8);
  --shadow-color-inferno-3-hover: rgba(255,107,74,0.6);
  --shadow-color-post-pulse: rgba(255, 107, 74, var(--heat-opacity, 0.2));
  --shadow-color-post-pulse-hover: rgba(255, 107, 74, calc(var(--heat-opacity, 0.2) * 1.5));
 
  /* Variables for Topic Section */
  --background-topic-section: rgba(255, 140, 66, 0.05);
  --border-color-topic-section: rgba(255, 140, 66, 0.2);
  --background-topic-tag: rgba(255, 140, 66, 0.2);
  --text-color-topic-tag: var(--text-accent);
  --background-topic-tag-active: var(--text-accent);
  --text-color-topic-tag-active: var(--text-button-primary);
  --border-color-topic-input: rgba(255, 140, 66, 0.3);
  /* Variables for Feed Controls */
  --background-feed-controls: rgba(0, 0, 0, 0.2);
  --background-topic-filter-select: rgba(255, 140, 66, 0.1);
  --border-color-topic-filter-select: rgba(255, 140, 66, 0.3);
  --border-color-mode-button: rgba(255, 140, 66, 0.3); 
  /* Variables for Topic Tree Visualization */
  --background-topic-tree-node: rgba(255, 140, 66, 0.1);
  --border-color-topic-tree-node: var(--text-accent); /* Use the main accent color */
  --border-color-topic-tree-parent: #4CAF50; /* Green */
  --border-color-topic-tree-child: #2196F3;  /* Blue */

  /* NEW: Profile Theme Variables */
  --profile-bg: #1a1a1a;
  --profile-text: #e0e0e0;
  --profile-accent: #ff1493;
}


body.light-mode {
  /* Backgrounds */
  --background-gradient: linear-gradient(to bottom, #ffffff, #f0f0f0);
  --background-column: transparent;
  --background-compose-area: #ffffff;
  --background-status-area: #fdfdfd;
  --background-input: #ffffff;
  --background-button-primary: #ff8c42;
  --background-button-primary-hover: #ff6b4a;
  --background-button-disabled: #e0e0e0;
  --background-bonfire-item: #fff8f5;
  --background-bonfire-item-hover: #fff2e8;
  --background-notification: #333;
  --background-loading-overlay: rgba(255, 255, 255, .8);
  --background-scrollbar-track: #f0f0f0;
  --background-scrollbar-thumb: #cccccc;
  --background-scrollbar-thumb-hover: #ff8c42;

  /* Text Colors */
  --text-primary: #1a1a1a;
  --text-secondary: #555;
  --text-tertiary: #888;
  --text-accent: #d96d00;
  --text-accent-hot: #ff6b4a;
  --text-button-primary: #ffffff;
  --text-button-disabled: #999;
  --text-bonfire-preview: #444;
  --text-bonfire-heat: #d96d00;
  --text-notification: #fff;
  --text-accent-darker: #cc2936;

  /* Borders & Gradients */
  --border-color-dark: #e0e0e0;
  --border-color-light: #d0d0d0;
  --border-color-accent: #ff8c42;
  --border-image-post: linear-gradient(to right, #ff8c42, #ff6b4a);
  --border-image-post-hot: linear-gradient(to right, #ff6b4a, #ff8c42);
  --border-image-post-inferno: linear-gradient(to right, #ffeb3b, #ff8c42, #ff6b4a);
  --border-image-post-dying: linear-gradient(to right, #e0e0e0, #f0f0f0);
  --border-thread-line: linear-gradient(to bottom, #ff8c42, transparent);
  
  /* Shadows & Glows */
  --shadow-color-accent: rgba(255, 140, 66, 0.3);
  --shadow-color-header: #ff6b4a, 0 0 20px #ff8c42;
  --shadow-color-button-hover: #ff8c42;
  --shadow-color-ember-glow-1: rgba(255,107,74,0.5);
  --shadow-color-ember-glow-2: rgba(255,140,66,0.3);
  --shadow-color-ember-glow-inset: rgba(255,140,66,0.1);
  --shadow-color-ember-glow-1-hover: rgba(255,107,74,0.7);
  --shadow-color-ember-glow-2-hover: rgba(255,140,66,0.5);
  --shadow-color-ember-glow-inset-hover: rgba(255,140,66,0.2);
  --shadow-color-inferno-1: rgba(255,107,74,0.6);
  --shadow-color-inferno-2: rgba(255,235,59,0.5);
  --shadow-color-inferno-3: rgba(255,107,74,0.4);
  --shadow-color-inferno-1-hover: rgba(255,107,74,0.8);
  --shadow-color-inferno-2-hover: rgba(255,235,59,0.7);
  --shadow-color-inferno-3-hover: rgba(255,107,74,0.6);
  --shadow-color-post-pulse: rgba(255, 107, 74, var(--heat-opacity, 0.2));
  --shadow-color-post-pulse-hover: rgba(255, 107, 74, calc(var(--heat-opacity, 0.2) * 1.5));
  /* Light mode overrides for Topic Section */
  --background-topic-section: #fff8f5;
  --border-color-topic-section: #ffeadb;
  --background-topic-tag: #ffeadb;
  --text-color-topic-tag: var(--text-accent);
  --background-topic-tag-active: var(--text-accent);
  --text-color-topic-tag-active: #ffffff;
  --border-color-topic-input: #fcd5b8;

  /* Light mode overrides for Feed Controls */
  --background-feed-controls: var(--background-bonfire-item); /* Re-using a nice light orange tint */
  --background-topic-filter-select: var(--background-topic-tag); /* Re-using the light tag background */
  --border-color-topic-filter-select: var(--border-color-topic-input); /* Re-using the light input border */
  --border-color-mode-button: var(--border-color-topic-section); 
  /* Light mode overrides for Topic Tree Visualization */
  --background-topic-tree-node: var(--background-bonfire-item); /* A consistent light orange tint */
  --border-color-topic-tree-node: var(--text-accent); /* This already adapts to light mode */
  --border-color-topic-tree-parent: #45a049; /* A slightly darker green for better contrast on white */
  --border-color-topic-tree-child: #1e88e5; /* A slightly darker blue for better contrast on white */
  
  /* NEW: Light mode profile variables */
  --profile-bg: #fafafa;
  --profile-text: #1a1a1a;
  --profile-accent: #d9006c;
}


/*
  ==========================================================================
  GENERAL STYLES
  This section contains the refactored styles using the variables defined above.
  ==========================================================================
*/

* { 
  margin: 0; 
  padding: 0; 
  box-sizing: border-box; 
}

/* Custom scrollbar for a cleaner look */
::-webkit-scrollbar {
  width: 8px;
}
::-webkit-scrollbar-track {
  background: var(--background-scrollbar-track);
}
::-webkit-scrollbar-thumb {
  background: var(--background-scrollbar-thumb);
  border-radius: 4px;
}
::-webkit-scrollbar-thumb:hover {
  background: var(--background-scrollbar-thumb-hover);
}

body {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
  background: var(--background-gradient);
  color: var(--text-primary);
  line-height: 1.6;
  overflow: hidden; /* Prevent body scroll, columns will scroll instead */
}

/* Main multi-column container */
#app-container {
  display: flex;
  height: 100vh;
}

.app-column {
  padding: 20px;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

/* Column 1: Controls */
#column-controls {
  flex: 0 0 320px; /* Fixed width for the control column */
  border-right: 1px solid var(--border-color-dark);
}

/* Column 2: Main Feed */
#column-feed {
  flex: 2; /* Takes up more space */
  border-right: 1px solid var(--border-color-dark);
}

/* Column 3: Bonfire */
#column-bonfire {
  flex: 1; /* Takes up less space than the feed */
}

.column-header {
  padding-bottom: 10px;
  margin-bottom: 20px;
  border-bottom: 1px solid var(--border-color-light);
  color: var(--text-secondary);
  font-weight: bold;
}

#posts, #bonfire-content {
  flex-grow: 1;
  overflow-y: auto;
  padding-right: 10px; /* Space for scrollbar */
}

header {
  text-align: left;
  margin-bottom: 20px;
  padding-bottom: 20px;
  border-bottom: 1px solid var(--border-color-light);
}

h1 {
  font-size: 28px;
  font-weight: bold;
  color: var(--text-accent); /* Main text color */
  margin-bottom: 5px;
  /* Apply animation */
  animation: text-flicker-primary 2s ease-in-out infinite alternate; /* Default dark mode animation */
}

.tagline {
  color: var(--text-secondary);
  font-size: 14px;
}

#status {
  background: var(--background-status-area);
  padding: 10px 15px;
  border-radius: 20px;
  font-size: 12px;
  margin-bottom: 20px;
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  gap: 8px;
  position: relative;
  border: 1px solid var(--border-color-light);
}

/* Flickering Flame on Status */
#status::before {
  content: 'üî•';
  position: absolute;
  right: 0;
  top: 10px;
  font-size: 20px;
  opacity: 0.6;
  animation: flicker 3s ease-in-out infinite;
}

.status-indicator {
  width: 8px;
  height: 8px;
  background: var(--border-color-accent);
  border-radius: 50%;
  display: inline-block;
  margin-right: 8px;
  animation: pulse 2s infinite;
}
.status-indicator.connecting { background: var(--background-button-disabled); }

#compose {
  background: var(--background-compose-area);
  padding: 20px;
  border-radius: 12px;
  border: 1px solid var(--border-color-light);
}

#post-input {
  width: 100%;
  background: var(--background-input);
  border: 1px solid var(--border-color-light);
  color: var(--text-primary);
  padding: 12px;
  border-radius: 8px;
  resize: vertical;
  min-height: 100px;
  font-size: 16px;
  transition: box-shadow .3s;
}
/* Compose Area Glow on Focus */
#post-input:focus {
  outline: none;
  border-color: var(--border-color-accent);
  box-shadow: 0 0 15px var(--shadow-color-accent);
}

.compose-footer {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-top: 12px;
}
.char-count { font-size: 12px; color: var(--text-tertiary); }

button {
  background: var(--background-button-primary);
  color: var(--text-button-primary);
  border: none;
  padding: 8px 20px;
  border-radius: 20px;
  cursor: pointer;
  font-size: 14px;
  font-weight: bold;
  transition: .2s;
}
button:hover { background: var(--background-button-primary-hover); box-shadow: 0 0 10px var(--shadow-color-button-hover); }
button:active { transform: scale(.98); }
button:disabled { opacity: .5; cursor: not-allowed; background: var(--background-button-disabled); color: var(--text-button-disabled); box-shadow: none; }

.post {
  background: var(--background-column);
  padding: 20px;
  border-radius: 12px;
  margin-bottom: 20px;
  transition: all .5s ease-in-out;
  border: 1px solid;
  border-image-slice: 1;
  border-image-source: var(--border-image-post);
  box-shadow: 0 0 20px var(--shadow-color-post-pulse);
  position: relative;
  overflow: hidden;
  animation: pulse-border 5s infinite;
}

/* Rising Embers Particle Effect */
.post::before {
  content: '';
  position: absolute;
  top: -20px; left: 0; right: 0;
  height: 20px;
  background: url('data:image/svg+xml;utf8,<svg xmlns="[http://www.w3.org/2000/svg](http://www.w3.org/2000/svg)" viewBox="0 0 100 20"><circle cx="10" cy="10" r="1" fill="%23ff8c42" opacity="0.6"><animate attributeName="cy" from="20" to="-10" dur="3s" repeatCount="indefinite"/><animate attributeName="opacity" from="0.6" to="0" dur="3s" repeatCount="indefinite"/></circle><circle cx="50" cy="15" r="1.5" fill="%23ff6b4a" opacity="0.7"><animate attributeName="cy" from="20" to="-10" dur="2.5s" repeatCount="indefinite"/><animate attributeName="opacity" from="0.7" to="0" dur="2.5s" repeatCount="indefinite"/></circle><circle cx="80" cy="5" r="1" fill="%23fff5e6" opacity="0.5"><animate attributeName="cy" from="20" to="-10" dur="3.5s" repeatCount="indefinite"/><animate attributeName="opacity" from="0.5" to="0" dur="3.5s" repeatCount="indefinite"/></circle></svg>') repeat-x;
  opacity: var(--heat-opacity, 0.6);
  pointer-events: none;
  transition: opacity 1.5s;
}
.post.hot::before, .post.inferno::before {
  opacity: 1;
}

/* Glow/Pulse for Hot & Inferno Posts */
.post.hot {
  border-image-source: var(--border-image-post-hot);
  animation: ember-glow 5s ease-in-out infinite;
}
.post.inferno {
  border-image-source: var(--border-image-post-inferno);
  animation: inferno-pulse 3s ease-in-out infinite;
}

.post.dying {
  border-image-source: var(--border-image-post-dying);
  animation: fadeToAsh 1s forwards;
}
/* Ash Particle Effect for Dying Posts */
.post.dying::after {
  content: '';
  position: absolute;
  top: 0; left: 0; right: 0; bottom: 0;
  background: url('data:image/svg+xml;utf8,<svg xmlns="[http://www.w3.org/2000/svg](http://www.w3.org/2000/svg)" viewBox="0 0 100 100"><circle cx="20" cy="80" r="2" fill="%23333"><animate attributeName="cy" from="80" to="120" dur="1s" fill="freeze"/><animate attributeName="opacity" from="0.8" to="0" dur="1s" fill="freeze"/></circle><circle cx="50" cy="80" r="1.5" fill="%23444"><animate attributeName="cy" from="80" to="120" dur="1.2s" fill="freeze"/><animate attributeName="opacity" from="0.7" to="0" dur="1.2s" fill="freeze"/></circle><circle cx="80" cy="80" r="2" fill="%23333"><animate attributeName="cy" from="80" to="120" dur="0.8s" fill="freeze"/><animate attributeName="opacity" from="0.8" to="0" dur="0.8s" fill="freeze"/></circle></svg>');
  pointer-events: none;
}

.author { font-size: 14px; color: var(--text-accent); margin-bottom: 8px; font-weight: 500; }
.content { color: var(--text-primary); margin-bottom: 12px; word-wrap: break-word; }
.post-footer { display: flex; justify-content: space-between; align-items: center; font-size: 12px; color: var(--text-tertiary); }
.carriers { display: flex; align-items: center; gap: 5px; color: var(--text-accent-hot); }
.carrier-count { font-weight: bold; }

.carry-button { padding: 6px 14px; font-size: 16px; background: transparent; border: 1px solid var(--border-color-accent); color: var(--border-color-accent); }
.carry-button:hover { background: var(--border-color-accent); color: var(--text-button-primary); }
/* Blow Effect on Button Click */
.carry-button:active {
  animation: blow-effect 2s ease-out;
}

/* Bonfire Styles */
.bonfire-item {
  background: var(--background-bonfire-item);
  padding: 10px 15px;
  border-radius: 8px;
  border-left: 3px solid var(--border-color-accent);
  margin-bottom: 10px;
  cursor: pointer;
  transition: background .2s;
  display: flex;
  align-items: center;
}
.bonfire-item:hover { background: var(--background-bonfire-item-hover); }
.bonfire-heat { color: var(--text-bonfire-heat); font-weight: bold; white-space: nowrap; margin-right: 15px; }
.bonfire-preview { color: var(--text-bonfire-preview); font-size: 14px; }
.empty-state { color: var(--text-tertiary); text-align: center; padding: 40px 20px; font-style: italic; }

/* Notification & Loading */
.notification { position: fixed; top: 20px; right: 20px; background: var(--background-notification); color: var(--text-notification); padding: 12px 20px; border-radius: 8px; z-index: 1000; }
.loading-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: var(--background-loading-overlay); display: flex; align-items: center; justify-content: center; z-index: 2000; }
.spinner { border: 3px solid var(--border-color-light); border-top: 3px solid var(--border-color-accent); border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; margin: 0 auto 20px; }

/* Keyframe Animations */
@keyframes spin { to { transform: rotate3d(0, 1, 0, 360deg); } }
@keyframes pulse {
  0% { box-shadow: 0 0 5px var(--border-color-accent); }
  50% { box-shadow: 0 0 15px var(--text-accent-hot); }
  100% { box-shadow: 0 0 5px var(--border-color-accent); }
}
@keyframes flicker {
  0%, 100% { opacity: 0.6; transform: scale(1); }
  50% { opacity: 1; transform: scale(1.1); }
}
@keyframes fadeToAsh {
  to { opacity: 0; transform: scale(.95); }
}
@keyframes blow-effect {
  0% { transform: scale(1); }
  50% { transform: scale(1.05); }
  100% { transform: scale(1); }
}
@keyframes ember-glow {
  0%, 100% { box-shadow: 0 0 20px var(--shadow-color-ember-glow-1), 0 0 30px var(--shadow-color-ember-glow-2), inset 0 0 15px var(--shadow-color-ember-glow-inset); }
  50% { box-shadow: 0 0 30px var(--shadow-color-ember-glow-1-hover), 0 0 50px var(--shadow-color-ember-glow-2-hover), inset 0 0 20px var(--shadow-color-ember-glow-inset-hover); }
}
@keyframes inferno-pulse {
  0%, 100% { transform: scale(1); box-shadow: 0 0 30px var(--shadow-color-inferno-1), 0 0 60px var(--shadow-color-inferno-2), 0 0 90px var(--shadow-color-inferno-3); }
  50% { transform: scale(1.02); box-shadow: 0 0 40px var(--shadow-color-inferno-1-hover), 0 0 80px var(--shadow-color-inferno-2-hover), 0 0 120px var(--shadow-color-inferno-3-hover); }
}
@keyframes pulse-border {
  0% { box-shadow: 0 0 20px var(--shadow-color-post-pulse); }
  50% { box-shadow: 0 0 30px var(--shadow-color-post-pulse-hover); }
  100% { box-shadow: 0 0 20px var(--shadow-color-post-pulse); }
}

/* Responsive layout for smaller screens */
@media (max-width: 900px) {
  body {
    overflow: auto;
  }
  #app-container {
    flex-direction: column;
    height: auto;
  }
  .app-column {
    border-right: none;
    border-bottom: 1px solid var(--border-color-dark);
  }
  #column-controls { flex: 0 0 auto; }
  #posts, #bonfire-content {
    max-height: 60vh; /* Give a max height to scrolling sections on mobile */
  }
}

.carry-button {
  position: relative;
  transition: box-shadow 0.2s ease;
}

.carry-button:active {
  animation: blow-effect 0.3s ease-out;
  box-shadow: 0 0 10px var(--border-color-accent), 0 0 20px var(--text-accent-hot); /* Glow effect */
}

.carry-button::after {
  content: 'üí®'; /* Use the puff emoji as the content */
  position: absolute;
  top: 50%;
  left: 100%;
  opacity: 0;
  pointer-events: none;
  font-size: 20px; /* Set the size of the emoji */
  /* The transform is now handled by the animation */
}

.carry-button:active::after {
  /* Apply our new puff-of-wind animation on click */
  animation: puff-of-wind 0.6s ease-out;
}

@keyframes particle-burst {
  0% {
    transform: translate(-50%, -50%) scale(1);
    opacity: 1;
  }
  100% {
    transform: translate(-50%, -50%) scale(5);
    opacity: 0;
  }
}
@keyframes puff-of-wind {
  0% {
    opacity: 0;
    transform: translate(-50%, -50%) scale(0.8);
  }
  20% {
    opacity: 1;
  }
  100% {
    opacity: 0;
    transform: translate(150%, -50%) scale(1.5);
  }
}
.post.reply {
  /* Use a relative unit for the fallback margin for consistency. */
  margin-left: 0px; 
  border-left: 2px solid var(--border-color-accent);
  position: relative;
}

.post.reply::before {
  content: '‚Ü≥';
  position: absolute;
  /* Use 'em' to position the arrow relative to the text size. */
  left: 0em;
  top: 0.1em;
  color: var(--text-accent);
  /* Use 'em' to scale the arrow size with the text. */
  font-size: 1.4em;
  font-weight: bold;
}

.reply-button {
  background: transparent;
  border: 1px solid var(--text-tertiary);
  color: var(--text-secondary);
  padding: 4px 12px;
  font-size: 14px;
  margin-left: 10px;
}

.reply-button:hover {
  border-color: var(--border-color-accent);
  color: var(--border-color-accent);
}

.reply-compose {
  margin-top: 10px;
  padding: 15px;
  background: var(--background-compose-area);
  border-radius: 8px;
  border: 1px solid var(--border-color-light);
}

.reply-input {
  width: 100%;
  background: var(--background-input);
  border: 1px solid var(--border-color-light);
  color: var(--text-primary);
  padding: 8px;
  border-radius: 6px;
  resize: vertical;
  min-height: 60px;
  font-size: 14px;
}

.thread-line {
  position: absolute;
  left: -20px;
  top: 0;
  bottom: 0;
  width: 5px;
  background: var(--border-thread-line);
}

.replies-container {
  margin-top: 2%;  
  margin-left: 4%;
}

.thread-stats {
  font-size: 12px;
  color: var(--text-tertiary);
  margin-left: 10px;
}

.collapse-thread {
  cursor: pointer;
  user-select: none;
  color: var(--text-tertiary);
  font-size: 12px;
  margin-left: 10px;
}

.collapse-thread:hover {
  color: var(--border-color-accent);
}

/* Nested reply styles */
.post.reply.depth-1 { margin-left: 0%; }
.post.reply.depth-2 { margin-left: 0%; }
.post.reply.depth-3 { margin-left: 0%; }
.post.reply.depth-4 { margin-left: 0%; opacity: 0.9; }
.post.reply.depth-5 { margin-left: 0%; opacity: 0.8; }

/* Animate thread flames */
.thread-ember {
  display: inline-block;
  animation: thread-flicker 2s ease-in-out infinite;
}

@keyframes thread-flicker {
  0%, 100% { opacity: 0.6; transform: scale(1); }
  50% { opacity: 1; transform: scale(1.1); }
}

#controls-footer {
  padding: 10px 0;
  margin-bottom: 20px;
  text-align: center;
  border-bottom: 1px solid var(--border-color-light);
}

.secondary-button {
  background: transparent;
  border: 1px solid var(--border-color-light);
  color: var(--text-secondary);
  font-weight: normal;
  padding: 6px 14px;
}

.secondary-button:hover {
  border-color: var(--text-accent);
  color: var(--text-accent);
  background: var(--background-bonfire-item); /* A subtle hover background */
}
.post-image {
  max-width: 100%;
  border-radius: 8px;
  margin-top: 10px;
}

.image-preview {
  margin: 10px 0;
  position: relative;
  max-width: 200px;
}

.image-preview img {
  width: 100%;
  border-radius: 8px;
}

.image-preview button {
  position: absolute;
  top: 5px;
  right: 5px;
  background: rgba(0,0,0,0.7);
  color: white;
  border: none;
  border-radius: 50%;
  width: 24px;
  height: 24px;
  cursor: pointer;
}

.image-button {
  background: transparent;
  border: 1px solid #666;
  color: #888;
  padding: 6px 12px;
  margin-right: 10px;
}
/* Remove the bottom margin from only the last reply in a thread */
.replies-container .post.reply:last-child {
  margin-bottom: 0;
}
/*
  ==========================================================================
  IDENTITY CREATION MODAL STYLES
  ==========================================================================
*/

#identity-modal-content {
  background: var(--background-compose-area);
  padding: 30px 40px;
  border-radius: 12px;
  border: 1px solid var(--border-color-light);
  max-width: 500px;
  text-align: center;
  box-shadow: 0 10px 30px rgba(0,0,0,0.2);
}

#identity-modal-content h2 {
  color: var(--text-accent);
  margin-bottom: 15px;
}

#identity-modal-content p {
  color: var(--text-secondary);
  font-size: 14px;
  margin-bottom: 25px;
}

#identity-status-text, #identity-status-text-2 {
  margin-top: 15px;
  color: var(--text-primary);
  font-size: 14px;
}

#identity-progress-bar {
  width: 100%;
  height: 12px;
  margin-top: 10px;
  border-radius: 6px;
  overflow: hidden;
  border: 1px solid var(--border-color-light);
}

/* Styling for the progress bar value */
#identity-progress-bar::-webkit-progress-bar {
  background-color: var(--background-input);
}
#identity-progress-bar::-webkit-progress-value {
  background-color: var(--border-color-accent);
  transition: width 0.2s ease-in-out;
}
#identity-progress-bar::-moz-progress-bar { /* Firefox */
  background-color: var(--border-color-accent);
}

#identity-progress-percent {
  font-size: 12px;
  color: var(--text-tertiary);
  margin-top: 5px;
}

#identity-step-3-prompt input {
    display: block;
    width: 80%;
    margin: 10px auto;
    background: var(--background-input);
    border: 1px solid var(--border-color-light);
    color: var(--text-primary);
    padding: 10px;
    border-radius: 8px;
    text-align: center;
}
#identity-step-3-prompt input:focus {
    outline: none;
    border-color: var(--border-color-accent);
}

#identity-step-3-prompt button {
    margin-top: 15px;
}
/* Make the identity-creation modal sit ABOVE the Ember splash */
#identity-creation-overlay {
  z-index: 3001;      /* higher than #loading (2000) */
}
@keyframes text-flicker-primary {
  0%, 100% { text-shadow: 0 0 10px var(--shadow-color-header), 0 0 20px var(--text-accent-hot); }
  50% { text-shadow: 0 0 15px var(--shadow-color-header), 0 0 25px var(--text-accent-hot), 0 0 5px var(--text-accent); }
}

@keyframes text-flicker-light {
  0%, 100% { text-shadow: 0 0 10px var(--shadow-color-header), 0 0 20px var(--text-accent); }
  50% { text-shadow: 0 0 15px var(--shadow-color-header), 0 0 25px var(--text-accent), 0 0 5px var(--text-accent-hot); }
}
body.light-mode h1 {
  animation: text-flicker-light 2s ease-in-out infinite alternate;
}

.post.animate::before {
  background: url('data:image/svg+xml...');
}
.post:not(.animate)::before {
  display: none;
}

/* Add to your style.css */
.loading-content h1 {
  animation: ember-glow 3s ease-in-out infinite;
}

.loading-content h2 {
  color: var(--text-accent);
  margin-bottom: 15px;
}

.loading-content .primary-button {
  animation: pulse 2s infinite;
  box-shadow: 0 0 20px var(--shadow-color-accent);
  transition: all 0.3s ease;
}

.loading-content .primary-button:hover {
  transform: scale(1.05);
  box-shadow: 0 0 30px var(--shadow-color-accent);
}

@keyframes ember-glow {
  0%, 100% { 
    transform: scale(1);
    filter: brightness(1);
  }
  50% { 
    transform: scale(1.1);
    filter: brightness(1.3) drop-shadow(0 0 20px #ff8c42);
  }
}

/* Add to style.css */
.topics-section {
  margin: 20px 0;
  padding: 15px;
  background: var(--background-topic-section); /* USE VARIABLE */
  border-radius: 8px;
  border: 1px solid var(--border-color-topic-section); /* USE VARIABLE */
}

.topics-section h3 {
  margin: 0 0 10px 0;
  font-size: 16px;
}

.subscribed-topics {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  margin-bottom: 10px;
}

.topic-tag {
  background: var(--background-topic-tag); /* USE VARIABLE */
  color: var(--text-color-topic-tag); /* USE VARIABLE */
  padding: 4px 12px;
  border-radius: 16px;
  font-size: 14px;
  cursor: pointer;
  transition: all 0.2s;
  position: relative;
}

.topic-tag.active {
  background: var(--background-topic-tag-active); /* USE VARIABLE */
  color: var(--text-color-topic-tag-active); /* USE VARIABLE */
}

.topic-tag:hover {
  transform: scale(1.05);
}

.topic-tag::after {
  content: '√ó';
  margin-left: 6px;
  opacity: 0;
  transition: opacity 0.2s;
}

.topic-tag:hover::after {
  opacity: 1;
}

.topic-input-wrapper {
  display: flex;
  gap: 8px;
  margin-top: 10px;
}

.topic-input-wrapper input {
  flex: 1;
  padding: 6px 10px;
  border: 1px solid var(--border-color-topic-input); /* USE VARIABLE */
  border-radius: 4px;
  background: transparent;
  color: var(--text-primary);
}

.subscribe-button {
  padding: 6px 12px;
  background: var(--background-topic-tag-active); /* USE VARIABLE */
  color: var(--text-color-topic-tag-active); /* USE VARIABLE */
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-weight: bold;
}

.topic-stats {
  margin-top: 10px;
  font-size: 12px;
  color: var(--text-secondary);
}

.feed-controls {
  padding: 15px;
  background: var(--background-feed-controls); /* USE VARIABLE */
  margin-bottom: 10px;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.topic-filter select {
  padding: 6px 10px;
  background: var(--background-topic-filter-select); /* USE VARIABLE */
  border: 1px solid var(--border-color-topic-filter-select); /* USE VARIABLE */
  border-radius: 4px;
  color: var(--text-primary); /* This was already correct */
}

.feed-mode {
  display: flex;
  gap: 10px;
}

.mode-button {
  padding: 6px 15px;
  background: transparent;
  border: 1px solid var(--border-color-mode-button); /* USE VARIABLE */
  border-radius: 4px;
  color: var(--text-primary);
  cursor: pointer;
  transition: all 0.2s;
}

.mode-button.active {
  background: var(--text-accent);  /* FIX: was --ember-orange */
  color: var(--text-button-primary); /* FIX: was white */
  border-color: var(--text-accent); /* FIX: was --ember-orange */
}

/* Post topic indicators */
.post-topics {
  display: flex;
  gap: 6px;
  margin-top: 8px;
  flex-wrap: wrap;
}

.post-topic-tag {
  font-size: 12px;
  padding: 2px 8px;
  background: var(--background-topic-tag); /* USE VARIABLE */
  border-radius: 12px;
  color: var(--text-color-topic-tag); /* USE VARIABLE */
}

/* Topic tree visualization */
.topic-tree-node {
  padding: 4px 8px;
  margin: 2px 0;
  background: var(--background-topic-tree-node);      /* USE VARIABLE */
  border-left: 3px solid var(--border-color-topic-tree-node); /* USE VARIABLE */
  font-size: 12px;
}

.topic-tree-node.parent {
  border-left-color: var(--border-color-topic-tree-parent); /* USE VARIABLE */
}

.topic-tree-node.child {
  margin-left: 20px;
  border-left-color: var(--border-color-topic-tree-child); /* USE VARIABLE */
}
#column-controls {
  overflow-y: auto;
  padding-right: 10px; /* Consistent padding for the scrollbar */
}
.verified-badge {
    color: var(--text-accent);
    font-size: 14px;
    margin-left: 5px;
    opacity: 0.7;
}

.unverified-badge {
    color: var(--text-secondary);
    font-size: 14px;
    margin-left: 5px;
    animation: pulse 1s infinite;
}

.post.unverified {
    opacity: 0.8;
}
.reply-image-preview {
    position: relative;
    margin: 10px 0;
    border-radius: 8px;
    overflow: hidden;
    max-width: 200px;
}

.reply-image-preview img {
    width: 100%;
    height: auto;
    display: block;
    border-radius: 8px;
}

.reply-image-preview button {
    position: absolute;
    top: 5px;
    right: 5px;
    background: rgba(0, 0, 0, 0.8);
    color: white;
    border: none;
    border-radius: 50%;
    width: 24px;
    height: 24px;
    cursor: pointer;
    font-size: 16px;
    line-height: 1;
}

.reply-image-preview button:hover {
    background: rgba(255, 0, 0, 0.8);
}

/* Ensure the image button in replies matches the main compose */
.reply-compose .image-button {
    background: transparent;
    border: none;
    font-size: 20px;
    cursor: pointer;
    padding: 4px 8px;
    border-radius: 4px;
    transition: background 0.2s;
}

.reply-compose .image-button:hover {
    background: rgba(255, 140, 66, 0.1);
}

/* Direct Messages Panel */
/* ===============================================
   ENHANCED DM SYSTEM - EMBER THEMED
   =============================================== */

/* Direct Messages Panel - Make it resizable and ember-themed */
#dm-panel {
  position: fixed;
  right: 20px;
  bottom: 20px;
  width: 380px;
  min-width: 320px;
  max-width: 500px;
  height: 60vh;
  min-height: 400px;
  max-height: 80vh;
  background: linear-gradient(135deg, 
    rgba(5, 5, 5, 0.98) 0%, /* Nearly black */
    rgba(10, 5, 5, 0.98) 100%); /* Slightly reddish black */
  border: 1px solid var(--border-color-dark); /* #222 for subtle border */
  border-radius: 16px;
  display: flex;
  flex-direction: column;
  box-shadow: 
    0 0 40px rgba(204, 41, 54, 0.2), /* Darker orange/red: #cc2936 */
    0 10px 40px rgba(0, 0, 0, 0.5),
    inset 0 0 20px rgba(204, 41, 54, 0.05); /* Very subtle inset glow */
  z-index: 1000;
  overflow: hidden;
  resize: both;
  transition: all 0.3s ease;
  animation: dm-panel-enter 0.3s ease-out;
  display: flex;
  flex-direction: column;
  overflow: hidden; /* Important! */
}

@keyframes dm-panel-enter {
  from {
    opacity: 0;
    transform: translateY(20px) scale(0.95);
  }
  to {
    opacity: 1;
    transform: translateY(0) scale(1);
  }
}

/* Subtle glowing border effect */
#dm-panel::before {
  content: '';
  position: absolute;
  top: -2px; left: -2px; right: -2px; bottom: -2px;
  background: linear-gradient(45deg, 
    var(--text-accent-darker), /* #cc2936 */
    var(--shadow-color-ember-glow-1), /* rgba(255,107,74,0.7) */
    var(--text-accent-darker),
    transparent);
  border-radius: 16px;
  opacity: 0.3; /* Very subtle base opacity */
  z-index: -1;
  animation: subtle-pulse 6s ease-in-out infinite; /* Slower pulse */
}

@keyframes subtle-pulse {
  0%, 100% { opacity: 0.3; }
  50% { opacity: 0.25; } /* Minimal opacity change */
}


/* DM Header with ember particles */
.dm-header {
  padding: 18px 20px;
  background: linear-gradient(to bottom, 
    rgba(255, 140, 66, 0.15), 
    rgba(255, 140, 66, 0.05));
  border-bottom: 1px solid rgba(255, 140, 66, 0.3);
  display: flex;
  align-items: center;
  justify-content: space-between;
  position: relative;
  flex-shrink: 0;
}

/* Animated ember particles in header */
.dm-header::after {
  content: '‚ú®';
  position: absolute;
  bottom: -10px;
  left: 50%;
  font-size: 20px;
  opacity: 0;
  animation: ember-rise 4s ease-out infinite;
}

@keyframes ember-rise {
  0% {
    opacity: 0;
    transform: translateX(-50%) translateY(0);
  }
  20% {
    opacity: 0.8;
  }
  100% {
    opacity: 0;
    transform: translateX(-50%) translateY(-40px) scale(0.5);
  }
}

.dm-header h3 {
  margin: 0;
  font-size: 18px;
  color: var(--text-accent);
  font-weight: 600;
  display: flex;
  align-items: center;
  gap: 8px;
}

.dm-header h3 span {
  text-shadow: 0 0 10px var(--shadow-color-accent);
  animation: text-glow 2s ease-in-out infinite alternate;
}

@keyframes text-glow {
  from { text-shadow: 0 0 10px var(--shadow-color-accent); }
  to { text-shadow: 0 0 20px var(--shadow-color-accent), 0 0 30px var(--text-accent-hot); }
}

/* Stylish close button */
.close-button {
  background: rgba(255, 140, 66, 0.1);
  border: 1px solid rgba(255, 140, 66, 0.3);
  color: var(--text-accent);
  font-size: 18px;
  cursor: pointer;
  padding: 0;
  width: 32px;
  height: 32px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s;
}

.close-button:hover {
  background: var(--background-button-primary);
  color: var(--text-button-primary);
  transform: rotate(90deg) scale(1.1);
  box-shadow: 0 0 20px var(--shadow-color-accent);
}

/* Messages container with better scrolling */
.dm-messages {
  flex: 1 1 auto; /* Take available space */
  overflow-y: auto;
  overflow-x: hidden;
  padding: 20px;
  display: flex;
  flex-direction: column;
  gap: 12px;
  scroll-behavior: smooth;
  position: relative;
 /**** max-height: calc(60vh - 80px - 70px); /* Account for header and compose heights */
  /***justify-content: flex-end; /* New messages appear at the bottom */
}

/* Custom scrollbar for messages */
.dm-messages::-webkit-scrollbar {
  width: 6px;
}


.dm-messages::-webkit-scrollbar-track {
  background: var(--background-scrollbar-track); /* #0a0a0a in dark mode, #f0f0f0 in light mode */
  border-radius: 3px;
}


.dm-messages::-webkit-scrollbar-thumb {
  background: var(--background-scrollbar-thumb); /* #333 in dark mode, #cccccc in light mode */
  border-radius: 3px;
}


.dm-messages::-webkit-scrollbar-thumb:hover {
  background: var(--background-scrollbar-thumb-hover); /* #ff8c42 in both modes */
}


/* Message bubbles with proper text wrapping */
.dm-message {
  max-width: 75%;
  word-wrap: break-word;
  word-break: break-word;
  animation: message-appear 0.3s ease-out;
  position: relative;
}

@keyframes message-appear {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}


.dm-message.sent {
  align-self: flex-end;
  margin-left: 20%;
}

.dm-message.received {
  align-self: flex-start;
  margin-right: 20%;
}

/* Enhanced message content bubbles */
.dm-message-content {
  background: rgba(30, 30, 30, 0.8);
  padding: 12px 16px;
  border-radius: 18px;
  color: var(--text-primary); /* #e0e0e0 in dark mode */
  line-height: 1.4;
  font-size: 14px;
  position: relative;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
  backdrop-filter: blur(10px);
  overflow-wrap: break-word;
  hyphens: auto;
}


.dm-message.sent .dm-message-content {
  background: linear-gradient(135deg, 
    var(--background-button-primary) 0%, /* #ff8c42 */
    var(--background-button-primary-hover) 100%); /* #ff6b4a */
  color: var(--text-button-primary); /* #000 in dark mode, #ffffff in light mode */
  box-shadow: 
    0 2px 10px rgba(0, 0, 0, 0.3),
    0 0 20px rgba(255, 140, 66, 0.2);
}

/* Message tail (speech bubble effect) */
.dm-message.sent .dm-message-content::after {
  content: '';
  position: absolute;
  bottom: 0;
  right: -6px;
  width: 0;
  height: 0;
  border-style: solid;
  border-width: 0 0 12px 8px;
  border-color: transparent transparent var(--background-button-primary-hover) transparent;
}

.dm-message.received .dm-message-content::after {
  content: '';
  position: absolute;
  bottom: 0;
  left: -6px;
  width: 0;
  height: 0;
  border-style: solid;
  border-width: 0 8px 12px 0;
  border-color: transparent rgba(30, 30, 30, 0.8) transparent transparent;
}

/* Message timestamp */
.dm-message-time {
  font-size: 11px;
  color: var(--text-tertiary);
  margin-top: 4px;
  padding: 0 8px;
  opacity: 0.8;
  transition: opacity 0.2s;
}

.dm-message:hover .dm-message-time {
  opacity: 1;
}

/* Message status indicators */
.dm-message.sent .dm-message-time::after {
  content: ' ‚úì';
  color: var(--text-accent);
  opacity: 0.6;
}

.dm-message.sent.delivered .dm-message-time::after {
  content: ' ‚úì‚úì';
}

.dm-message.sent.read .dm-message-time::after {
  color: var(--text-accent-hot);
}

/* Compose area with ember effects */
.dm-compose {
  padding: 16px;
  background: linear-gradient(to top, 
    rgba(255, 140, 66, 0.08), 
    transparent);
  border-top: 1px solid rgba(255, 140, 66, 0.2);
  display: flex;
  gap: 12px;
  align-items: flex-end;
  position: relative;
  flex-shrink: 0;
 /**** order: 2; /* Ensure it stays at the bottom */
}

/* Typing indicator animation */
.dm-compose::before {
  content: '';
  position: absolute;
  top: -20px;
  left: 20px;
  display: none;
  font-size: 12px;
  color: var(--text-secondary);
  animation: typing-pulse 1.5s ease-in-out infinite;
}

.dm-compose.typing::before {
  content: 'Typing...';
  display: block;
}

@keyframes typing-pulse {
  0%, 100% { opacity: 0.5; }
  50% { opacity: 1; }
}

/* Enhanced input field */
#dm-input {
  flex: 1;
  background: rgba(10, 10, 10, 0.6);
  border: 1px solid rgba(255, 140, 66, 0.3);
  color: var(--text-primary);
  padding: 10px 16px;
  border-radius: 24px;
  resize: none;
  font-size: 14px;
  line-height: 1.4;
  max-height: 120px;
  transition: all 0.2s;
  backdrop-filter: blur(5px);
}

#dm-input:focus {
  outline: none;
  border-color: var(--text-accent);
  background: rgba(10, 10, 10, 0.8);
  box-shadow: 
    0 0 20px rgba(255, 140, 66, 0.2),
    inset 0 0 10px rgba(255, 140, 66, 0.05);
}

/* Send button with flame effect */
.dm-compose .primary-button {
  padding: 10px 20px;
  border-radius: 24px;
  font-weight: 600;
  position: relative;
  overflow: hidden;
  transition: all 0.3s;
}

.dm-compose .primary-button::before {
  content: 'üî•';
  position: absolute;
  top: 50%;
  left: -30px;
  transform: translateY(-50%);
  font-size: 20px;
  opacity: 0;
  transition: all 0.3s;
}

.dm-compose .primary-button:hover::before {
  left: 10px;
  opacity: 1;
}

.dm-compose .primary-button:hover {
  padding-left: 35px;
  box-shadow: 0 0 30px var(--shadow-color-accent);
}

/* Mobile responsiveness */
@media (max-width: 600px) {
  #dm-panel {
    right: 0;
    bottom: 0;
    left: 0;
    width: 100%;
    max-width: 100%;
    height: 100vh;
    max-height: 100vh;
    border-radius: 0;
    resize: none;
  }
  
  .dm-message {
    max-width: 85%;
  }
  
  .dm-message.sent {
    margin-left: 10%;
  }
  
  .dm-message.received {
    margin-right: 10%;
  }
}

/* Minimized state */
#dm-panel.minimized {
  height: 60px !important; /* Force the height */
  min-height: 60px !important;
  max-height: 60px !important; /* Add this */
  resize: none;
  overflow: hidden; /* Ensure nothing spills out */
}

#dm-panel.minimized .dm-messages,
#dm-panel.minimized .dm-compose {
  display: none !important; /* Force hide */
}

#dm-panel.minimized .dm-header {
  border-bottom: none;
  cursor: pointer;
}

/* Ensure the header stays visible and clickable when minimized */
#dm-panel.minimized .dm-header::after {
  display: none; /* Hide the ember particle animation when minimized */
}

/* Add minimize button to header */
.dm-header-controls {
  display: flex;
  gap: 8px;
}

.minimize-button {
  background: rgba(255, 140, 66, 0.1);
  border: 1px solid rgba(255, 140, 66, 0.3);
  color: var(--text-accent);
  font-size: 16px;
  cursor: pointer;
  padding: 0;
  width: 32px;
  height: 32px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s;
}

.minimize-button:hover {
  background: rgba(255, 140, 66, 0.2);
  transform: scale(1.1);
}

/* Light mode adjustments */
body.light-mode #dm-panel {
  background: linear-gradient(135deg, 
    rgba(255, 255, 255, 0.95) 0%,     /* Almost opaque white */
    rgba(255, 248, 245, 0.95) 100%);  /* Slight peachy tint but mostly white */
  border: 1px solid #fcd5b8;
  box-shadow: 
    0 0 20px rgba(255, 140, 66, 0.08),
    0 10px 30px rgba(0, 0, 0, 0.1);
}

body.light-mode .dm-header {
  background: linear-gradient(to bottom, 
    rgba(255, 140, 66, 0.15),   /* Stronger orange tint */
    rgba(255, 140, 66, 0.08));
  border-bottom: 1px solid rgba(255, 140, 66, 0.25);
}
body.light-mode .dm-header h3 {
  color: #d96d00; /* Darker orange for better contrast */
  text-shadow: none; /* Remove glow in light mode */
}
body.light-mode .dm-messages:empty::after {
  color: #888; /* Darker grey for readability */
}

body.light-mode .dm-compose {
  background: rgba(255, 255, 255, 0.8);
  border-top: 1px solid rgba(255, 140, 66, 0.2);
}

body.light-mode #dm-panel::before {
  display: none; /* Just remove the animated border glow in light mode */
}

body.light-mode .dm-message-content {
  background: rgba(240, 240, 240, 0.9);
  color: var(--text-primary); /* #1a1a1a for black text in light mode */
}

body.light-mode .dm-message.sent .dm-message-content {
  background: linear-gradient(135deg, 
    var(--background-button-primary) 0%, /* #ff8c42 */
    var(--background-button-primary-hover) 100%); /* #ff6b4a */
  color: var(--text-button-primary); /* #ffffff */
}
body.light-mode .dm-message.received .dm-message-content {
  background: #f5f5f5;  /* Light grey instead of almost white */
  border: 1px solid #e0e0e0; /* Add a subtle border */
  color: #1a1a1a;
}
body.light-mode #dm-input {
  background: rgba(255, 255, 255, 0.8);
  border-color: rgba(255, 107, 74, 0.7);
  color: #1a1a1a; /* Dark text on light background - ADD THIS */
}


body.light-mode #dm-input:focus {
  background: rgba(255, 255, 255, 0.95);
  border-color: #cc2936;
  color: #1a1a1a; /* Dark text on light background - ADD THIS */
}
body.light-mode #dm-input::placeholder {
  color: #666; /* Medium grey placeholder */
  opacity: 1;
}
body.light-mode .dm-messages::-webkit-scrollbar-track {
  background: #f0f0f0; /* Light grey background */
}

body.light-mode .dm-messages::-webkit-scrollbar-thumb {
  background: #cccccc; /* Medium grey thumb */
}

body.light-mode .dm-messages::-webkit-scrollbar-thumb:hover {
  background: #ff8c42; /* Keep the orange on hover */
}


/* Enhanced DM button animation in posts */
.dm-button {
  position: relative;
  overflow: hidden;
}

.dm-button::after {
  content: 'üíå';
  position: absolute;
  top: 50%;
  left: -30px;
  transform: translateY(-50%);
  opacity: 0;
  transition: all 0.3s;
}

.dm-button:hover::after {
  left: 50%;
  transform: translateX(-50%) translateY(-50%);
  opacity: 0.8;
}

/* Status indicators for DM panel */
.dm-status {
  display: inline-block;
  width: 8px;
  height: 8px;
  border-radius: 50%;
  margin-left: 8px;
  background: #4CAF50;
  animation: pulse 2s infinite;
}

.dm-status.offline {
  background: var(--text-tertiary);
  animation: none;
}

.dm-status.typing {
  background: var(--text-accent);
  animation: pulse 0.8s infinite;
}

/* Message reactions (future enhancement) */
.dm-message-reactions {
  display: flex;
  gap: 4px;
  margin-top: 4px;
  flex-wrap: wrap;
}

.dm-reaction {
  background: rgba(255, 140, 66, 0.1);
  border: 1px solid rgba(255, 140, 66, 0.2);
  border-radius: 12px;
  padding: 2px 8px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s;
}

.dm-reaction:hover {
  background: rgba(255, 140, 66, 0.2);
  transform: scale(1.1);
}

/* Empty state enhancement */
.dm-messages:empty::after {
  content: 'Start a conversation üî•';
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: var(--text-tertiary);
  font-style: italic;
  opacity: 0.5;
}

/* Loading state for messages */
.dm-message.loading .dm-message-content {
  background: linear-gradient(90deg, 
    rgba(255, 140, 66, 0.1) 0%, 
    rgba(255, 140, 66, 0.2) 50%, 
    rgba(255, 140, 66, 0.1) 100%);
  background-size: 200% 100%;
  animation: loading-shimmer 1.5s ease-in-out infinite;
}

@keyframes loading-shimmer {
  0% { background-position: 200% 0; }
  100% { background-position: -200% 0; }
}


/* DM Inbox Styles */
#dm-inbox {
  margin-top: 20px;
  background: var(--background-bonfire-item);
  border-radius: 12px;
  border: 1px solid var(--border-color-light);
  overflow: hidden;
  position: relative;
}

#dm-inbox::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 100px;
  background: radial-gradient(ellipse at center top, 
    var(--shadow-color-ember-glow-1) 0%, 
    transparent 70%);
  opacity: 0.3;
  pointer-events: none;
  animation: smoke-rise 8s ease-in-out infinite;
}

@keyframes smoke-rise {
  0%, 100% { transform: translateY(0) scale(1); opacity: 0.3; }
  50% { transform: translateY(-20px) scale(1.1); opacity: 0.5; }
}

.dm-inbox-header {
  padding: 15px;
  background: linear-gradient(to bottom, 
    rgba(255, 140, 66, 0.1), 
    transparent);
  border-bottom: 1px solid var(--border-color-light);
  position: relative;
}

.dm-inbox-header h3 {
  margin: 0;
  color: var(--text-accent);
  font-size: 16px;
  display: flex;
  align-items: center;
  gap: 8px;
}

.dm-inbox-header h3::before {
  content: 'üíå';
  font-size: 20px;
  animation: pulse 2s infinite;
}

.dm-conversations {
  max-height: 300px;
  overflow-y: auto;
}

.dm-conversation-item {
  padding: 12px 15px;
  border-bottom: 1px solid var(--border-color-dark);
  cursor: pointer;
  transition: all 0.2s;
  position: relative;
  overflow: hidden;
}

.dm-conversation-item::after {
  content: '';
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  height: 2px;
  background: linear-gradient(to right, 
    transparent, 
    var(--text-accent), 
    transparent);
  transform: translateX(-100%);
  transition: transform 0.3s;
}

.dm-conversation-item:hover {
  background: rgba(255, 140, 66, 0.1);
}

.dm-conversation-item:hover::after {
  transform: translateX(0);
}

.dm-conversation-item.unread {
  background: rgba(255, 140, 66, 0.15);
  border-left: 3px solid var(--text-accent);
}

.dm-sender {
  font-weight: bold;
  color: var(--text-accent);
  margin-bottom: 4px;
  display: flex;
  align-items: center;
  gap: 8px;
}

.dm-sender .ember-indicator {
  font-size: 10px;
  animation: flicker 3s ease-in-out infinite;
}

.dm-preview {
  font-size: 13px;
  color: var(--text-secondary);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.dm-time {
  font-size: 11px;
  color: var(--text-tertiary);
  position: absolute;
  top: 12px;
  right: 15px;
}

.dm-empty-state {
  padding: 40px 20px;
  text-align: center;
  color: var(--text-tertiary);
  font-style: italic;
}

.dm-empty-state::before {
  content: 'üî•';
  display: block;
  font-size: 40px;
  margin-bottom: 10px;
  opacity: 0.3;
  animation: pulse 4s infinite;
}

/* Light mode adjustments */
body.light-mode #dm-inbox::before {
  background: radial-gradient(ellipse at center top, 
    rgba(255, 140, 66, 0.2) 0%, 
    transparent 70%);
}

body.light-mode .dm-conversation-item.unread {
  background: rgba(255, 140, 66, 0.08);
}
/* Drawer System */
.column-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-bottom: 10px;
  margin-bottom: 20px;
  border-bottom: 1px solid var(--border-color-light);
}

.drawer-tabs {
  display: flex;
  gap: 5px;
}

.drawer-tab {
  background: transparent;
  border: 1px solid var(--border-color-light);
  color: var(--text-secondary);
  padding: 6px 12px;
  border-radius: 20px;
  font-size: 12px;
  display: flex;
  align-items: center;
  gap: 5px;
  position: relative;
  transition: all 0.3s ease;
}

.drawer-tab:hover {
  border-color: var(--text-accent);
  color: var(--text-accent);
  transform: translateY(-1px);
  box-shadow: 0 2px 10px var(--shadow-color-accent);
}

.drawer-tab.active {
  background: var(--background-button-primary);
  color: var(--text-button-primary);
  border-color: var(--background-button-primary);
  box-shadow: 0 0 20px var(--shadow-color-accent);
}

.drawer-tab .tab-icon {
  font-size: 16px;
  animation: subtle-pulse 3s ease-in-out infinite;
}

.drawer-tab.active .tab-icon {
  animation: active-glow 2s ease-in-out infinite;
}

.drawer-tab .tab-label {
  display: none; /* Hide on small screens */
}

@media (min-width: 1200px) {
  .drawer-tab .tab-label {
    display: inline;
  }
}

.unread-badge {
  position: absolute;
  top: -5px;
  right: -5px;
  background: var(--text-accent-hot);
  color: var(--text-button-primary);
  font-size: 10px;
  font-weight: bold;
  padding: 2px 6px;
  border-radius: 10px;
  min-width: 18px;
  text-align: center;
  animation: bounce 2s ease-in-out infinite;
}

@keyframes bounce {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.1); }
}

@keyframes subtle-pulse {
  0%, 100% { opacity: 0.7; }
  50% { opacity: 1; }
}

@keyframes active-glow {
  0%, 100% { 
    filter: drop-shadow(0 0 3px currentColor);
    transform: scale(1);
  }
  50% { 
    filter: drop-shadow(0 0 8px currentColor);
    transform: scale(1.05);
  }
}

/* Drawer Container */
.drawer-container {
  position: relative;
  flex: 1;
  overflow: hidden;
}

.drawer-content {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  opacity: 0;
  transform: translateX(100%);
  transition: all 0.3s ease;
  overflow-y: auto;
  padding-right: 10px;
}

.drawer-content.active {
  opacity: 1;
  transform: translateX(0);
}

/* Slide effect for drawer transitions */
.drawer-content.slide-out-left {
  transform: translateX(-100%);
}

.drawer-content.slide-in-right {
  animation: slideInRight 0.3s ease forwards;
}

@keyframes slideInRight {
  from { transform: translateX(100%); opacity: 0; }
  to { transform: translateX(0); opacity: 1; }
}

/* Network Visualization Styles */
#network-stats {
  padding: 20px;
}

.network-visualization {
  background: var(--background-bonfire-item);
  border-radius: 12px;
  padding: 20px;
  margin-bottom: 20px;
  position: relative;
  overflow: hidden;
}

.network-visualization::before {
  content: '';
  position: absolute;
  top: -50%;
  left: -50%;
  width: 200%;
  height: 200%;
  background: radial-gradient(circle, var(--shadow-color-ember-glow-1) 0%, transparent 70%);
  opacity: 0.1;
  animation: rotate 20s linear infinite;
}

@keyframes rotate {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}

#network-canvas {
  width: 100%;
  height: 200px;
  position: relative;
  z-index: 1;
}

.network-details h4 {
  color: var(--text-accent);
  margin-bottom: 15px;
}

#network-metrics {
  display: grid;
  gap: 10px;
}

.metric-item {
  background: var(--background-bonfire-item);
  padding: 10px 15px;
  border-radius: 8px;
  border-left: 3px solid var(--border-color-accent);
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.metric-label {
  color: var(--text-secondary);
  font-size: 13px;
}

.metric-value {
  color: var(--text-accent);
  font-weight: bold;
  font-size: 16px;
}

/* Update DM inbox styles for drawer mode */
#inbox-drawer #dm-inbox {
  background: transparent;
  border: none;
  margin-top: 0;
}

#inbox-drawer #dm-inbox::before {
  display: none; /* Remove smoke effect in drawer mode */
}

/* Light mode adjustments */
body.light-mode .drawer-tab {
  background: var(--background-bonfire-item);
}

body.light-mode .drawer-tab.active {
  background: var(--background-button-primary);
}

/* Community Rating System Styles */
.rating-display {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    margin-left: 15px;
    font-size: 14px;
}

.rating-score {
    font-weight: bold;
    color: var(--text-accent);
    padding: 2px 8px;
    background: rgba(255, 140, 66, 0.1);
    border-radius: 12px;
    font-size: 13px;
}

.rating-confidence {
    opacity: 0.7;
    font-size: 12px;
    color: var(--text-secondary);
}

.rating-buttons {
    display: inline-flex;
    gap: 8px;
    margin-left: auto;
}

.rate-up, .rate-down {
    background: transparent;
    border: 1px solid var(--border-color-light);
    border-radius: 16px;
    padding: 4px 10px;
    cursor: pointer;
    font-size: 13px;
    transition: all 0.2s;
    display: inline-flex;
    align-items: center;
    gap: 4px;
}

.rate-up:hover {
    border-color: #4CAF50;
    background: rgba(76, 175, 80, 0.1);
    color: #4CAF50;
    transform: translateY(-1px);
}

.rate-down:hover {
    border-color: #f44336;
    background: rgba(244, 67, 54, 0.1);
    color: #f44336;
    transform: translateY(-1px);
}

.rate-up.active {
    background: #4CAF50;
    color: white;
    border-color: #4CAF50;
    box-shadow: 0 0 10px rgba(76, 175, 80, 0.3);
}

.rate-down.active {
    background: #f44336;
    color: white;
    border-color: #f44336;
    box-shadow: 0 0 10px rgba(244, 67, 54, 0.3);
}

.vote-count {
    font-size: 11px;
    opacity: 0.8;
    font-weight: normal;
}

/* Animate rating changes */
@keyframes rating-pulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.1); }
    100% { transform: scale(1); }
}

.rating-score.updating {
    animation: rating-pulse 0.3s ease-out;
}

/* Light mode adjustments for ratings */
body.light-mode .rating-score {
    background: rgba(217, 109, 0, 0.1);
}

body.light-mode .rate-up:hover {
    background: rgba(76, 175, 80, 0.05);
}

body.light-mode .rate-down:hover {
    background: rgba(244, 67, 54, 0.05);
}

/*
  ==========================================================================
  NEW: PROFILE MODAL STYLES
  ==========================================================================
*/
.clickable-author {
  cursor: pointer;
  text-decoration: underline;
  text-decoration-color: rgba(255, 140, 66, 0.5);
  transition: color 0.2s, text-decoration-color 0.2s;
}
.clickable-author:hover {
  color: var(--text-accent-hot);
  text-decoration-color: var(--text-accent-hot);
}

#profile-modal-overlay {
  z-index: 2500; /* Above loading, below identity */
  backdrop-filter: blur(5px);
}

#profile-modal {
  width: 90vw;
  max-width: 700px;
  height: 80vh;
  max-height: 800px;
  background: var(--profile-bg, #1a1a1a);
  color: var(--profile-text, #e0e0e0);
  border-radius: 16px;
  border: 2px solid var(--profile-accent, #ff1493);
  box-shadow: 0 0 50px rgba(0,0,0,0.5), 0 0 30px var(--profile-accent, #ff1493);
  display: flex;
  flex-direction: column;
  overflow: hidden;
  position: relative;
  transition: background 0.5s, color 0.5s, border-color 0.5s;
}

.close-profile-button {
  position: absolute;
  top: 15px;
  right: 15px;
  background: rgba(0,0,0,0.5);
  color: white;
  border: 1px solid white;
  width: 30px;
  height: 30px;
  border-radius: 50%;
  cursor: pointer;
  z-index: 10;
}

#profile-content {
  flex-grow: 1;
  overflow-y: auto;
  padding: 20px;
  display: flex;
  flex-direction: column;
}

.profile-header {
  display: flex;
  gap: 20px;
  padding-bottom: 20px;
  border-bottom: 1px solid var(--profile-accent, #ff1493);
  margin-bottom: 20px;
}

.profile-picture-container {
  flex-shrink: 0;
}

.profile-picture {
  width: 120px;
  height: 120px;
  border-radius: 50%;
  border: 4px solid var(--profile-accent, #ff1493);
  object-fit: cover;
}

.profile-picture-placeholder {
  width: 120px;
  height: 120px;
  border-radius: 50%;
  background: #333;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 50px;
  border: 4px solid var(--profile-accent, #ff1493);
}

.profile-info {
  flex-grow: 1;
}

.profile-handle {
  font-size: 28px;
  font-weight: bold;
  color: var(--profile-accent, #ff1493);
  margin-bottom: 10px;
}

.profile-bio {
  font-size: 16px;
  margin-bottom: 15px;
  font-style: italic;
  color: var(--profile-text, #e0e0e0);
}

.edit-profile-button {
  background: transparent;
  border: 1px solid var(--profile-accent, #ff1493);
  color: var(--profile-accent, #ff1493);
}

.profile-posts {
  flex-grow: 1;
  display: flex;
  flex-direction: column;
}

.profile-posts h3 {
  color: var(--profile-accent, #ff1493);
  border-bottom: 1px solid var(--profile-accent, #ff1493);
  padding-bottom: 5px;
  margin-bottom: 10px;
}

.profile-posts-list {
  overflow-y: auto;
  flex-grow: 1;
}

.profile-post-item {
  background: rgba(255,255,255,0.05);
  padding: 10px;
  border-radius: 8px;
  margin-bottom: 10px;
  cursor: pointer;
  transition: background 0.2s;
}
.profile-post-item:hover {
  background: rgba(255,255,255,0.1);
}
.profile-post-content {
  margin-bottom: 5px;
}
.profile-post-meta {
  font-size: 12px;
  color: var(--text-secondary);
  display: flex;
  justify-content: space-between;
}

/* Profile Editor Styles */
.profile-editor {
  display: flex;
  flex-direction: column;
  gap: 20px;
}
.profile-editor-section {
  background: rgba(255,255,255,0.05);
  padding: 15px;
  border-radius: 8px;
}
.profile-editor label {
  display: block;
  margin-bottom: 10px;
  font-weight: bold;
  color: var(--profile-accent, #ff1493);
}
.profile-editor textarea {
  width: 100%;
  min-height: 80px;
  background: var(--background-input);
  color: var(--text-primary);
  border: 1px solid var(--border-color-light);
  border-radius: 4px;
  padding: 8px;
}
.profile-picture-editor {
  display: flex;
  align-items: center;
  gap: 20px;
}
.current-picture img, .current-picture .profile-picture-placeholder {
  width: 80px;
  height: 80px;
}
#profile-picture-preview {
  margin-top: 10px;
}
#profile-picture-preview img {
  max-width: 150px;
  border-radius: 8px;
}
.color-inputs {
  display: flex;
  gap: 20px;
}
.color-input-group input[type="color"] {
  width: 50px;
  height: 50px;
  border: none;
  padding: 0;
  border-radius: 8px;
  cursor: pointer;
}
.profile-editor-actions {
  display: flex;
  justify-content: flex-end;
  gap: 10px;
}

/* User Profile Section in Control Panel */
.user-profile-section {
  margin: 20px 0;
  padding: 15px;
  background: var(--background-compose-area);
  border-radius: 12px;
  border: 1px solid var(--border-color-light);
  transition: all 0.3s ease;
}

.user-profile-header {
  display: flex;
  align-items: center;
  gap: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.user-profile-header:hover {
  transform: translateX(5px);
}

.user-profile-pic {
  flex-shrink: 0;
  position: relative;
}

.user-profile-pic img,
.profile-picture-placeholder-small {
  width: 48px;
  height: 48px;
  border-radius: 50%;
  border: 2px solid var(--border-color-accent);
  object-fit: cover;
  transition: all 0.2s ease;
}

.profile-picture-placeholder-small {
  background: var(--background-bonfire-item);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 24px;
}

.user-profile-header:hover .user-profile-pic img,
.user-profile-header:hover .profile-picture-placeholder-small {
  border-color: var(--text-accent-hot);
  box-shadow: 0 0 20px var(--shadow-color-accent);
}

.user-profile-info {
  flex-grow: 1;
  min-width: 0; /* Prevent overflow */
}

.user-profile-handle {
  font-weight: bold;
  color: var(--text-accent);
  font-size: 16px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  margin-bottom: 2px;
}

.user-profile-hint {
  font-size: 12px;
  color: var(--text-secondary);
  opacity: 0;
  transition: opacity 0.2s ease;
}

.user-profile-header:hover .user-profile-hint {
  opacity: 1;
}

/* Ember effect on hover */
.user-profile-section::before {
  content: 'üî•';
  position: absolute;
  top: 10px;
  right: 10px;
  font-size: 16px;
  opacity: 0;
  transition: all 0.3s ease;
  animation: flicker 2s ease-in-out infinite;
}

.user-profile-section:hover::before {
  opacity: 0.6;
}

/* Light mode adjustments */
body.light-mode .user-profile-section {
  background: var(--background-compose-area);
  border-color: var(--border-color-topic-section);
}

body.light-mode .profile-picture-placeholder-small {
  background: var(--background-bonfire-item);
}

body.light-mode .user-profile-header:hover .user-profile-pic img,
body.light-mode .user-profile-header:hover .profile-picture-placeholder-small {
  box-shadow: 0 0 15px rgba(255, 140, 66, 0.3);
}

/* Author section with profile pic */
.author-section {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 12px;
}

.author-profile-pic {
  width: 32px;
  height: 32px;
  border-radius: 50%;
  border: 2px solid var(--border-color-accent);
  object-fit: cover;
  flex-shrink: 0;
  transition: all 0.2s ease;
}

.author-profile-placeholder {
  background: var(--background-bonfire-item);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 16px;
  color: var(--text-secondary);
}

/* Hover effect on author section */
.author-section:hover .author-profile-pic {
  border-color: var(--text-accent-hot);
  box-shadow: 0 0 15px var(--shadow-color-accent);
  transform: scale(1.1);
}

/* Make the whole author section clickable */
.author-section {
  cursor: pointer;
}

/* Adjust existing author styles */
.author-section .author {
  margin-bottom: 0; /* Remove the margin since it's now in author-section */
}

/* Light mode adjustments */
body.light-mode .author-profile-placeholder {
  background: var(--background-topic-tag);
}


========================================
--- FILE: config.js
========================================
export const CONFIG = {
  MAX_POSTS: 1000,
  MAX_POST_SIZE: 1120,
  MAX_PEERS: 50,
  MAX_MESSAGE_SIZE: 1 * 1024 * 1024, // 1MB
  RATE_LIMIT_MESSAGES: 50,
  RATE_LIMIT_WINDOW: 60_000,
  GARBAGE_COLLECT_INTERVAL: 60_000,
  CARRIER_UPDATE_INTERVAL: 30_000,
  TOXICITY_THRESHOLD: 0.9,
  LOCAL_MODE: false,
  IDENTITY_CONFIRMATION_THRESHOLD: 1,
  NSFWJS_MODEL_PATH: 'nsfwjs-model/',
  TRUST_THRESHOLD: 30, // Minimum trust score to skip verification
  ATTESTATION_TIMEOUT: 1000, // Max time to wait for attestations (1 second)
  MAX_PENDING_MESSAGES: 100, // Max messages to queue per peer before handshake
};


========================================
--- FILE: main.js
========================================
// FILE: main.js
// main.js
// This is the main entry point and orchestrator for the entire application.
// It initializes all modules, manages the global state, and wires up event handlers.

// --- 1. IMPORTS ---
import { getContentSafety, setRulePackPath, reloadRulePack  } from './services/content-safety-wrapper.js';
import * as tf from '@tensorflow/tfjs';                 //  for nsfwjs
import '@tensorflow/tfjs-backend-cpu';               //  for nsfwjs
import nacl from 'tweetnacl'; 
import * as nsfwjs from 'nsfwjs';
import DOMPurify from 'dompurify';
import { CONFIG } from './config.js';
import { Post } from './models/post.js';
import { VerificationQueue } from './verification-queue.js';
import { KademliaDHT } from './p2p/dht.js';

// --- 2. IMPORT SHARED STATE & SERVICES ---
import { initializeServices, getServices } from './services.js';

import { state } from './state.js';
import { messageBus } from './p2p/message-bus.js';
import { setServiceCallbacks } from './services/callbacks.js';


import {
    currentDMRecipient, addMessageToConversation, applyTheme, setupThemeToggle, 
    showConnectScreen, updateLoadingMessage, renderPost, refreshPost, dropPost, 
    updateStatus, notify, loadTopicSubscriptions, updateTopicFilter, addTopicToUI, 
    updateAges, updateTopicStats, handleImageSelect, removeImage, toggleReplyForm, 
    discoverAndFilterTopic, filterByTopic, setFeedMode, completeTopicSuggestion, 
    scrollToPost, subscribeToTopic, handleReplyImageSelect, removeReplyImage, 
    storeDMLocallyAndUpdateUI, updateDMInbox, updateUnreadBadge, toggleThread,
    openProfileForHandle, renderProfile, closeProfile, updateProfilePicturesInPosts, initializeUserProfileSection, setSendPeer,updateHotTopics
} from './ui.js';
import { StateManager } from './storage.js';
import { MemoryManager } from './services/memory-manager.js';
import { PeerManager } from './services/peer-manager.js';
import { ContentAddressedImageStore } from './services/image-store.js';
import { createNewIdentity } from './identity/identity-flow.js';
import { IdentityRegistry } from './identity/identity-manager.js';
import { ProgressiveVDF } from './identity/vdf.js';
import { initNetwork, registerHandler, sendPeer, broadcast } from './p2p/network-manager.js';
import { NoiseGenerator } from './p2p/noise-generator.js';
import { TrafficMixer } from './p2p/traffic-mixer.js';
//import { DandelionRouter } from './p2p/dandelion.js';
import { HierarchicalBloomFilter, BloomFilter, generateId, isReply, arrayBufferToBase64, base64ToArrayBuffer, JSONStringifyWithBigInt, JSONParseWithBigInt } from './utils.js';
import wasmVDF from './vdf-wrapper.js'; 
import { EpidemicGossip } from './p2p/epidemic-gossip.js';
import { HyParView } from './p2p/hyparview.js';
import { Scribe } from './p2p/scribe.js';
import { routingManager } from './services/routing-manager.js';


// Get service references
let stateManager, verificationQueue, imageStore, peerManager, memoryManager;
let progressiveVDF, noiseGenerator, trafficMixer, epidemicGossip;

// --- EXPORTS for other modules to import handler functions ---
export {
  // Core post handlers
  handleNewPost,
  handlePostsResponse,
  handleVerificationResults,

  // Identity and Attestation
  handleProvisionalClaim,
  handleConfirmationSlip,
  generateAndBroadcastAttestation,
  evaluatePostTrust,
  scheduleTrustEvaluation,
  hashClaim,

  // Post interaction handlers
  createPostWithTopics,
  createReply,
  toggleCarry,
  handleCarrierUpdate,
  handleParentUpdate,
  findRootPost,
  
  // Rating system
  ratePost,
  handlePostRating,

  // Content checking
  isToxic,
  isImageToxic,

  // Direct Messaging
  sendDirectMessage,
  handleDirectMessage,

  // Profile system
  broadcastProfileUpdate,
  subscribeToProfile,
  unsubscribeFromProfile,
  handleProfileUpdate,
  
  // P2P Protocol and Network Management
  initializeP2PProtocols,
  initNetworkWithTempId,
  handleScribeMessage,
  sendToPeer,
  findPeerByHandle,

  // Maintenance and Debugging
  startMaintenanceLoop,
  maintenanceInterval,
  debugPostRemoval
};

// Trust evaluation system for incoming posts
const trustEvaluationTimers = new Map(); // postId -> timer





// --- 4. CORE LOGIC & HANDLERS ---
function applyConfigToUI() {
  const postInput = document.getElementById('post-input');
  if (postInput) {
    postInput.maxLength = CONFIG.MAX_POST_SIZE;
  }

  const charCountDisplay = document.querySelector('#compose .char-count');
  if (charCountDisplay) {
    charCountDisplay.innerHTML = `<span id="char-current">0</span>/${CONFIG.MAX_POST_SIZE}`;
  }
}

async function initImageFilter() {
    try {
        state.imageClassifier = await nsfwjs.load(CONFIG.NSFWJS_MODEL_PATH);
        console.log("Image filter model ready");
    } catch (e) {
        console.error("Image filter failed to load:", e);
    }
}


async function initContentFilter() {
  try {
    // Use the new content safety filter
    state.toxicityClassifier = await getContentSafety();
    console.log("Content safety filter ready");
  } catch (e) {
    console.error("Content safety filter failed:", e);
  }
}

async function handlePostAttestation(msg, fromWire) {
  const { attestation, attesterHandle, attesterPublicKey, signature } = msg;
  
  if (!attestation || !attesterHandle || !attesterPublicKey || !signature) {
    console.warn('[Attestation] Invalid attestation message format');
    return;
  }
  
  // Verify the signature
  try {
    const dataToVerify = JSON.stringify(attestation);
    const publicKey = base64ToArrayBuffer(attesterPublicKey);
    const sig = base64ToArrayBuffer(signature);
    
    const verified = nacl.sign.open(sig, publicKey);
    if (!verified) {
      console.warn(`[Attestation] Invalid signature from ${attesterHandle}`);
      return;
    }
    
    const decodedData = new TextDecoder().decode(verified);
    if (decodedData !== dataToVerify) {
      console.warn(`[Attestation] Signature mismatch from ${attesterHandle}`);
      return;
    }
  } catch (e) {
    console.error('[Attestation] Signature verification failed:', e);
    return;
  }
  
  // Check attestation age (prevent replay attacks)
  const age = Date.now() - attestation.timestamp;
  if (age > 60000) { // Reject attestations older than 1 minute
    console.warn(`[Attestation] Attestation too old: ${age}ms`);
    return;
  }
  
  // Get attester's reputation
  const peerId = fromWire.peerId;
  const reputation = getServices().peerManager.getScore(peerId);
  const canTrust = getServices().peerManager.canTrustAttestations(peerId);
  
  console.log(`[Attestation] Received from ${attesterHandle} (rep: ${reputation.toFixed(2)}, trusted: ${canTrust})`);
  
  // Find the post (could be in pendingVerification or already in posts)
  let post = state.pendingVerification.get(attestation.postId);
  if (!post) {
    post = state.posts.get(attestation.postId);
  }
  
  if (!post) {
    console.log(`[Attestation] Post ${attestation.postId} not found`);
    return;
  }
  
  // Add attestation to the post
  const wasNew = post.addAttestation(attesterHandle, reputation);
  
  if (wasNew) {
    console.log(`[Attestation] Added to post ${attestation.postId}, trust score: ${post.trustScore.toFixed(2)}`);
    
    // Track attestation for reputation
    getServices().peerManager.updateScore(peerId, 'attestation', 1);
    
    // Nudge the verifier so we don't wait for the next scheduled sweep
    if (state.pendingVerification.has(attestation.postId)) { 
        evaluatePostTrust(attestation.postId); 
    }
    
    // If post is still pending and now has enough trust, promote it
    if (state.pendingVerification.has(attestation.postId) && 
        post.hasSufficientTrust(CONFIG.TRUST_THRESHOLD)) {
      console.log(`[Attestation] Post ${attestation.postId} reached trust threshold, promoting without verification`);
      
      // Move from pending to verified
      state.pendingVerification.delete(attestation.postId);
      post.verified = true;
      state.posts.set(post.id, post);
      renderPost(post);
      notify(`Post verified by peer attestations`);
      
      // The attester gets credit for a correct attestation
      getServices().peerManager.updateScore(peerId, 'correct_attestation', 1);
    }
  }
}

async function isToxic(text) {
  if (!state.toxicityClassifier) return false;
  
  try {
    const result = await state.toxicityClassifier.checkContent(text);
    
    if (result.shouldBlock) {
      // Return the most severe violation type
      const violation = result.violations[0];
      return violation.type.toUpperCase();
    }
    
    return false;
  } catch (e) {
    console.error("Content check failed:", e);
    return false;
  }
}

async function isImageToxic(imageData) {
    if (!state.imageClassifier) return false;
    try {
        const img = new Image();
        img.src = imageData;
        await new Promise((resolve) => img.onload = resolve);
        const predictions = await state.imageClassifier.classify(img);
        const problematic = predictions.find(p => {
            if (p.className === 'Porn' && p.probability > 0.7) return true;
            if (p.className === 'Hentai' && p.probability > 0.7) return true;
            if (p.className === 'Sexy' && p.probability > 0.8) return true;
            return false;
        });
        return problematic ? problematic.className : false;
    } catch (e) {
        console.error("Image classification failed:", e);
        return false;
    }
}

async function handleNewPost(data, fromWire) {
  const postData = data.post || data;

  if (!postData?.id || state.posts.has(postData.id) || state.seenPosts.has(postData.id)) {
    return;
  }
  if (postData.content.length > CONFIG.MAX_POST_SIZE) {
    return;
  }
  // Quick pattern check for received content
    if (await isToxic(postData.content)) {
      notify(`Blocked harmful content from ${postData.author}`);
      console.warn(`Blocked harmful content from ${postData.author}`);
      if (fromWire) {
        peerManager.updateScore(fromWire.peerId, 'harmful_content', -50);
      }
      return;
    }

  state.seenPosts.add(postData.id);
  const p = Post.fromJSON(postData);
  state.pendingVerification.set(p.id, p);

  //  Use trust-based verification flow
  console.log(`[Trust] New post ${p.id} from ${p.author}, scheduling trust evaluation`);
  scheduleTrustEvaluation(p);

  // Continue broadcasting
  broadcast({ type: "new_post", post: postData }, fromWire);
}



function findRootPost(postId) {
  let current = postId;
  let post = state.posts.get(current);
  const visited = new Set();
  
  while (post && post.parentId && !visited.has(current)) {
    visited.add(current);
    current = post.parentId;
    post = state.posts.get(current);
  }
  
  return current;
}

async function handlePostsResponse(list, fromWire) {
  if (!Array.isArray(list)) return;

  console.log(`Received ${list.length} posts, queuing for trust evaluation...`);
  const postsToEvaluate = [];
  
  for (const postData of list) {
    if (!postData?.id || state.posts.has(postData.id) || state.seenPosts.has(postData.id)) {
      continue;
    }
    if (postData.content.length > CONFIG.MAX_POST_SIZE) {
      continue;
    }
    state.seenPosts.add(postData.id);
    const p = Post.fromJSON(postData);
    state.pendingVerification.set(p.id, p);
    postsToEvaluate.push(p);
  }

  if (postsToEvaluate.length > 0) {
    // Sort by timestamp (oldest first)
    postsToEvaluate.sort((a, b) => a.timestamp - b.timestamp);
    
    // Schedule trust evaluation for each post
    postsToEvaluate.forEach(post => {
      console.log(`[Trust] Scheduling evaluation for ${post.id}`);
      scheduleTrustEvaluation(post);
    });
  }
}

async function handleVerificationResults(results) {
    let newlyVerifiedCount = 0;
    console.log(`[Debug] Processing ${results.length} verification results`);
    for (const result of results) {
        const post = state.pendingVerification.get(result.id);
        if (!post) continue;

        if (result.valid) {
            post.verified = true;
            let identityStatus = 'unknown';
            if (state.identityRegistry) {
                try {
                    const claim = await state.identityRegistry.lookupHandle(post.author);
                    if (claim) {
                        const identityValid = await state.identityRegistry.verifyAuthorIdentity(post);
                        identityStatus = identityValid ? 'verified' : 'mismatch';
                    }
                } catch (e) {
                    console.warn(`Identity check error for ${post.author}:`, e);
                }
            }

            post.identityStatus = identityStatus;
            if (identityStatus === 'mismatch') {
                console.warn(`Rejecting post from ${post.author} - identity mismatch!`);
                state.pendingVerification.delete(result.id);
                continue;
            }

            // MODIFIED IMAGE HANDLING LOGIC
            if (post.imageHash && !post.imageData) {
                const imageData = await imageStore.retrieveImage(post.imageHash);
                if (!imageData) {
                    // Image is not ready. Request it and defer rendering.
                    console.log(`[Image] Post ${post.id} is valid but awaiting image data. Requesting from peers.`);
                    const peers = Array.from(state.peers.values()).slice(0, 3);
                    for (const peer of peers) {
                        sendPeer(peer.wire, { type: "request_image", imageHash: post.imageHash });
                    }
                    // Skip the rest of this loop, leaving the post in pendingVerification.
                    continue;
                }
                // If we get here, image data was found locally.
                post.imageData = imageData;
            }

            // This block is now only reached if the post has no image or its image is ready.
            if (post.parentId) {
                const parent = state.posts.get(post.parentId);
                if (parent) {
                    parent.replies.add(post.id);
                    post.depth = Math.min(parent.depth + 1, 5);
                    refreshPost(parent);
                } else {
                    post.depth = 1;
                }
            }

            state.posts.set(post.id, post);
            renderPost(post);
            newlyVerifiedCount++;
            generateAndBroadcastAttestation(post);
            console.log(`[Attestation] Would update peer reputation for valid post`);
        }

        state.pendingVerification.delete(result.id);
    }

    if (newlyVerifiedCount > 0) {
        notify(`Added ${newlyVerifiedCount} new verified posts`);
    }
}

async function generateAndBroadcastAttestation(post) {
  // Only generate attestations if we have an identity and the post is verified
  if (!state.myIdentity || !post.verified) return;
  
  // Create attestation data with timestamp to prevent replay attacks
  const attestationData = {
    postId: post.id,
    postAuthor: post.author,
    timestamp: Date.now(),
    vdfIterations: post.vdfProof?.iterations?.toString() || '0'
  };
  
  // Sign the attestation
  const dataToSign = JSON.stringify(attestationData);
  const signature = nacl.sign(
    new TextEncoder().encode(dataToSign),
    state.myIdentity.secretKey
  );
  
  // Create attestation message
  const attestationMsg = {
    type: 'post_attestation',
    attestation: attestationData,
    attesterHandle: state.myIdentity.handle,
    attesterPublicKey: arrayBufferToBase64(state.myIdentity.publicKey),
    signature: arrayBufferToBase64(signature)
  };
  
  console.log(`[Attestation] Broadcasting attestation for post ${post.id} by ${post.author}`);
  
  // Broadcast to network
  broadcast(attestationMsg);
}

function evaluatePostTrust(postId) {
  const post = state.pendingVerification.get(postId);
  if (!post) {
    // Clean up timer if post is gone
    const timer = trustEvaluationTimers.get(postId);
    if (timer) {
      clearInterval(timer);
      trustEvaluationTimers.delete(postId);
    }
    return;
  }
  
  // ALWAYS verify signature first
  if (!post.signature || !post.verify()) {
    console.log(`[Trust] Post ${postId} has invalid signature, rejecting`);
    state.pendingVerification.delete(postId);
    if (trustEvaluationTimers.has(postId)) {
      clearInterval(trustEvaluationTimers.get(postId));
      trustEvaluationTimers.delete(postId);
    }
    return;
  }
  
  // Check if post has reached trust threshold
  if (post.hasSufficientTrust(CONFIG.TRUST_THRESHOLD)) {
    console.log(`[Trust] Post ${postId} reached trust threshold (${post.trustScore.toFixed(2)}), accepting with verified signature`);
    
    // Clear timer
    if (trustEvaluationTimers.has(postId)) {
      clearInterval(trustEvaluationTimers.get(postId));
      trustEvaluationTimers.delete(postId);
    }
    
    // Accept the post
    handleVerificationResults([{
      id: postId,
      valid: true,
      errors: []
    }]);
    
    // Give attesters credit
    for (const attesterHandle of post.attesters) {
      for (const [peerId, peer] of state.peers) {
        peerManager.updateScore(peerId, 'correct_attestation', 0.1);
      }
    }
    
    return;
  }
  
  // Check timeout
  const waitTime = Date.now() - post.timestamp;
  if (waitTime >= CONFIG.ATTESTATION_TIMEOUT) {
    console.log(`[Trust] Timeout for post ${postId}, proceeding with full verification`);
    
    if (trustEvaluationTimers.has(postId)) {
      clearInterval(trustEvaluationTimers.get(postId));
      trustEvaluationTimers.delete(postId);
    }
    
    verificationQueue.addBatch([post], 'normal', (results) => {
      handleVerificationResults(results);
    });
  }
}

function scheduleTrustEvaluation(post) {
  const postId = post.id;
  
  // Helper function to clean up timer
  const cleanupTimer = () => {
    const timer = trustEvaluationTimers.get(postId);
    if (timer) {
      clearInterval(timer);
      trustEvaluationTimers.delete(postId);
    }
  };
  
  // Clear any existing timer
  cleanupTimer();
  
  // Schedule periodic evaluation
  const timer = setInterval(() => {
    // Check if post still exists in pending
    if (!state.pendingVerification.has(postId)) {
      cleanupTimer();
      return;
    }
    
    evaluatePostTrust(postId);
  }, 100);
  
  trustEvaluationTimers.set(postId, timer);
  
  // Set a maximum lifetime for the timer (10 seconds)
  setTimeout(() => {
    cleanupTimer();
    
    // If still pending after timeout, send to verification
    if (state.pendingVerification.has(postId)) {
      const post = state.pendingVerification.get(postId);
      verificationQueue.addBatch([post], 'normal', (results) => {
        handleVerificationResults(results);
      });
    }
  }, 10000);
  
  // Do an immediate check
  evaluatePostTrust(postId);
}

async function handleProvisionalClaim(claim) {
    if (!claim || !claim.handle || !claim.vdfProof || !claim.signature) {
        return;
    }
    if (await state.dht.get(`identity:handle:${claim.handle}`)) return;
    if (state.provisionalIdentities.has(claim.handle)) return;

    try {
        const vdfProofForVerification = new wasmVDF.VDFProof(claim.vdfProof.y, claim.vdfProof.pi, claim.vdfProof.l, claim.vdfProof.r, BigInt(claim.vdfProof.iterations));
        const isVdfValid = await wasmVDF.computer.verify_proof(claim.vdfInput, vdfProofForVerification);
        if (!isVdfValid) {
            return;
        }
        const claimDataToVerify = JSON.stringify({
            handle: claim.handle,
            publicKey: claim.publicKey,
            vdfProof: claim.vdfProof
        });
        const publicKeyBytes = base64ToArrayBuffer(claim.publicKey);
        const signatureBytes = new Uint8Array(Object.values(claim.signature));
        if (nacl.sign.open(signatureBytes, publicKeyBytes) === null) {
            return;
        }
    } catch (e) {
        return;
    }

    state.provisionalIdentities.set(claim.handle, {
        claim: claim,
        confirmations: new Set()
    });
    const claimHash = await hashClaim(claim);
    const slipDataToSign = JSON.stringify({ handle: claim.handle, claimHash });
    const slipSignature = nacl.sign(new TextEncoder().encode(slipDataToSign), state.myIdentity.secretKey);
    const slip = {
        handle: claim.handle,
        claimHash: claimHash,
        confirmerHandle: state.myIdentity.handle,
        confirmerPublicKey: arrayBufferToBase64(state.myIdentity.publicKey),
        signature: slipSignature
    };
    broadcast({ type: 'identity_confirmation_slip', slip: slip });
}

async function handleConfirmationSlip(slip) {
    if (!slip || !slip.handle || !slip.claimHash || !slip.confirmerPublicKey || !slip.signature) return;
    const provisionalEntry = state.provisionalIdentities.get(slip.handle);
    if (!provisionalEntry) return;
    const slipDataToVerify = JSON.stringify({ handle: slip.handle, claimHash: slip.claimHash });
    const isSlipSignatureValid = nacl.sign.open(slip.signature, base64ToArrayBuffer(slip.confirmerPublicKey)) !== null;
    if (!isSlipSignatureValid) {
        return;
    }
    const expectedHash = await hashClaim(provisionalEntry.claim);
    if (slip.claimHash !== expectedHash) {
        return;
    }
    provisionalEntry.confirmations.add(slip.confirmerHandle);
    if (provisionalEntry.confirmations.size >= CONFIG.IDENTITY_CONFIRMATION_THRESHOLD) {
        await state.dht.store(`identity:handle:${slip.handle}`, provisionalEntry.claim);
        state.provisionalIdentities.delete(slip.handle);
        if (slip.handle === state.myIdentity.handle) {
            notify(`Your handle "${slip.handle}" has been confirmed by the network!`);
            state.myIdentity.isRegistered = true;
            state.myIdentity.registrationVerified = true;
        }
    }
}

async function hashClaim(claim) {
    const claimString = JSON.stringify({
        handle: claim.handle,
        publicKey: claim.publicKey,
        vdfProof: claim.vdfProof
    });
    const encoder = new TextEncoder();
    const data = encoder.encode(claimString);
    const hashBuffer = await crypto.subtle.digest('SHA-256', data);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
}

function handleCarrierUpdate(msg) {
    const p = state.posts.get(msg.postId);
    if (!p) return;
    const handle = msg.peer || msg.fromIdentityHandle;
    if (!handle) return;
    if (msg.carrying) {
        p.carriers.add(handle);
    } else {
        p.carriers.delete(handle);
    }
    if (p.carriers.size === 0 && !isReply(p)) {
        if (!debugPostRemoval(p.id, 'carrier update - no carriers')) {
            state.posts.delete(p.id);
            dropPost(p.id);
        }
    } else {
        refreshPost(p);
    }
}

function handleParentUpdate(msg) {
    const parent = state.posts.get(msg.parentId);
    const reply = state.posts.get(msg.replyId);
    if (parent && reply) {
        parent.replies.add(msg.replyId);
        refreshPost(parent);
    }
}

async function createPostWithTopics() {
    const input = document.getElementById("post-input");
    const txt = input.value.trim();
    if (!txt) return;

    const topics = state.scribe ? state.scribe.extractTopics(txt) : ['#general'];
    const imagePreview = document.getElementById('image-preview');
    const imageData = imagePreview.dataset.imageData || null;
    const btn = document.getElementById("send-button");
    btn.disabled = true;

    notify("Computing proof of work...", 10000);

    try {
        const vdfInput = txt + state.myIdentity.uniqueId + Date.now();
        btn.textContent = "Computing proof...";
        const proof = await progressiveVDF.computeAdaptiveProof(txt, state.myIdentity.uniqueId, vdfInput);
        if (await isToxic(txt)) {
            notify(`Your post may be seen as toxic. Please rephrase.`);
            btn.disabled = false;
            btn.textContent = "üî•";
            return;
        }
        if (imageData && await isImageToxic(imageData)) {
            notify("Image content not allowed");
            btn.disabled = false;
            btn.textContent = "üî•";
            return;
        }
        
        const p = new Post(txt, null, imageData);
        p.verified = true;
        if (imageData) {
            await p.processImage();
        }
        
        p.vdfProof = proof;
        p.vdfInput = vdfInput;
        p.sign(state.myIdentity.secretKey);

        state.posts.set(p.id, p);
        input.value = "";
        document.getElementById("char-current").textContent = 0;
        renderPost(p);
        /*****
        if (state.peers.size >= 3) {
            dandelion.routePostSecure(p);
        } else {
            dandelion.routePost(p);
        }
        *****/
        // This function now *only* multicasts via Scribe.
        if (state.scribe) {
            topics.forEach(topic => {
                console.log(`[Scribe] Multicasting new post ${p.id} to topic: ${topic}`);
                state.scribe.multicast(topic, { type: 'new_post', post: p.toJSON() });
            });
        } else {
            console.warn("Scribe not initialized, post was not sent.");
            notify("Error: Not connected to the network.");
        }

        removeImage();

        btn.disabled = false;
        btn.textContent = "üî•";
        notify("Posted to the void");
    } catch (error) {
        console.error("VDF computation failed:", error);
        notify("Failed to compute proof of work", 5000);
        btn.disabled = false;
        btn.textContent = "üî•";
    }
}

function toggleCarry(id, isManual = true) {
    const p = state.posts.get(id);
    if (!p) return;
    const isCarrying = p.carriers.has(state.myIdentity.handle);

    if (!isCarrying) {
        p.carriers.add(state.myIdentity.handle);
        state.explicitlyCarrying.add(id);
        broadcast({ type: "carrier_update", postId: id, peer: state.myIdentity.handle, carrying: true });
        refreshPost(p);
    } else {
        p.carriers.delete(state.myIdentity.handle);
        state.explicitlyCarrying.delete(id);
        broadcast({ type: "carrier_update", postId: id, peer: state.myIdentity.handle, carrying: false });
        if (p.carriers.size === 0 && !isReply(p)) {
            if (!debugPostRemoval(p.id, 'toggleCarry - withdrawn')) {
                state.posts.delete(p.id);
                dropPost(id);
            }
        } else {
            refreshPost(p);
        }
    }
}

async function ratePost(postId, vote) {
    const post = state.posts.get(postId);
    if (!post) return;
    
    // Can't rate your own posts - return early
    if (post.author === state.myIdentity.handle) {
        notify("You cannot rate your own posts");
        return;
    }
    
    // For the current user voting on others' posts, just use a default reputation
    const myReputation = 50; // Default reputation for self
    
    // Add/update rating
    const changed = post.addRating(state.myIdentity.handle, vote, myReputation);
    
    if (changed) {
        // Animate the score update
        const scoreEl = document.querySelector(`#post-${postId} .rating-score`);
        if (scoreEl) {
            scoreEl.classList.add('updating');
            setTimeout(() => scoreEl.classList.remove('updating'), 300);
        }
        
        // Update UI
        refreshPost(post);
        
        // Broadcast rating to network
        const ratingMsg = {
            type: 'post_rating',
            postId: postId,
            voter: state.myIdentity.handle,
            vote: vote,
            reputation: myReputation,
            timestamp: Date.now()
        };
        
        // Sign the rating
        const msgStr = JSON.stringify({
            postId: ratingMsg.postId,
            voter: ratingMsg.voter,
            vote: ratingMsg.vote,
            timestamp: ratingMsg.timestamp
        });
        
        const signature = nacl.sign(
            new TextEncoder().encode(msgStr),
            state.myIdentity.secretKey
        );
        
        ratingMsg.signature = arrayBufferToBase64(signature);
        ratingMsg.voterPublicKey = arrayBufferToBase64(state.myIdentity.publicKey);
        
        broadcast(ratingMsg);
        
        // Visual feedback
        const emoji = vote === 'up' ? 'üëç' : 'üëé';
        notify(`Rated post ${emoji}`);
    } else {
        notify("You've already given this rating");
    }
}

async function createReply(parentId) {
    const input = document.getElementById(`reply-input-${parentId}`);
    if (!input) return;

    const btn = input.parentElement.querySelector('button');
    btn.disabled = true;

    try {
        const txt = input.value.trim();
        if (!txt) return; // Exit silently if there is no text

        const parentPost = state.posts.get(parentId);
        if (!parentPost) {
            notify("Parent post no longer exists!");
            return;
        }

        // --- All checks now happen inside the robust try block ---

        if (await isToxic(txt)) {
            notify(`Your reply may be seen as toxic. Please rephrase.`);
            return; // Abort if toxic
        }

        const imagePreview = document.getElementById(`reply-image-preview-${parentId}`);
        const imageData = imagePreview?.dataset?.imageData || null;
        if (imageData && await isImageToxic(imageData)) {
            notify("Image content not allowed");
            return; // Abort if image is toxic
        }
        
        // --- VDF is now mandatory and will throw an error on failure ---
        
        const reply = new Post(txt, parentId, imageData);
        reply.depth = Math.min(parentPost.depth + 1, 5);

        if (imageData) {
            await reply.processImage();
        }

        const vdfInput = txt + state.myIdentity.uniqueId + Date.now();
        const proof = await progressiveVDF.computeAdaptiveProof(txt, state.myIdentity.uniqueId, vdfInput);
        reply.vdfProof = proof;
        reply.vdfInput = vdfInput;

        // --- Signing and Broadcasting, identical to parent posts ---

        reply.sign(state.myIdentity.secretKey);
        
        parentPost.replies.add(reply.id);
        if (!parentPost.carriers.has(state.myIdentity.handle)) {
            parentPost.carriers.add(state.myIdentity.handle);
            state.explicitlyCarrying.add(parentId);
            broadcast({ type: "carrier_update", postId: parentId, peer: state.myIdentity.handle, carrying: true });
        }
        
        state.posts.set(reply.id, reply);
        renderPost(reply);
        
        const replyData = reply.toJSON();
        //broadcast({ type: "new_post", post: replyData });
        //broadcast({ type: "parent_update", parentId: parentId, replyId: reply.id });

        // Also broadcast to topics, which was missing before
        const topics = state.scribe ?
        state.scribe.extractTopics(txt) : [];
        if (state.scribe) {
            topics.forEach(topic => {
                // Multicast the new reply post itself
                state.scribe.multicast(topic, { type: 'new_post', post: replyData });
                // ALSO multicast the parent update on the same topic
                state.scribe.multicast(topic, { type: "parent_update", parentId: parentId, replyId: reply.id });
            });
        }
        
        reply.carriers.add(state.myIdentity.handle);
        state.explicitlyCarrying.add(reply.id);

        // --- Final UI Cleanup ---

        input.value = "";
        document.getElementById(`reply-char-${parentId}`).textContent = 0;
        removeReplyImage(parentId);
        toggleReplyForm(parentId);
        notify("Gas'd the thread!");

    } catch (error) {
        // If anything fails (especially VDF), notify the user and log it.
        console.error("Failed to create reply:", error);
        notify(`Could not create reply: ${error.message}`);

    } finally {
        // IMPORTANT: Always re-enable the button, whether it succeeded or failed.
        btn.disabled = false;
    }
}
async function checkAndDeliverPendingMessages(recipientHandle = null) {
  try {
    console.log('[DM] Checking for pending messages to deliver');
    
    // Get all our pending outgoing messages
    const pendingMessages = await stateManager.getPendingMessagesFrom(state.myIdentity.handle);
    
    if (pendingMessages.length === 0) {
      return;
    }
    
    console.log(`[DM] Found ${pendingMessages.length} pending messages`);
    
    for (const pending of pendingMessages) {
      // Skip if not for the specified recipient (if specified)
      if (recipientHandle && pending.recipient !== recipientHandle) {
        continue;
      }
      
      // Check if recipient is now online
      const routingInfo = await state.identityRegistry.lookupPeerLocation(pending.recipient);
      if (!routingInfo) {
        console.log(`[DM] ${pending.recipient} still offline, skipping`);
        continue;
      }
      
      // Try to deliver
      console.log(`[DM] Attempting to deliver pending message to ${pending.recipient}`);
      
      // Update attempt count
      await stateManager.updateMessageAttempt(pending.id);
      
      // Reconstruct the DM packet
      const dmPacket = {
        type: 'e2e_dm',
        recipient: pending.recipient,
        sender: state.myIdentity.handle,
        ciphertext: pending.encrypted.ciphertext,
        nonce: pending.encrypted.nonce,
        timestamp: pending.timestamp,
        messageId: pending.id, // Include ID for delivery confirmation
        isRetry: true
      };
      
      // Try direct delivery
      const directPeer = await findPeerByHandle(pending.recipient);
      if (directPeer) {
        sendPeer(directPeer.wire, dmPacket);
        console.log(`[DM] Sent pending message directly to ${pending.recipient}`);
        continue;
      }
      
      // Try DHT routing
      const recipientClaim = await state.identityRegistry.lookupHandle(pending.recipient);
      if (recipientClaim && recipientClaim.nodeId) {
        const recipientNodeId = base64ToArrayBuffer(recipientClaim.nodeId);
        const closestPeers = await state.dht.findNode(recipientNodeId);
        
        if (closestPeers.length > 0) {
          const peer = closestPeers[0];
          if (peer.wire && !peer.wire.destroyed) {
            sendPeer(peer.wire, dmPacket);
            console.log(`[DM] Sent pending message to ${pending.recipient} via DHT`);
          }
        }
      }
    }
  } catch (error) {
    console.error('[DM] Error delivering pending messages:', error);
  }
}

async function storePendingMessage(recipientHandle, messageText, status = 'queued') {
  try {
    // First encrypt the message for storage
    const recipientClaim = await state.identityRegistry.lookupHandle(recipientHandle);
    if (!recipientClaim || !recipientClaim.encryptionPublicKey) {
      console.error('[DM] Cannot store message - no encryption key for recipient');
      return null;
    }
    
    // Encrypt the message
    const nonce = nacl.randomBytes(24);
    const messageBytes = new TextEncoder().encode(messageText);
    const recipientPublicKey = base64ToArrayBuffer(recipientClaim.encryptionPublicKey);
    const ciphertext = nacl.box(
      messageBytes,
      nonce,
      recipientPublicKey,
      state.myIdentity.encryptionSecretKey
    );
    
    const encryptedData = {
      ciphertext: arrayBufferToBase64(ciphertext),
      nonce: arrayBufferToBase64(nonce)
    };
    
    // Store in IndexedDB
    const messageId = await stateManager.storePendingMessage(
      recipientHandle,
      messageText,
      state.myIdentity.handle,
      encryptedData
    );
    
    // Also update UI to show pending status
    storeDMLocallyAndUpdateUI(recipientHandle, messageText, status);
    
    console.log(`[DM] Stored pending message ${messageId} for ${recipientHandle}`);
    return messageId;
    
  } catch (error) {
    console.error('[DM] Failed to store pending message:', error);
    return null;
  }
}

async function sendDirectMessage(recipientHandle, messageText) {
  console.log(`[DM] Initializing DM to ${recipientHandle}...`);

  try {
    // --- Step 1: Find and Validate Recipient's Identity ---
    let recipientClaim = null;
    const maxAttempts = 3;
    for (let attempt = 0; attempt < maxAttempts; attempt++) {
      if (attempt > 0) await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
      notify(`Searching for ${recipientHandle}... (Attempt ${attempt + 1})`);
      recipientClaim = await state.identityRegistry.lookupHandle(recipientHandle);
      if (recipientClaim) break;
    }

    if (!recipientClaim) {
      notify(`Could not find user "${recipientHandle}". They may be offline or do not exist.`);
      return false;
    }

    if (!recipientClaim.encryptionPublicKey) {
      notify(`User ${recipientHandle} does not support encrypted messages.`);
      return false;
    }

    // --- Step 2: Prepare the Encrypted Packet ---
    const nonce = nacl.randomBytes(24);
    const messageBytes = new TextEncoder().encode(messageText);
    const recipientPublicKey = base64ToArrayBuffer(recipientClaim.encryptionPublicKey);
    const ciphertext = nacl.box(
      messageBytes, nonce, recipientPublicKey, state.myIdentity.encryptionSecretKey
    );
    const dmPacket = {
      type: 'e2e_dm',
      recipient: recipientHandle,
      sender: state.myIdentity.handle,
      ciphertext: arrayBufferToBase64(ciphertext),
      nonce: arrayBufferToBase64(nonce),
      timestamp: Date.now()
    };

    // --- Step 3: Attempt Direct Delivery (Highest Priority) ---
    const directPeer = await findPeerByHandle(recipientHandle);
    if (directPeer) {
      console.log(`[DM] Direct connection found. Sending message to ${recipientHandle}.`);
      sendPeer(directPeer.wire, dmPacket);
      storeDMLocallyAndUpdateUI(recipientHandle, messageText, 'sent');
      addMessageToConversation(recipientHandle, messageText, 'sent');
      notify(`Message sent directly to ${recipientHandle}`);
      return true;
    }

    // --- Step 4: Fallback to DHT-based Routing ---
    const routingInfo = await state.identityRegistry.lookupPeerLocation(recipientHandle);
    if (routingInfo) {
      console.log(`[DM] No direct connection. Forwarding message to ${recipientHandle} via DHT.`);
      dmPacket.routingHint = routingInfo.wirePeerId;
      const recipientNodeId = base64ToArrayBuffer(routingInfo.nodeId);
      const closestPeers = await state.dht.findNode(recipientNodeId);

      if (closestPeers.length > 0) {
        sendPeer(closestPeers[0].wire, dmPacket);
        storeDMLocallyAndUpdateUI(recipientHandle, messageText, 'sent');
        addMessageToConversation(recipientHandle, messageText, 'sent');
        notify(`Message sent to ${recipientHandle} via network routing`);
        return true;
      }
    }

    // --- Step 5: Last Resort - Store for Offline Delivery ---
    console.log(`[DM] User ${recipientHandle} is unreachable. Storing message for later delivery.`);
    await storePendingMessage(recipientHandle, messageText, 'queued');
    notify(`${recipientHandle} appears to be offline. Your message has been saved.`);
    return true;

  } catch (error) {
    console.error('Error sending direct message:', error);
    notify(`Error: Could not send message to ${recipientHandle}.`);
    return false;
  }
}

async function handleDirectMessage(msg, fromWire) {
  try {
    // Check if this message is for us
    if (msg.recipient !== state.myIdentity.handle) {
      console.log(`[DM] Message for ${msg.recipient}, attempting to forward`);
      
      // Try to forward using routing hint first
      if (msg.routingHint) {
        for (const [peerId, peer] of state.peers) {
          if (peerId === msg.routingHint && peer.wire && !peer.wire.destroyed) {
            console.log(`[DM] Forwarding to peer via routing hint`);
            sendPeer(peer.wire, msg);
            return;
          }
        }
      }
      
      // Fall back to looking up current routing
      const routingInfo = await state.identityRegistry.lookupPeerLocation(msg.recipient);
      if (routingInfo) {
        // Check if recipient is directly connected to us
        const directPeer = await findPeerByHandle(msg.recipient);
        if (directPeer) {
          console.log(`[DM] Forwarding directly to ${msg.recipient}`);
          sendPeer(directPeer.wire, msg);
          return;
        }
      }
      
      // Fall back to DHT routing
      const recipientClaim = await state.identityRegistry.lookupHandle(msg.recipient);
      if (recipientClaim && recipientClaim.nodeId) {
        const recipientNodeId = base64ToArrayBuffer(recipientClaim.nodeId);
        const closestPeers = state.dht.findClosestPeers(recipientNodeId, 3);
        
        for (const peer of closestPeers) {
          if (peer.wire !== fromWire && peer.wire && !peer.wire.destroyed) {
            sendPeer(peer.wire, msg);
          }
        }
        console.log(`[DM] Forwarded to ${closestPeers.length} peers via DHT`);
      }
      return;
    }
    
    // Message is for us - verify and decrypt
    console.log(`[DM] Received message from ${msg.sender}`);
    
    const senderClaim = await state.identityRegistry.lookupHandle(msg.sender);
    if (!senderClaim || !senderClaim.encryptionPublicKey) {
      console.warn(`[DM] Unknown or invalid sender: ${msg.sender}`);
      return;
    }
    
    // Decrypt the message
    const ciphertext = base64ToArrayBuffer(msg.ciphertext);
    const nonce = base64ToArrayBuffer(msg.nonce);
    const senderPublicKey = base64ToArrayBuffer(senderClaim.encryptionPublicKey);
    
    const decryptedBytes = nacl.box.open(
      ciphertext,
      nonce,
      senderPublicKey,
      state.myIdentity.encryptionSecretKey
    );
    
    if (!decryptedBytes) {
      console.error('[DM] Failed to decrypt - invalid ciphertext or keys');
      return;
    }
    
    const messageText = new TextDecoder().decode(decryptedBytes);
    
    // Store and display the message
    storeDMLocallyAndUpdateUI(msg.sender, messageText, 'received');
    updateUnreadBadge();
    notify(`üì¨ New message from ${msg.sender}`, 6000,
      () => openDMPanel(msg.sender));
    
    
    // Send delivery confirmation if this was a retry
    if (msg.messageId && msg.isRetry) {
      const confirmation = {
        type: 'dm_delivered',
        messageId: msg.messageId,
        recipient: msg.recipient,
        deliveredAt: Date.now()
      };
      
      // Send confirmation back
      const senderPeer = await findPeerByHandle(msg.sender);
      if (senderPeer) {
        sendPeer(senderPeer.wire, confirmation);
      } else {
        // Route through DHT
        const senderClaim = await state.identityRegistry.lookupHandle(msg.sender);
        if (senderClaim && senderClaim.nodeId) {
          const senderNodeId = base64ToArrayBuffer(senderClaim.nodeId);
          const closestPeers = await state.dht.findNode(senderNodeId);
          if (closestPeers.length > 0) {
            sendPeer(closestPeers[0].wire, confirmation);
          }
        }
      }
    }   
      
    
    // Update UI if DM panel is open
    if (currentDMRecipient === msg.sender) {
      addMessageToConversation(msg.sender, messageText, 'received');
    }
    
    // Check if we have pending messages to send back
    await checkAndDeliverPendingMessages(msg.sender);
    
  } catch (error) {
    console.error('[DM] Receive error:', error);
  }
}

// Profile Functions
async function broadcastProfileUpdate(profileData = null) {
  if (!state.myIdentity || !state.scribe) return;
  
  const profile = profileData || state.myIdentity.profile;
  if (!profile) return;
  
  const topic = '@' + state.myIdentity.handle;
  console.log(`[Profile] Broadcasting profile update to topic: ${topic}`);
  
  // Sign the profile data
  const profileStr = JSON.stringify(profile);
  const signature = nacl.sign(
    new TextEncoder().encode(profileStr),
    state.myIdentity.secretKey
  );
  
  const message = {
    type: 'PROFILE_UPDATE',
    profile: profile,
    signature: arrayBufferToBase64(signature),
    publicKey: arrayBufferToBase64(state.myIdentity.publicKey)
  };
  
  try {
    // ADDED: Store in DHT
    const dhtKey = `profile:${profile.handle}`;
    console.log(`[Profile] Storing profile in DHT with key: ${dhtKey}`);
    
    try {
      await state.dht.store(dhtKey, message);
      console.log('[Profile] Profile successfully stored in DHT');
    } catch (dhtError) {
      console.error('[Profile] Failed to store profile in DHT:', dhtError);
    }
    
    // Original Scribe multicast
    await state.scribe.multicast(topic, message);
    console.log('[Profile] Profile update broadcast successful');
  } catch (error) {
    console.error('[Profile] Failed to broadcast profile update:', error);
  }
}

async function subscribeToProfile(handle) {
  if (!state.scribe) return;
  
  const topic = '@' + handle;
  console.log(`[Profile] Subscribing to profile topic: ${topic}`);
  
  try {
    await state.scribe.subscribe(topic);
    console.log(`[Profile] Successfully subscribed to ${handle}'s profile`);
  } catch (error) {
    console.error(`[Profile] Failed to subscribe to ${handle}'s profile:`, error);
  }
}

async function unsubscribeFromProfile(handle) {
  if (!state.scribe || !handle) return;
  
  const topic = '@' + handle;
  console.log(`[Profile] Unsubscribing from profile topic: ${topic}`);
  
  try {
    state.scribe.unsubscribe(topic);
    console.log(`[Profile] Successfully unsubscribed from ${handle}'s profile`);
  } catch (error) {
    console.error(`[Profile] Failed to unsubscribe from ${handle}'s profile:`, error);
  }
}

function handleProfileUpdate(msg, fromWire) {
  if (!msg.profile || !msg.signature || !msg.publicKey) return;
  
  const { profile, signature, publicKey } = msg;
  
  // Verify signature
  try {
    const profileStr = JSON.stringify(profile);
    const publicKeyBytes = typeof publicKey === 'string' ? 
      base64ToArrayBuffer(publicKey) : publicKey;
    const signatureBytes = base64ToArrayBuffer(signature);
    
    const verified = nacl.sign.open(signatureBytes, publicKeyBytes);
    if (!verified) {
      console.warn('[Profile] Invalid signature on profile update');
      return;
    }
    
    // Additional check: verify the data matches
    const decodedData = new TextDecoder().decode(verified);
    if (decodedData !== profileStr) {
      console.warn('[Profile] Profile data mismatch');
      return;
    }
  } catch (error) {
    console.error('[Profile] Failed to verify profile signature:', error);
    return;
  }
  
  // Cache the profile
  state.profileCache.set(profile.handle, profile);

  // *** Check for and store the image metadata ***
  if (profile.profilePictureHash && profile.profilePictureMeta) {
    const imageStore = getServices().imageStore;
    if (imageStore && !imageStore.images.has(profile.profilePictureHash)) {
      imageStore.images.set(profile.profilePictureHash, profile.profilePictureMeta);
      console.log(`[Profile] Stored new image metadata for ${profile.handle}'s profile picture.`);
    }
  }
  
  // ADDED: Cache verified profile into local DHT
  const dhtKey = `profile:${profile.handle}`;
  console.log(`[Profile] Caching verified profile to DHT with key: ${dhtKey}`);
  
  // Store the complete message object (with signature and publicKey) in DHT
  state.dht.store(dhtKey, msg).then(() => {
    console.log(`[Profile] Successfully cached ${profile.handle}'s profile to DHT`);
  }).catch(error => {
    console.error(`[Profile] Failed to cache profile to DHT:`, error);
  });
  
  // If this is the profile we're currently viewing, update the UI
  if (state.viewingProfile === profile.handle) {
    renderProfile(profile);
  }
  
  console.log(`[Profile] Received and verified profile update for ${profile.handle}`);
}

async function handleScribeMessage(msg, fromWire) {
  if (!state.scribe) return;
  
  // Check if this is a profile update
  if (msg.subtype === 'MULTICAST' && msg.message) {
    const innerMsg = msg.message;
    if (innerMsg.type === 'PROFILE_UPDATE') {
      handleProfileUpdate(innerMsg, fromWire);
      return;
    }
  }
  
  // Pass to regular Scribe handler
  state.scribe.handleMessage(msg, fromWire);
}

async function initTopics() {
    loadTopicSubscriptions();
    updateTopicFilter();
    const pendingTopics = new Set(state.subscribedTopics);
    const waitForScribe = setInterval(async () => {
        if (state.scribe) {
            clearInterval(waitForScribe);
            for (const topic of pendingTopics) {
                try {
                    await state.scribe.subscribe(topic);
                } catch (e) {
                    console.error(`Failed to subscribe to ${topic}:`, e);
                }
            }
        }
    }, 1000);
    setInterval(updateTopicStats, 5000);
}

// --- 5. MAINTENANCE & GARBAGE COLLECTION ---
let maintenanceInterval;
function startMaintenanceLoop() {
  let tick = 0;
  maintenanceInterval = setInterval(() => {
    tick++;
    if (tick % 5 === 0) trafficMixer.mix();
    if (tick % 10 === 0) {
      updateAges();
      noiseGenerator.generateNoise();
    }
    
    if (tick % 10 === 0) {
      updateAges();
      noiseGenerator.generateNoise();
      //Update profile pictures
      updateProfilePicturesInPosts();
    }
    
    if (tick % 30 === 0) {
      memoryManager.checkMemory();
      garbageCollect();
      stateManager.savePosts();
      stateManager.saveUserState();
      stateManager.savePeerScores();
      stateManager.saveImageChunks(); // Periodically save image data
      stateManager.saveDHTState(); 
      
              // Re-publish identity to DHT to ensure it doesn't expire
        if (state.myIdentity && state.dht && state.myIdentity.isRegistered) {
            console.log("[Maintenance] Re-publishing identity records to DHT...");
            
            const identityOptions = { propagate: true, refresh: true, replicationFactor: 30 };
            const handleAddress = `handle-to-pubkey:${state.myIdentity.handle.toLowerCase()}`;
            const pubkeyAddress = `pubkey:${state.myIdentity.publicKey}`;

            // Re-store both the handle mapping and the full identity claim
            state.dht.store(handleAddress, state.myIdentity.publicKey, identityOptions).catch(err => {
                console.error("[Maintenance] Failed to re-publish handle mapping:", err);
            });
            
            if (state.myIdentity.identityClaim) {
                state.dht.store(pubkeyAddress, state.myIdentity.identityClaim, identityOptions).catch(err => {
                    console.error("[Maintenance] Failed to re-publish identity claim:", err);
                });
            }
        }

      
    }
    if (tick % 60 === 0 && state.hyparview) {
        const activePeers = state.hyparview.getActivePeers();
        if (activePeers.length > 0) {
            const target = activePeers[Math.floor(Math.random() * activePeers.length)];
            const knownPeers = Array.from(state.peers.keys())
                .filter(id => typeof id === 'string')
                .slice(0, 10)
                .map(peerId => ({ id: peerId }));
            if (knownPeers.length > 0 && target.wire && !target.wire.destroyed) {
                sendPeer(target.wire, {
                    type: 'peer_exchange',
                    peers: knownPeers
                });
            }
        }
          // Try to deliver pending messages
          checkAndDeliverPendingMessages().catch(e => 
            console.error('[Maintenance] Failed to check pending messages:', e)
          );
    }

    if (tick % 120 === 0) { // Every 2 minutes
      // Update our routing info in DHT
      if (state.identityRegistry && state.myIdentity && state.peers.size > 0) {
        // Find our current wire peer ID from any active connection
        let ourWirePeerId = null;
        for (const [peerId, peerData] of state.peers) {
          if (peerData.wire && !peerData.wire.destroyed) {
            // Get our peer ID as seen by this peer
            ourWirePeerId = peerData.wire._client?.peerId;
            if (ourWirePeerId) break;
          }
        }
        
        if (ourWirePeerId) {
          state.identityRegistry.updatePeerLocation(
            state.myIdentity.handle,
            state.myIdentity.nodeId,
            ourWirePeerId
          ).then(() => {
            console.log('[Maintenance] Routing info refreshed');
          }).catch(e => {
            console.error('[Maintenance] Failed to refresh routing:', e);
          });
        }
      }
      
      // Clean up expired routing entries
      if (state.identityRegistry) {
        state.identityRegistry.removeExpiredRouting();
      }
    }
    
    
        if (tick % 180 === 0) { // Every 3 minutes
      const hotTopics = new Map();
      let topicsProcessed = 0;
      
      // Iterate through Scribe's known topics to find active ones
      if (state.scribe) {
        state.scribe.subscribedTopics.forEach((info, topic) => {
            const children = info.children ? info.children.size : 0;
            const score = 1 + children; // Simple score: 1 + number of children
            if (score > 1) {
                hotTopics.set(topic, { score });
            }
            topicsProcessed++;
        });
      }
      
      console.log(`[Maintenance] Processed ${topicsProcessed} topics for hotness score.`);

      if (hotTopics.size > 0) {
        const sortedTopics = Array.from(hotTopics.entries())
            .sort((a, b) => b[1].score - a[1].score)
            .slice(0, 50); // Store top 50 topics
        
        const dataToStore = {
            topics: sortedTopics,
            updatedAt: Date.now()
        };

        if (state.dht) {
            state.dht.store('hot-topics:v1', dataToStore)
                .then(() => console.log(`[Maintenance] Published ${sortedTopics.length} hot topics to the DHT.`))
                .catch(e => console.error('[Maintenance] Failed to publish hot topics:', e));
        }
      }
    }
    
    
    
    if (tick % 300 === 0) {
        const stats = state.seenMessages.getStats();
      // Clean up stale routing cache entries
      if (state.peerRoutingCache) {
        const now = Date.now();
        const staleTimeout = 600000; // 10 minutes
        
        for (const [handle, info] of state.peerRoutingCache) {
          const age = now - info.timestamp;
          const heartbeatAge = info.lastHeartbeat ? now - info.lastHeartbeat : Infinity;
          
          if (age > staleTimeout && heartbeatAge > staleTimeout) {
            console.log(`[Maintenance] Removing stale routing for ${handle}`);
            state.peerRoutingCache.delete(handle);
          }
        }
      }
      
      // Clean up expired DHT routing entries
      if (state.identityRegistry) {
        state.identityRegistry.removeExpiredRouting();
      }
      
      // Re-broadcast profile every 5 minutes
      if (state.myIdentity && state.myIdentity.profile) {
        broadcastProfileUpdate();
      }
    }
    
    
    
    
    
    
    if (tick % 600 === 0) { // Every 10 minutes
      // Log DHT health
      if (state.dht) {
        const stats = state.dht.getStats();
        console.log('[DHT Health]', {
          peers: stats.totalPeers,
          keys: stats.localKeys,
          refreshQueue: stats.refreshQueueSize,
          replication: stats.replicationHealth
        });
        
        // Force refresh if too many under-replicated keys
        if (stats.replicationHealth.underReplicated > stats.replicationHealth.wellReplicated) {
          console.warn('[DHT] Many under-replicated keys, forcing refresh');
          state.dht.refreshStoredValues();
        }
      }
    }
    
    
    if (tick % 3600 === 0) {
        stateManager.cleanup();
        tick = 0;
      // Clean up old messages
      stateManager.cleanupOldMessages().catch(e =>
        console.error('[Maintenance] Failed to cleanup old messages:', e)
      );
    }
    
  }, 1000);
}

function garbageCollect() {
    const now = Date.now();
    const threadsMap = new Map();
    for (const [id, p] of state.posts) {
        const rootId = findRootPost(id);
        if (!threadsMap.has(rootId)) {
            threadsMap.set(rootId, new Set());
        }
        threadsMap.get(rootId).add(id);
    }
    for (const [rootId, threadPosts] of threadsMap) {
        const threadCarriers = new Set();
        let newestTimestamp = 0;
        let hasExplicitlyCarried = false;
        let hasReplies = false;
        threadPosts.forEach(postId => {
            const post = state.posts.get(postId);
            if (post) {
                post.carriers.forEach(c => threadCarriers.add(c));
                newestTimestamp = Math.max(newestTimestamp, post.timestamp);
                if (state.explicitlyCarrying.has(postId)) hasExplicitlyCarried = true;
                if (isReply(post)) hasReplies = true;
            }
        });
        const threadAge = now - newestTimestamp;
        const shouldKeep = hasExplicitlyCarried || threadCarriers.size > 2 || threadAge < 3600000 || hasReplies;
        if (!shouldKeep && threadCarriers.size === 1 && threadAge > 1800000) {
            threadPosts.forEach(postId => {
                const post = state.posts.get(postId);
                if (post && post.carriers.has(state.myIdentity.handle) && post.carriers.size === 1 && !isReply(post)) {
                    toggleCarry(postId, false);
                }
            });
        }
    }
    updateStatus();
}

// --- 6. APP LIFECYCLE (INIT) ---
async function init() {
  applyTheme(localStorage.getItem('ephemeral-theme') || 'dark');
  setupThemeToggle();
  applyConfigToUI();
  
  try {
    // Set up service callbacks
    setServiceCallbacks({
      debugPostRemoval,
      dropPost,
      notify,
      renderPost,
      broadcastProfileUpdate,
      initializeUserProfileSection
    });
    
    // Register Scribe message handlers with message bus
    messageBus.registerHandler('scribe:new_post', (data) => {
      if (state.myIdentity && data.message.post.author === state.myIdentity.handle) return;
      handleNewPost(data.message.post, null);
    });
    
    messageBus.registerHandler('scribe:PROFILE_UPDATE', (data) => {
      handleProfileUpdate(data.message, null);
    });
    
    messageBus.registerHandler('scribe:parent_update', (data) => {
      handleParentUpdate(data.message);
    });
    
    // Initialize services
    const services = initializeServices({
      renderPost: renderPost
    });
    // Extract service references
    ({
      stateManager,
      verificationQueue,
      imageStore,
      peerManager,
      memoryManager,
      progressiveVDF,
      noiseGenerator,
      trafficMixer,
      epidemicGossip
    } = services);
    
    // Set up the StateManager's renderPost dependency
    services.stateManager.renderPost = renderPost;
    // Set up UI dependencies
    setSendPeer(sendPeer);
    
    // Register message handlers
    registerHandler('new_post', handleNewPost);
    registerHandler('provisional_identity_claim', async (msg) => await handleProvisionalClaim(msg.claim));
    registerHandler('identity_confirmation_slip', async (msg) => await handleConfirmationSlip(msg.slip));
    registerHandler('post_attestation', handlePostAttestation);
    registerHandler('carrier_update', handleCarrierUpdate);
    registerHandler('parent_update', handleParentUpdate);
    registerHandler('posts_response', async (msg) => await handlePostsResponse(msg.posts));
    registerHandler('post_rating', handlePostRating);
    registerHandler('e2e_dm', handleDirectMessage);
    registerHandler('generate_attestation', generateAndBroadcastAttestation);
    
    await wasmVDF.initialize();
    await verificationQueue.init();
    await stateManager.init();
    
    // Check for stored identity but DON'T set it yet
    const stored = localStorage.getItem("ephemeral-id");
    let storedIdentity = null;
    
    if (stored) {
      try {
        const identity = JSONParseWithBigInt(stored);
        if (identity.nodeId) {
            if (typeof identity.nodeId === 'string') {
            // stored as base-64
            identity.nodeId = base64ToArrayBuffer(identity.nodeId);
            } else if (Array.isArray(identity.nodeId)) {
            // stored as JSON array
            identity.nodeId = new Uint8Array(identity.nodeId);
           }
        }       
        
        
        if (identity.secretKey) {
          if (Array.isArray(identity.secretKey)) {
            identity.secretKey = new Uint8Array(identity.secretKey);
          }
        }
        if (identity.publicKey && typeof identity.publicKey === 'string') {
          identity.publicKey = base64ToArrayBuffer(identity.publicKey);
        }
        if (identity.encryptionPublicKey && typeof identity.encryptionPublicKey === 'string') {
          identity.encryptionPublicKey = base64ToArrayBuffer(identity.encryptionPublicKey);
        }
        if (identity.encryptionSecretKey && Array.isArray(identity.encryptionSecretKey)) {
          identity.encryptionSecretKey = new Uint8Array(identity.encryptionSecretKey);
        }
        if (identity.vdfProof && identity.vdfProof.iterations) {
          if (typeof identity.vdfProof.iterations === 'string') {
            identity.vdfProof.iterations = BigInt(identity.vdfProof.iterations);
          }
        }
        
        // Initialize default profile if not present
        if (!identity.profile) {
          identity.profile = {
            handle: identity.handle,
            bio: '',
            profilePictureHash: null,
            theme: {
              backgroundColor: '#000000',
              fontColor: '#ffffff',
              accentColor: '#ff1493'
            },
            updatedAt: Date.now()
          };
        }
        
        storedIdentity = identity;
      } catch (e) {
        console.error("Failed to parse stored identity:", e);
      }
    }
    
    // Initialize network FIRST with temporary node ID
    const tempNodeId = (storedIdentity && storedIdentity.nodeId instanceof Uint8Array)
                        ? storedIdentity.nodeId
                        : crypto.getRandomValues(new Uint8Array(20));
    
    await initNetworkWithTempId(tempNodeId);
    await stateManager.loadDHTState();
    
    // Wait for DHT to be ready
    await new Promise(resolve => {
      const checkInterval = setInterval(() => {
        if (state.dht && state.identityRegistry) {
          clearInterval(checkInterval);
          resolve();
        }
      }, 100);
    });
    
    await new Promise(resolve => {
      let waitTime = 0;
      const checkInterval = setInterval(() => {
        waitTime += 100;
        
        if (state.dht && state.identityRegistry) {
          clearInterval(checkInterval);
          
          // Check if we're likely the first node
          if (waitTime > 5000 && state.peers.size === 0) {
            notify("üéâ Welcome, pioneer! You appear to be the first node on the network!");
          }
          
          resolve();
        }
      }, 100);
    });
        
    
    // Now handle identity
    if (storedIdentity && storedIdentity.handle) {
      // Verify stored identity
      const isValid = await state.identityRegistry.verifyOwnIdentity(storedIdentity);
      
      if (isValid) {
        // Identity was successfully verified on the network
        state.myIdentity = storedIdentity;
        
        // Update the DHT with the final, correct nodeId ---
        state.dht.nodeId = state.myIdentity.nodeId;
        
         // Re-publish identity records to the DHT to ensure discoverability ---
        console.log("[Identity] Re-publishing identity records for returning user...");
        const handleAddress = `handle-to-pubkey:${state.myIdentity.handle.toLowerCase()}`;
        const pubkeyAddress = `pubkey:${state.myIdentity.publicKey}`;

        // Use Promise.all to re-publish both records concurrently.
        Promise.all([
          state.dht.store(handleAddress, { publicKey: state.myIdentity.publicKey }),
          state.dht.store(pubkeyAddress, state.myIdentity.identityClaim)
        ]).then(() => {
            console.log("[Identity] Successfully re-published identity to the DHT.");
        }).catch(err => {
            console.error("[Identity] Failed to re-publish identity:", err);
        });       
          // Initialize profile section
        initializeUserProfileSection();
        notify(`Welcome back, ${storedIdentity.handle}!`);
        // Announce our routing info after a short delay
        setTimeout(async () => {
          if (state.client && state.identityRegistry) {
            // Get our current WebRTC peer ID from any active connection
            const activePeer = Array.from(state.peers.values())[0];
            if (activePeer && activePeer.wire) {
              const ourWirePeerId = activePeer.wire._client?.peerId;
              if (ourWirePeerId) {
                await state.identityRegistry.updatePeerLocation(
                  state.myIdentity.handle,
                  state.myIdentity.nodeId,
                  ourWirePeerId
                );
                console.log('[Init] Initial routing info announced');
              }
            }
          }
        }, 5000); // Wait 5 seconds for connections to establish
      } else if (state.peers.size === 0) {
        // If verification fails BUT we have no peers, we are the first node.
        // We should trust the local identity and assume it's valid.
        console.warn("Could not verify identity on DHT (no peers found), trusting local storage.");
        state.myIdentity = storedIdentity;
         initializeUserProfileSection();
        notify(`Welcome back, pioneer ${storedIdentity.handle}!`);
      } else {
        // Stored identity is invalid or taken because verification failed and there ARE peers.
        notify("Stored identity is no longer valid. Please create a new one.");
        await createNewIdentity();
        initializeUserProfileSection();
      }
    } else {
      // No stored identity
      await createNewIdentity();
      initializeUserProfileSection();
    }
    
    // Continue with rest of initialization
    await stateManager.loadUserState();
    await stateManager.loadImageChunks();
    await initContentFilter();
    await initImageFilter();
    
    const loadedPostCount = await stateManager.loadPosts();
    
    
    await stateManager.loadPeerScores();
    
    // Hide loading screen and show main app
    document.getElementById("loading").style.display = "none";
    initializeP2PProtocols();
    startMaintenanceLoop();
    initTopics();
    updateDMInbox();
    updateUnreadBadge();
    // Update inbox periodically
    setInterval(()=>{ 
                updateDMInbox(),
                updateUnreadBadge();
                }, 30000); // Every 30 seconds
    
    window.addEventListener("beforeunload", () => {
      if (maintenanceInterval) clearInterval(maintenanceInterval);
      stateManager.savePosts();
      stateManager.saveUserState();
      stateManager.savePeerScores();
      stateManager.saveDHTState();
        routingManager.stop();
      if (state.client) state.client.destroy();
      if (state.dht) {
        state.dht.shutdown();
      }
    });
    
    if (!localStorage.getItem("ephemeral-tips")) {
      setTimeout(() => notify("üí° Tip: Posts live only while carried by peers"), 1000);
      setTimeout(() => notify("üí° Tip: Ctrl+Enter to post quickly"), 6000);
      localStorage.setItem("ephemeral-tips", "yes");
    }
    
  } catch (e) {
    console.error("Init failed:", e);
    document.getElementById("loading").innerHTML = `<div class="loading-content"><h2>Init Failed</h2><p>${e.message}</p><button onclick="location.reload()">Try Again</button></div>`;
  }
}

async function handlePostRating(msg, fromWire) {
    const { postId, voter, vote, reputation, timestamp, signature, voterPublicKey } = msg;
    
    // Validate message
    if (!postId || !voter || !vote || !signature || !voterPublicKey) {
        console.warn('[Rating] Invalid rating message');
        return;
    }
    
    // Check if post exists
    const post = state.posts.get(postId);
    if (!post) return;
    
    // Verify signature
    try {
        const dataToVerify = JSON.stringify({
            postId,
            voter,
            vote,
            timestamp
        });
        
        const publicKey = base64ToArrayBuffer(voterPublicKey);
        const sig = base64ToArrayBuffer(signature);
        
        const verified = nacl.sign.open(sig, publicKey);
        if (!verified) {
            console.warn(`[Rating] Invalid signature from ${voter}`);
            return;
        }
        
        const decodedData = new TextDecoder().decode(verified);
        if (decodedData !== dataToVerify) {
            console.warn(`[Rating] Signature mismatch from ${voter}`);
            return;
        }
    } catch (e) {
        console.error('[Rating] Signature verification failed:', e);
        return;
    }
    
    // Check timestamp (prevent replay attacks)
    const age = Date.now() - timestamp;
    if (age > 300000) { // 5 minutes
        console.warn(`[Rating] Rating too old: ${age}ms`);
        return;
    }
    
    // Look up voter's actual reputation if we know them
    let actualReputation = reputation || 10;
    for (const [peerId, peerData] of state.peers) {
        if (peerData.handle === voter) {
            actualReputation = peerManager.getScore(peerId);
            break;
        }
    }
    
    // Apply rating
    const changed = post.addRating(voter, vote, actualReputation);
    if (changed) {
        refreshPost(post);
        console.log(`[Rating] Applied rating from ${voter} to post ${postId}`);
    }
}

function initializeP2PProtocols() {
  if (!state.myIdentity) {
    console.error("Cannot initialize P2P protocols without an identity.");
    return;
  }
  
  // HyParView is created in identity-flow, but we ensure it's here for returning users
  if (!state.hyparview) {
      state.hyparview = new HyParView(state.myIdentity.nodeId, state.dht);
      state.hyparview.bootstrap().catch(e => console.error("HyParView bootstrap failed:", e));
  }

  // Initialize Scribe
  try {
    state.scribe = new Scribe(state.myIdentity.nodeId, state.dht);
    state.scribe.deliverMessage = (topic, message) => {
      if (message.type === 'new_post' && message.post) {
        if (message.post.author === state.myIdentity.handle) return;
        handleNewPost(message.post, null);
      } else if (message.type === 'PROFILE_UPDATE') {
        handleProfileUpdate(message, null);
      } else if (message.type === 'parent_update') {
        // New handler for reply notifications
        handleParentUpdate(message);
      }
    };
  } catch (e) {
    console.error("Failed to initialize Scribe:", e);
  }

  // Initialize Plumtree
 // state.plumtree = new Plumtree(state.myIdentity.nodeId, state.hyparview);
 // state.plumtree.deliver = (message) => {
 //   if (message.type === 'post') {
 //     handleNewPost(message.data, null);
 //   }
 // };
  
  console.log("P2P protocol (Scribe) initialized.");
  // Start routing manager
    routingManager.start();
    console.log("Routing manager initialized");
}

// helper function for init
async function initNetworkWithTempId(tempNodeId) {
  initNetwork(); // This will create state.client
  
  // Initialize DHT and identity registry immediately
  state.dht = new KademliaDHT(tempNodeId);
  state.identityRegistry = new IdentityRegistry(state.dht);
  
  // The rest of the protocols will initialize after the bootstrap connection
}

function sendToPeer(peer, message) {
    if (!peer || !peer.wire || peer.wire.destroyed) return false;
    
    try {
        sendPeer(peer.wire, message);
        return true;
    } catch (error) {
        console.error('Failed to send message to peer:', error);
        return false;
    }
}

async function findPeerByHandle(handle) {
  // First check our local peer identity map
  if (state.peerIdentities) {
    for (const [peerId, identity] of state.peerIdentities) {
      if (identity.handle === handle) {
        const peer = state.peers.get(peerId);
        if (peer && peer.wire && !peer.wire.destroyed) {
          console.log(`[FindPeer] Found ${handle} in local peer map`);
          return peer;
        }
      }
    }
  }
  
  // Check routing cache
  if (state.peerRoutingCache && state.peerRoutingCache.has(handle)) {
    const cached = state.peerRoutingCache.get(handle);
    
    // Check if routing info is fresh
    const age = Date.now() - cached.timestamp;
    if (age < 300000) { // 5 minutes
      // Try to find peer by the cached peer ID
      for (const [peerId, peer] of state.peers) {
        if (peerId === cached.peerId || peerId === cached.fromWire) {
          if (peer.wire && !peer.wire.destroyed) {
            console.log(`[FindPeer] Found ${handle} via routing cache`);
            return peer;
          }
        }
      }
    }
  }
  
  // If not found locally, check DHT routing info
  const routingInfo = await state.identityRegistry.lookupPeerLocation(handle);
  if (!routingInfo) {
    console.log(`[FindPeer] No routing info found for ${handle}`);
    return null;
  }
  
  // Find peer by wire peer ID
  for (const [peerId, peer] of state.peers) {
    if (peerId === routingInfo.wirePeerId) {
      if (peer.wire && !peer.wire.destroyed) {
        console.log(`[FindPeer] Found ${handle} via DHT routing`);
        return peer;
      }
    }
  }
  
  console.log(`[FindPeer] Routing info found but peer not connected`);
  return null;
}

function debugPostRemoval(postId, reason) {
  // This allows for live debugging via the browser console, e.g.:

  if (window.ephemeralDebug?.preventRemoval) {
    console.warn(`[Debug] Removal of post ${postId} PREVENTED by global flag. Reason: ${reason}`);
    return true; // Return true to PREVENT removal
  }
  
  if (window.ephemeralDebug?.protectedPosts?.has(postId)) {
    console.warn(`[Debug] Removal of post ${postId} PREVENTED because it is protected. Reason: ${reason}`);
    return true; // Return true to PREVENT removal
  }
  
  console.log(`[Debug] Post ${postId} is being removed. Reason: ${reason}`);
  return false; // Return false to ALLOW removal
}

// --- 7. GLOBALS & KICKOFF ---
// Expose functions to the global scope so onclick handlers in the HTML can find them.

    // Set stateManager's renderPost dependency
   // stateManager.renderPost = renderPost;
  // Expose functions to the global scope so onclick handlers in the HTML can find them.
  window.createPostWithTopics = createPostWithTopics;
  window.toggleCarry = toggleCarry;
  window.createReply = createReply;
  window.handleImageSelect = handleImageSelect;
  window.removeImage = removeImage;
  window.toggleReplyForm = toggleReplyForm;
  window.subscribeToTopic = subscribeToTopic;
  window.filterByTopic = filterByTopic;
  window.setFeedMode = setFeedMode;
  window.discoverAndFilterTopic = discoverAndFilterTopic;
  window.completeTopicSuggestion = completeTopicSuggestion;
  window.scrollToPost = scrollToPost;
  window.clearLocalData = () => stateManager.clearLocalData();
  window.handleReplyImageSelect = handleReplyImageSelect;
  window.removeReplyImage = removeReplyImage;
  window.openDMPanel = openDMPanel;
  window.closeDMPanel = closeDMPanel;
  window.sendDM = sendDM;
  window.toggleThread = toggleThread;
  window.switchDrawer = switchDrawer; // If this exists
  window.setRulePackPath = setRulePackPath;   // choose a new JSON file
  window.reloadRulePack  = reloadRulePack;    // refresh the current file
  window.ratePost = ratePost;
    window.sendDirectMessage = sendDirectMessage;
      window.isToxic = isToxic;
    window.isImageToxic = isImageToxic;  
        window.updateHotTopics = updateHotTopics;
    window.handleProfileUpdate = handleProfileUpdate;
    window.unsubscribeFromProfile =unsubscribeFromProfile;

    window.subscribeToProfile = subscribeToProfile;
  window.state = state;
window.openProfileForHandle = openProfileForHandle;
window.broadcastProfileUpdate = broadcastProfileUpdate;
  // FIX: Expose profile functions to the global scope
  window.closeProfile = closeProfile;

  window.toggleDMMinimize = function() {
    const panel = document.getElementById('dm-panel');
    panel.classList.toggle('minimized');
    
    // If minimized, clicking header should restore
    if (panel.classList.contains('minimized')) {
      panel.querySelector('.dm-header').onclick = () => toggleDMMinimize();
    } else {
      panel.querySelector('.dm-header').onclick = null;
    }
  };

  window.autoResizeDMInput = function(textarea) {
    textarea.style.height = 'auto';
    textarea.style.height = Math.min(textarea.scrollHeight, 120) + 'px';
  };


  // Debugging interface
  window.ephemeralDebug = {
    posts: () => state.posts,
    peers: () => state.peers,
    id: () => state.myIdentity,
    stats: () => ({ posts: state.posts.size, peers: state.peers.size }),
    wasmVDF: wasmVDF,
    reputations: () => {
      console.table(peerManager.debugReputations());
      const stats = peerManager.getReputationStats();
      console.log('Reputation distribution:', stats);
      return stats;
    },
    routing: () => {
      console.log('=== Routing Status ===');
      console.log('Routing Manager:', routingManager.getStats());
      
      if (state.peerRoutingCache) {
        console.log('\nRouting Cache:');
        const now = Date.now();
        for (const [handle, info] of state.peerRoutingCache) {
          console.log(`  ${handle}: age=${Math.floor((now - info.timestamp)/1000)}s, peerId=${info.peerId.substring(0,8)}...`);
        }
      }
      
      console.log('\nPeer Identities:');
      if (state.peerIdentities) {
        for (const [peerId, identity] of state.peerIdentities) {
          console.log(`  ${peerId.substring(0,8)}... => ${identity.handle}`);
        }
      }
      
      return 'See console for routing details';
    },
    forceRoutingUpdate: () => {
      routingManager.updateRouting(true).then(() => 
        console.log('Routing update forced')
      );
    },
    dhtHealth: () => {
      if (!state.dht) {
        return 'DHT not initialized';
      }
      
      const stats = state.dht.getStats();
      console.log('=== DHT Health Report ===');
      console.log('Network:', {
        totalPeers: stats.totalPeers,
        activeBuckets: stats.activeBuckets,
        avgBucketSize: stats.avgBucketSize
      });
      console.log('Storage:', {
        localKeys: stats.localKeys,
        refreshQueue: stats.refreshQueueSize
      });
      console.log('Replication:', stats.replicationHealth);
      
      console.log('\nReplication Details (sample):');
      let count = 0;
      for (const [key, status] of state.dht.replicationStatus) {
        if (count++ >= 10) break;
        console.log(`  ${key}: ${status.replicas} replicas, last checked ${Math.floor((Date.now() - status.lastCheck) / 1000)}s ago`);
      }
      
      return 'See console for DHT health details';
    },
    forceRefresh: async (key) => {
      if (!state.dht) return 'DHT not initialized';
      
      if (key) {
        const value = state.dht.storage.get(key);
        if (value) {
          const result = await state.dht.store(key, value.value || value, { propagate: true });
          return `Refreshed ${key}: ${result.replicas} replicas`;
        }
        return `Key ${key} not found locally`;
      } else {
        await state.dht.refreshStoredValues();
        return 'Triggered refresh of all stored values';
      }
    },
    checkReplication: async (key) => {
      if (!state.dht) return 'DHT not initialized';
      const status = await state.dht.getReplicationStatus(key);
      return `Key ${key}: ${status.replicas} replicas found`;
    }
  };

  // Start the application initialization process once the page is loaded.
  window.addEventListener("load", init);



========================================
--- FILE: services.js
========================================
// FILE: services.js

// --- IMPORTS FOR ALL SERVICES ---
import { VerificationQueue } from './verification-queue.js';
import { MemoryManager } from './services/memory-manager.js';
import { PeerManager } from './services/peer-manager.js';
import { ContentAddressedImageStore } from './services/image-store.js';
import { ProgressiveVDF } from './identity/vdf.js';
import { NoiseGenerator } from './p2p/noise-generator.js';
import { TrafficMixer } from './p2p/traffic-mixer.js';
import { EpidemicGossip } from './p2p/epidemic-gossip.js';

import { StateManager } from './storage.js';
import { setServices } from './services/instances.js';

// --- SERVICE INSTANCES ---
// Create instances with dependency injection
export function initializeServices(dependencies = {}) {
  const imageStore = new ContentAddressedImageStore();
  const peerManager = new PeerManager();
  
  const stateManager = new StateManager({
    imageStore,
    peerManager,
    renderPost: dependencies.renderPost
  });
  
  const services = {
    stateManager,
    verificationQueue: new VerificationQueue(),
    imageStore,
    peerManager,
    memoryManager: new MemoryManager(),
    progressiveVDF: new ProgressiveVDF(),
    noiseGenerator: new NoiseGenerator(),
    trafficMixer: new TrafficMixer(),
    epidemicGossip: new EpidemicGossip()
  };
  
  setServices(services);
  return services;
}

// Re-export for backward compatibility
export { getServices, getImageStore, getPeerManager, getStateManager } from './services/instances.js';




========================================
--- FILE: state.js
========================================
// FILE: state.js
import { HierarchicalBloomFilter } from './utils.js';

// This file ONLY defines and exports the shared state object.
export const state = {
  posts: new Map(),
  peers: new Map(),
  peerIdentities: new Map(),
  myIdentity: null,
  client: null,
  provisionalIdentities: new Map(),
  explicitlyCarrying: new Set(),
  viewing: new Set(),
  toxicityClassifier: null,
  imageClassifier: null,
  seenMessages: new HierarchicalBloomFilter(),
  seenPosts: new HierarchicalBloomFilter(),
  dht: null,
  hyparview: null,
  scribe: null,
  identityRegistry: null,
  subscribedTopics: new Set([]),
  topicFilter: '',
  feedMode: 'all',
  pendingVerification: new Map(),
  viewingProfile: null,
  profileCache: new Map(),
};


========================================
--- FILE: storage.js
========================================
import { state } from './state.js';
import { generateId } from './utils.js';
import { Post } from './models/post.js';

export class StateManager {
  constructor(dependencies = {}) {
    this.imageStore = dependencies.imageStore;
    this.peerManager = dependencies.peerManager;
    this.renderPost = dependencies.renderPost;
    this.dbName = 'EmberNetwork';
    this.version = 2;
    this.db = null;
  }
  
    async clearLocalData() {
        if (confirm('This will clear all saved posts and reset your identity. Continue?')) {
          // Close the DB connection this manager is holding
          if (this.db) {
            this.db.close();
          }
          // Clear IndexedDB and localStorage
          await indexedDB.deleteDatabase(this.dbName);
          localStorage.clear();
          location.reload();
        }
      }
  
  async init() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, this.version);
      
      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        this.db = request.result;
        resolve();
      };
      
      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        
        // Posts store
        if (!db.objectStoreNames.contains('posts')) {
          const postsStore = db.createObjectStore('posts', { keyPath: 'id' });
          postsStore.createIndex('timestamp', 'timestamp', { unique: false });
          postsStore.createIndex('parentId', 'parentId', { unique: false });
        }
        
        // Image Chunks store
        if (!db.objectStoreNames.contains('imageChunks')) {
            // The keyPath will be the chunk's hash
            db.createObjectStore('imageChunks', { keyPath: 'hash' });
        }
        
        // User state store (identity, preferences)
        if (!db.objectStoreNames.contains('userState')) {
          db.createObjectStore('userState', { keyPath: 'key' });
        }
        
        // Peer reputation store
        if (!db.objectStoreNames.contains('peerScores')) {
          db.createObjectStore('peerScores', { keyPath: 'peerId' });
        }
        
        if (!db.objectStoreNames.contains('dhtRoutingTable')) {
            db.createObjectStore('dhtRoutingTable', { keyPath: 'bucketIndex' });
        }
        if (!db.objectStoreNames.contains('dhtStorage')) {
            db.createObjectStore('dhtStorage', { keyPath: 'key' });
        }
        
      // pending messages store
      if (!db.objectStoreNames.contains('pendingMessages')) {
        const pendingStore = db.createObjectStore('pendingMessages', { keyPath: 'id' });
        pendingStore.createIndex('recipient', 'recipient', { unique: false });
        pendingStore.createIndex('sender', 'sender', { unique: false });
        pendingStore.createIndex('timestamp', 'timestamp', { unique: false });
        pendingStore.createIndex('status', 'status', { unique: false });
      }
      
      //  delivery receipts store
      if (!db.objectStoreNames.contains('messageReceipts')) {
        const receiptsStore = db.createObjectStore('messageReceipts', { keyPath: 'messageId' });
        receiptsStore.createIndex('timestamp', 'timestamp', { unique: false });
      }
      
    };
    });
  }
    
  async savePosts() {
    if (!this.db) return;
    
    const transaction = this.db.transaction(['posts'], 'readwrite');
    const store = transaction.objectStore('posts');
    
    // Clear existing posts first
    await new Promise((resolve) => {
      const clearReq = store.clear();
      clearReq.onsuccess = resolve;
    });
    
    // Save all current posts
    for (const [id, post] of state.posts) {
      const postData = post.toJSON();
      // Include metadata about our explicit carries
      postData.wasExplicitlyCarried = state.explicitlyCarrying.has(id);
      postData.lastSeen = Date.now();
        try {
            store.add(postData);
        } catch(e) {
            if (e.name === 'QuotaExceededError') {
                console.error("Storage quota exceeded while saving posts. Aborting.");
                notify("Storage is full. Cannot save session.", 5000);
                transaction.abort();
                return; // Exit the loop
            }
        }
    }
  }
  
  async loadPosts() {
      if (!this.db) return;
      
      const transaction = this.db.transaction(['posts'], 'readonly');
      const store = transaction.objectStore('posts');
      const request = store.getAll();
      
      return new Promise((resolve) => {
        request.onsuccess = () => {
          const posts = request.result;
          const now = Date.now();
          let loadedCount = 0;
          
          posts.forEach(postData => {
            // Check if post is too old (24 hours)
            const age = now - postData.timestamp;
            if (age > 24 * 60 * 60 * 1000) return;
            
            // Check if post should still exist based on carriers
            if (postData.carriers.length === 0) return;
            
            // Recreate the post
            const post = Post.fromJSON(postData);            

            // Ensure trust properties are initialized
            if (!post.trustScore) post.trustScore = 0;
            if (!post.attesters) post.attesters = new Set();
            if (!post.attestationTimestamps) post.attestationTimestamps = new Map();

            // Queue for verification instead of marking as verified
            post.verified = true; //do we trust ourselves?
            //state.pendingVerification.set(post.id, post);

            // Decay carriers based on time away
            const hoursAway = Math.floor((now - postData.lastSeen) / (60 * 60 * 1000));
            const decayFactor = Math.max(0.5, 1 - (hoursAway * 0.1)); // Lose 10% per hour away
            
            // Randomly remove some carriers based on decay
            const carriersArray = [...post.carriers];
            const keepCount = Math.max(1, Math.floor(carriersArray.length * decayFactor));
            
            // Keep our own carry if we explicitly carried it
            const mustKeep = postData.wasExplicitlyCarried ? [state.myIdentity.handle] : [];
            const others = carriersArray.filter(c => c !== state.myIdentity.handle);
            
            // Randomly select carriers to keep
            const shuffled = others.sort(() => Math.random() - 0.5);
            const kept = mustKeep.concat(shuffled.slice(0, keepCount - mustKeep.length));
            
            post.carriers = new Set(kept);
            
            // Only load if post still has carriers OR we explicitly carried it
            if (post.carriers.size > 0 || postData.wasExplicitlyCarried) {
              // *** Check if the post was already in pendingVerification from a previous load. ***
              // If so, we use the already-verified version we just created.
              if (state.pendingVerification.has(post.id)) {
                  state.pendingVerification.delete(post.id);
              }

              state.posts.set(post.id, post);
              if (this.renderPost) {
                this.renderPost(post); // Render the post immediately
              }

              if (postData.wasExplicitlyCarried) {
                state.explicitlyCarrying.add(post.id);
              }
              loadedCount++;
            }
          });
          
          console.log(`Loaded ${loadedCount} posts from storage (all marked as verified)`);
          resolve(loadedCount);
        };
      });
    }
  
  
  async saveImageChunks() {
        if (!this.db || !this.imageStore) return;

        const transaction = this.db.transaction(['imageChunks'], 'readwrite');
        const store = transaction.objectStore('imageChunks');

        // Clear old chunks first to manage storage size
        await new Promise((resolve) => {
            const clearReq = store.clear();
            clearReq.onsuccess = resolve;
        });

        // Save all current chunks from the imageStore
        for (const [hash, data] of this.imageStore.chunks) {
            store.add({ hash: hash, data: data });
        }
        console.log(`Saved ${this.imageStore.chunks.size} image chunks to storage.`);
    }

    async loadImageChunks() {
        if (!this.db || !this.imageStore) return;

        const transaction = this.db.transaction(['imageChunks'], 'readonly');
        const store = transaction.objectStore('imageChunks');
        const request = store.getAll();

        return new Promise((resolve) => {
            request.onsuccess = () => {
                const chunks = request.result;
                chunks.forEach(chunk => {
                    this.imageStore.chunks.set(chunk.hash, chunk.data);
                });
                console.log(`Loaded ${chunks.length} image chunks from storage.`);
                resolve(chunks.length);
            };
            request.onerror = (event) => {
                console.error("Failed to load image chunks:", event.target.error);
                resolve(0);
            };
        });
    }

  
  
  
  async saveUserState() {
    if (!this.db) return;
    
    const transaction = this.db.transaction(['userState'], 'readwrite');
    const store = transaction.objectStore('userState');
    
    // Save identity (including profile)
    store.put({ 
      key: 'identity', 
      value: state.myIdentity 
    });
    
    // Save theme preference
    store.put({ 
      key: 'theme', 
      value: localStorage.getItem('ephemeral-theme') || 'dark' 
    });
    
    // Save explicitly carried posts
    store.put({ 
      key: 'explicitlyCarrying', 
      value: Array.from(state.explicitlyCarrying) 
    });
  }
  
    async loadUserState() {
        if (!this.db) return;

        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction(['userState'], 'readonly');
            const store = transaction.objectStore('userState');

            const identityReq = store.get('identity');
            const carryReq = store.get('explicitlyCarrying');

            let identityLoaded = false;
            let carryLoaded = false;

            const checkCompletion = () => {
                if (identityLoaded && carryLoaded) {
                    resolve(); // Resolve the promise only when both are done
                }
            };

            identityReq.onsuccess = () => {
                if (identityReq.result) {
                    state.myIdentity = identityReq.result.value;
                    console.log('Loaded identity from storage');
                }
                identityLoaded = true;
                checkCompletion();
            };

            carryReq.onsuccess = () => {
                if (carryReq.result) {
                    state.explicitlyCarrying = new Set(carryReq.result.value);
                }
                carryLoaded = true;
                checkCompletion();
            };

            identityReq.onerror = (event) => {
                console.error("Failed to load identity:", event.target.error);
                identityLoaded = true; // Mark as done even on error to not block forever
                checkCompletion();
            };

            carryReq.onerror = (event) => {
                console.error("Failed to load explicitly carried posts:", event.target.error);
                carryLoaded = true; // Mark as done even on error
                checkCompletion();
            };
        });
    }
  
  async savePeerScores() {
    if (!this.db || !this.peerManager) return;
    
    const transaction = this.db.transaction(['peerScores'], 'readwrite');
    const store = transaction.objectStore('peerScores');
    
    this.peerManager.scores.forEach((score, peerId) => {
      store.put({ peerId, ...score });
    });
  }
  
  async loadPeerScores() {
    if (!this.db || !this.peerManager) return;
    
    const transaction = this.db.transaction(['peerScores'], 'readonly');
    const store = transaction.objectStore('peerScores');
    const request = store.getAll();
    
    return new Promise((resolve) => {
      request.onsuccess = () => {
        const scores = request.result;
        scores.forEach(score => {
          const { peerId, ...data } = score;
          this.peerManager.scores.set(peerId, data);
        });
        console.log(`Loaded ${scores.length} peer scores`);
        resolve();
      };
    });
  }
  
  // Clean up old data
  async cleanup() {
    if (!this.db) return;
    
    const transaction = this.db.transaction(['posts'], 'readwrite');
    const store = transaction.objectStore('posts');
    const index = store.index('timestamp');
    
    // Delete posts older than 7 days
    const cutoff = Date.now() - (7 * 24 * 60 * 60 * 1000);
    const range = IDBKeyRange.upperBound(cutoff);
    
    index.openCursor(range).onsuccess = (event) => {
      const cursor = event.target.result;
      if (cursor) {
        cursor.delete();
        cursor.continue();
      }
    };
  }
  
  async storePendingMessage(recipientHandle, messageText, senderHandle, encrypted = null) {
      if (!this.db) return null;
      try {
        const messageId = generateId();
        const pendingMessage = {
          id: messageId,
          recipient: recipientHandle,
          sender: senderHandle,
          message: messageText,
          encrypted: encrypted,
          timestamp: Date.now(),
          attempts: 0,
          lastAttempt: null,
          status: 'pending',
          expiresAt: Date.now() + (7 * 24 * 60 * 60 * 1000) // 7 days
        };
        const transaction = this.db.transaction(['pendingMessages'], 'readwrite');
        const store = transaction.objectStore('pendingMessages');
        
        // FIX: Wrap the IDBRequest in a Promise
        await new Promise((resolve, reject) => {
            const request = store.add(pendingMessage);
            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
        });
        
        console.log(`[Storage] Stored pending message ${messageId} for ${recipientHandle}`);
        return messageId;
      } catch (error) {
        console.error('[Storage] Failed to store pending message:', error);
        return null;
      }
    }

    async getPendingMessagesFor(recipientHandle) {
      if (!this.db) return [];
      try {
        const transaction = this.db.transaction(['pendingMessages'], 'readonly');
        const store = transaction.objectStore('pendingMessages');
        const index = store.index('recipient');
        
        // FIX: Wrap the IDBRequest in a Promise
        const messages = await new Promise((resolve, reject) => {
            const request = index.getAll(recipientHandle);
            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
        });
        
        const now = Date.now();
        return messages.filter(msg => 
          msg.status === 'pending' && 
          msg.expiresAt > now
        );
      } catch (error) {
        console.error('[Storage] Failed to get pending messages:', error);
        return [];
      }
    }

    async getPendingMessagesFrom(senderHandle) {
      if (!this.db) return [];
      try {
        const transaction = this.db.transaction(['pendingMessages'], 'readonly');
        const store = transaction.objectStore('pendingMessages');
        const index = store.index('sender');
        
        // FIX: Wrap the IDBRequest in a Promise
        const messages = await new Promise((resolve, reject) => {
            const request = index.getAll(senderHandle);
            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
        });

        return messages.filter(msg => msg.status === 'pending');
      } catch (error) {
        console.error('[Storage] Failed to get pending messages from sender:', error);
        return [];
      }
    }

    async markMessageDelivered(messageId) {
      if (!this.db) return;
      try {
        const transaction = this.db.transaction(['pendingMessages', 'messageReceipts'], 'readwrite');
        const messagesStore = transaction.objectStore('pendingMessages');
        const receiptsStore = transaction.objectStore('messageReceipts');
        
        // FIX: Wrap the IDBRequest in a Promise
        const message = await new Promise((resolve, reject) => {
            const request = messagesStore.get(messageId);
            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
        });

        if (message) {
          message.status = 'delivered';
          message.deliveredAt = Date.now();
          
          // FIX: Wrap subsequent requests in Promises
          await new Promise((resolve, reject) => {
              const request = messagesStore.put(message);
              request.onsuccess = () => resolve(request.result);
              request.onerror = () => reject(request.error);
          });
          
          await new Promise((resolve, reject) => {
              const request = receiptsStore.add({
                  messageId: messageId,
                  timestamp: Date.now(),
                  recipient: message.recipient
              });
              request.onsuccess = () => resolve(request.result);
              request.onerror = () => reject(request.error);
          });

          console.log(`[Storage] Marked message ${messageId} as delivered`);
        }
      } catch (error) {
        console.error('[Storage] Failed to mark message as delivered:', error);
      }
    }

    async updateMessageAttempt(messageId) {
      if (!this.db) return;
      try {
        const transaction = this.db.transaction(['pendingMessages'], 'readwrite');
        const store = transaction.objectStore('pendingMessages');
        
        // FIX: Wrap the IDBRequest in a Promise
        const message = await new Promise((resolve, reject) => {
            const request = store.get(messageId);
            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
        });

        if (message) {
          message.attempts++;
          message.lastAttempt = Date.now();
          
          if (message.attempts >= 10) {
            message.status = 'failed';
          }
          
          // FIX: Wrap the put request in a Promise
          await new Promise((resolve, reject) => {
              const request = store.put(message);
              request.onsuccess = () => resolve(request.result);
              request.onerror = () => reject(request.error);
          });
        }
      } catch (error) {
        console.error('[Storage] Failed to update message attempt:', error);
      }
    }

    async cleanupOldMessages() {
      if (!this.db) return;
      
      try {
        const transaction = this.db.transaction(['pendingMessages'], 'readwrite');
        const store = transaction.objectStore('pendingMessages');
        const messages = await store.getAll();
        
        const now = Date.now();
        let deletedCount = 0;
        
        for (const message of messages) {
          // Delete if: expired, delivered over 24h ago, or failed
          if (message.expiresAt < now ||
              (message.status === 'delivered' && now - message.deliveredAt > 86400000) ||
              message.status === 'failed') {
            await store.delete(message.id);
            deletedCount++;
          }
        }
        
        if (deletedCount > 0) {
          console.log(`[Storage] Cleaned up ${deletedCount} old messages`);
        }
      } catch (error) {
        console.error('[Storage] Failed to cleanup old messages:', error);
      }
    }
  async saveDHTState() {
  if (!this.db || !state.dht) return;
  
  try {
    const dhtState = state.dht.serialize();
    const transaction = this.db.transaction(['dhtRoutingTable', 'dhtStorage'], 'readwrite');
    const routingStore = transaction.objectStore('dhtRoutingTable');
    const storageStore = transaction.objectStore('dhtStorage');
    
    // Clear existing data
    await new Promise((resolve) => {
      const clearReq1 = routingStore.clear();
      clearReq1.onsuccess = resolve;
    });
    
    await new Promise((resolve) => {
      const clearReq2 = storageStore.clear();
      clearReq2.onsuccess = resolve;
    });
    
    // Save routing table (buckets)
    if (dhtState.buckets) {
      dhtState.buckets.forEach((bucket, index) => {
        if (bucket.length > 0) {
          routingStore.add({ bucketIndex: index, peers: bucket });
        }
      });
    }
    
    // Save DHT storage
    if (dhtState.storage) {
      dhtState.storage.forEach(([key, value]) => {
        storageStore.add({ key, value });
      });
    }
    
    console.log('[StateManager] Saved DHT state');
  } catch (error) {
    console.error('[StateManager] Failed to save DHT state:', error);
  }
}

async loadDHTState() {
  if (!this.db) return;
  
  try {
    const transaction = this.db.transaction(['dhtRoutingTable', 'dhtStorage'], 'readonly');
    const routingStore = transaction.objectStore('dhtRoutingTable');
    const storageStore = transaction.objectStore('dhtStorage');
    
    // Load routing table
    const bucketsData = await new Promise((resolve) => {
      const request = routingStore.getAll();
      request.onsuccess = () => resolve(request.result);
    });
    
    // Load storage
    const storageData = await new Promise((resolve) => {
      const request = storageStore.getAll();
      request.onsuccess = () => resolve(request.result);
    });
    
    // Wait for DHT to be initialized
    if (state.dht && bucketsData.length > 0) {
        // First, create a new, full, and valid array of 160 empty buckets.
        const buckets = new Array(160).fill(null).map(() => []);

        // Then, populate it with the data that was loaded from storage.
        bucketsData.forEach(item => {
          // Ensure the saved index is valid before assigning.
          if (item.bucketIndex >= 0 && item.bucketIndex < 160) {
            buckets[item.bucketIndex] = item.peers;
          }
        });
        const storage = storageData.map(item => [item.key, item.value]);

        // Deserialize the now-complete and valid state into the DHT instance.
        state.dht.deserialize({ buckets, storage });
        console.log('[StateManager] Loaded DHT state with', bucketsData.length, 'buckets and', storageData.length, 'keys');
    }
  } catch (error) {
    console.error('[StateManager] Failed to load DHT state:', error);
  }
}
  
}


========================================
--- FILE: ui.js
========================================
// FILE: ui.js
// ui.js
// This module contains all functions and variables responsible for
// interacting with the DOM, rendering content, and handling UI events.

// --- IMPORTS ---
import { getImageStore } from './services/instances.js';
import { state } from './state.js';
import { sanitize, sanitizeDM } from './utils.js';
import { CONFIG } from './config.js';
import DOMPurify from 'dompurify';

// Dynamic sendPeer injection
let sendPeerFunction = null;
export function setSendPeer(fn) {
  sendPeerFunction = fn;
}

// --- LOCAL HELPERS ---
// Small helper functions that are only used by the UI.
const isReply = (post) => post && post.parentId;

// --- UI STATE & OBSERVERS ---
// Top-level constants and variables that manage UI state.
let bonfireUpdateTimeout;
let showAllShards = true;

export let currentDMRecipient = null;

const animationObserver = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      entry.target.classList.add('animate');
    } else {
      entry.target.classList.remove('animate');
    }
  });
}, { threshold: 0.1 });


// --- CORE RENDERING & POST INTERACTION ---
// These functions are responsible for displaying and interacting with posts and threads.
export function updateConnectionStatus(message, type = 'info') {
  console.log(`[Status] ${message}`);

  const loadingEl = document.getElementById("loading");
  if (!loadingEl || loadingEl.style.display === "none") return;

  const statusDiv = loadingEl.querySelector('div:last-child') ||
                   loadingEl.querySelector('.loading-content').lastElementChild;

  if (statusDiv) {
    const color = type === 'error' ? '#ff4444' :
                  type === 'success' ? '#44ff44' :
                  '#ff8c42';

    statusDiv.innerHTML = `<div style="font-size:12px;margin-top:10px;color:${color}">${message}</div>`;

    // For success messages, add a nice animation
    if (type === 'success') {
      statusDiv.style.animation = 'pulse 1s ease-in-out';
    }
  }
}
function notify(msg, dur = 3000, onClick = null) {
  const n = document.createElement("div");
  n.className = "notification";
  n.textContent = msg;
   if (onClick) n.addEventListener('click', () => { onClick(); n.remove(); });
  document.body.appendChild(n);
  setTimeout(() => {
    n.style.animationDirection = "reverse";
    setTimeout(() => n.remove(), 300);
  }, dur);
}

export function initializeUserProfileSection() {
  console.log('[Debug] initializeUserProfileSection from ui.js has been called.');
  if (!state.myIdentity) {
    console.log('[Debug] Exiting: state.myIdentity is not set.'); 
    return;
  }
  
  const section = document.getElementById('user-profile-section');
  const handleEl = document.getElementById('user-profile-handle');
  const picContainer = document.getElementById('user-profile-pic');

  if (section && handleEl && picContainer) { // Added picContainer to the check
    console.log('[Debug] Success: Found elements, setting display to block.'); 
    section.style.display = 'block';
    handleEl.textContent = state.myIdentity.handle;
    
    // Update profile picture if available
    const profile = state.myIdentity.profile;
    if (profile && profile.profilePictureHash) {
      const hash = profile.profilePictureHash;
      getImageStore().retrieveImage(hash).then(imageData => {
        if (imageData) {
          picContainer.innerHTML = `<img src="${imageData}" alt="Your profile" />`;
        } else {
          // ***  If image isn't ready, create a placeholder ***
          // This allows the periodic update function to find and fill it later.
          picContainer.innerHTML = `<div class="profile-picture-placeholder-small" data-hash="${hash}">üë§</div>`;
        }
      });
    }
  } else {
    console.error('[Debug] Failed: Could not find #user-profile-section, #user-profile-handle, or #user-profile-pic in the DOM.');
  }
}

async function renderPost(p, container = null) {
    console.log("render post called");
  if (document.getElementById("post-" + p.id)) return;

  const el = document.createElement("div");
  el.className = p.parentId ? `post reply depth-${Math.min(p.depth, 5)}` : "post";
  el.id = "post-" + p.id;
  animationObserver.observe(el);

  await updateInner(el, p); // Now async

  // Determine where to insert the post
  if (container) {
    container.appendChild(el);
  } else if (p.parentId) {
    // Find parent element and add to its replies container
    const parentEl = document.getElementById("post-" + p.parentId);
    if (parentEl) {
      let repliesContainer = parentEl.querySelector('.replies-container');
      if (!repliesContainer) {
        repliesContainer = document.createElement('div');
        repliesContainer.className = 'replies-container';
        parentEl.appendChild(repliesContainer);
      }
      repliesContainer.appendChild(el);
    } else {
      // Parent not found, add to main feed
      document.getElementById("posts").prepend(el);
    }
  } else {
    // Top-level post
    document.getElementById("posts").prepend(el);
  }

  state.viewing.add(p.id);
  updateStatus();
}

// Function to update profile pictures when they arrive
export function updateProfilePicturesInPosts() {
  // Check all placeholder profile pics periodically
  const placeholders = document.querySelectorAll('.author-profile-placeholder[data-hash]');
  
  placeholders.forEach(async (placeholder) => {
    const hash = placeholder.dataset.hash;
    const imageData = await getImageStore().retrieveImage(hash);
    
    if (imageData) {
      const img = document.createElement('img');
      img.src = imageData;
      img.className = 'author-profile-pic';
      img.alt = "Profile picture";
      placeholder.replaceWith(img);
    }
  });
}

function getHeatLevel(carrierCount) {
  if (carrierCount >= 20) return "üî• Inferno";
  if (carrierCount >= 15) return "üî• Blazing";
  if (carrierCount >= 10) return "üî• Burning";
  if (carrierCount >= 5) return "üåü Glowing";
  if (carrierCount >= 2) return "‚ú® Flickering";
  return "üí® Dying ember";
}

async function updateInner(el, p) {
  if (!p) return;

  // Initialize properties if missing
  if (!p.carriers) p.carriers = new Set();
  if (!p.replies) p.replies = new Set();

  const existingHTML = el.innerHTML;
  const mine = p.carriers.has(state.myIdentity?.handle);
  const isAuthor = p.author === state.myIdentity?.handle;
  const carrierCount = p.carriers.size;

  const heatLevel = getHeatLevel(carrierCount);
  const heatOpacity = Math.min(0.1 + (carrierCount / 20), 1);

  const threadSize = getThreadSize(p.id);
  const hasReplies = p.replies.size > 0;
  // verification indicator
  let verificationBadge = '';
  
  //  profile picture logic
  let authorProfilePic = '';
  const cachedProfile = state.profileCache.get(p.author);
  
  if (cachedProfile && cachedProfile.profilePictureHash) {
    const imageData = await getImageStore().retrieveImage(cachedProfile.profilePictureHash);
    if (imageData) {
      authorProfilePic = `<img src="${imageData}" class="author-profile-pic" alt="${p.author}'s profile" />`;
    } else {
      // Request the image if not found
      const peers = Array.from(state.peers.values()).slice(0, 3);
      for (const peer of peers) {
        if (peer.wire && !peer.wire.destroyed) {
          sendPeerFunction(peer.wire, { type: "request_image", imageHash: cachedProfile.profilePictureHash });
        }
      }
      authorProfilePic = `<div class="author-profile-pic author-profile-placeholder" data-hash="${cachedProfile.profilePictureHash}">üë§</div>`;
    }
  } else {
    // No profile cached, show placeholder
    authorProfilePic = '<div class="author-profile-pic author-profile-placeholder">üë§</div>';
  }
  
  
  if (p.verified) {
    const identityVerified = state.identityRegistry?.verifiedIdentities.has(p.author);
    if (identityVerified) {
      verificationBadge = '<span class="verified-badge" title="Cryptographically verified + Identity confirmed">‚úìüîí</span>';
    } else {
      verificationBadge = '<span class="verified-badge" title="Cryptographically verified">‚úì</span>';
    }
  } else {
    verificationBadge = '<span class="unverified-badge" title="Verification pending">‚è≥</span>';
  }

    let imageHtml = '';
    if (p.imageHash) {
        if (p.imageData) {
            // We already have the image data, show it
            imageHtml = `<img src="${p.imageData}" class="post-image" alt="Posted image" />`;
        } else if (!p._imageLoading) {
            // We don't have the image yet, try to retrieve it
            p._imageLoading = true;
            const currentElId = el.id;

            getImageStore().retrieveImage(p.imageHash).then(imageData => {
                p._imageLoading = false;
                const stillExists = document.getElementById(currentElId);
                if (stillExists && imageData) {
                    p.imageData = imageData; // Cache the image data
                    const imgPlaceholder = stillExists.querySelector('.image-placeholder');
                    if (imgPlaceholder) {
                        imgPlaceholder.outerHTML = `<img src="${imageData}" class="post-image" alt="Posted image" />`;
                    }
                }
            }).catch(err => {
                p._imageLoading = false;
                console.error('Failed to load image:', err);
            });

            // Show placeholder while loading
            imageHtml = `<div class="image-placeholder" style="width:100%;height:150px;background:#333;display:flex;align-items:center;justify-content:center;color:#fff;">Loading Image...</div>`;
        } else {
            // Loading in progress, show placeholder
            imageHtml = `<div class="image-placeholder" style="width:100%;height:150px;background:#333;display:flex;align-items:center;justify-content:center;color:#fff;">Loading Image...</div>`;
        }
    }

    // Gets the community rating of the post
    const ratingSummary = p.getRatingSummary();
    const userVote = p.ratings.get(state.myIdentity?.handle)?.vote;
    
    // Display score as percentage with emoji indicator
    let scoreDisplay = 'Unrated';
    let scoreEmoji = '';
    if (ratingSummary.total > 0) {
        const percentage = Math.round(ratingSummary.score * 100);
        scoreDisplay = `${percentage}%`;
        
        // Add emoji based on score
        if (percentage >= 80) scoreEmoji = 'üî•';
        else if (percentage >= 60) scoreEmoji = '‚ú®';
        else if (percentage >= 40) scoreEmoji = 'üí®';
        else scoreEmoji = '‚ùÑÔ∏è';
    }
    
    // Confidence visualization 
    const confidenceLevel = Math.round(ratingSummary.confidence * 5);
    const confidenceDisplay = '‚óè'.repeat(confidenceLevel) + '‚óã'.repeat(5 - confidenceLevel);



  // This logic adds the topic tags to the post's HTML
  let topicsHtml = '';
  if (state.scribe) {
    const topics = state.scribe.extractTopics(p.content);
    if (topics.length > 0) {
      topicsHtml = `
          <div class="post-topics">
              ${topics.map(topic => `<span class="post-topic-tag" data-topic="${sanitize(topic)}">${sanitize(topic)}</span>`).join('')}
          </div>`;
    }
  }

  // Preserve existing replies container
  const existingRepliesContainer = el.querySelector('.replies-container');

el.innerHTML = `
    <div class="author-section">
      ${authorProfilePic}
      <div class="author clickable-author" data-handle="${p.author}">${p.author} ${verificationBadge}</div>
    </div>
    <div class="content">${DOMPurify.sanitize(p.content)}</div> <!-- FIXED: Sanitize post content -->
    ${imageHtml}
    ${topicsHtml}
    <div class="post-footer">
        <div class="carriers">
            <span class="heat-level">${heatLevel}</span>
            <span class="carrier-count">${carrierCount}</span>&nbsp;${carrierCount === 1 ? 'breath' : 'breaths'}
            ${hasReplies ? `<span class="thread-stats"><span class="thread-ember">üî•</span> ${threadSize} in thread</span>` : ''}
        </div>
        <div class="rating-display">
            <span class="rating-score" title="Community rating: ${ratingSummary.weightedTotal.toFixed(1)} weighted votes">
                ${scoreEmoji} ${scoreDisplay}
            </span>
            <span class="rating-confidence" title="Confidence: ${(ratingSummary.confidence * 100).toFixed(0)}%">
                ${confidenceDisplay}
            </span>
        </div>
        <div class="rating-buttons">
            <button class="rate-up ${userVote === 'up' ? 'active' : ''}" 
                    onclick="ratePost('${p.id}', 'up')" 
                    title="Good post"
                    ${userVote === 'up' ? 'disabled' : ''}>
                üëç <span class="vote-count">${ratingSummary.upvotes}</span>
            </button>
            <button class="rate-down ${userVote === 'down' ? 'active' : ''}" 
                    onclick="ratePost('${p.id}', 'down')" 
                    title="Poor post"
                    ${userVote === 'down' ? 'disabled' : ''}>
                üëé <span class="vote-count">${ratingSummary.downvotes}</span>
            </button>
        </div>
        <div class="post-actions">
            <button class="carry-button ${mine ? 'withdrawing' : 'blowing'}" onclick="toggleCarry('${p.id}')">
                ${isAuthor ? "üå¨Ô∏è" : (mine ? "üí®" : "üî•")}
            </button>
            <button class="reply-button" onclick="toggleReplyForm('${p.id}')">üí¨</button>
            ${!isAuthor ? `<button class="dm-button" onclick="openDMPanel('${p.author}')">üì®</button>` : ''}
            ${hasReplies ? `<span class="collapse-thread" onclick="toggleThread('${p.id}')">[${el.classList.contains('collapsed') ? '+' : '-'}]</span>` : ''}
        </div>
    </div>
    <div id="reply-form-${p.id}" class="reply-compose" style="display: none;">
        <textarea id="reply-input-${p.id}" class="reply-input" placeholder="Add to the conversation..." maxlength="1125"></textarea>
        <div class="reply-image-preview" id="reply-image-preview-${p.id}" style="display:none;">
            <img id="reply-preview-img-${p.id}" />
            <button onclick="removeReplyImage('${p.id}')">‚úï</button>
        </div>
        <div class="compose-footer">
            <input type="file" id="reply-image-input-${p.id}" accept="image/*" style="display:none;" onchange="handleReplyImageSelect(this, '${p.id}')" />
            <button onclick="document.getElementById('reply-image-input-${p.id}').click()" class="image-button">üì∑</button>
            <span class="char-count"><span id="reply-char-${p.id}">0</span>/${CONFIG.MAX_POST_SIZE}</span>
            <button onclick="createReply('${p.id}')" class="primary-button">üî•</button>
        </div>
    </div>`;


  // Add safe event listeners to the new topic tags
  const topicTags = el.querySelectorAll('.post-topic-tag');
  topicTags.forEach(tag => {
    tag.addEventListener('click', (event) => {
      event.stopPropagation(); // Prevent post click events
      const topic = event.target.dataset.topic;
      if (topic) {
        discoverAndFilterTopic(topic);
      }
    });
  });
  
  // Add click handler for author
    const authorSection = el.querySelector('.author-section');
    if (authorSection) {
      authorSection.addEventListener('click', (event) => {
        event.stopPropagation();
        const handle = el.querySelector('.clickable-author').dataset.handle;
        if (handle) {
          openProfileForHandle(handle);
        }
      });
    }

  // *** FIX: Re-attach the existing replies container if it existed ***
  if (existingRepliesContainer) {
    el.appendChild(existingRepliesContainer);
  }

  el.style.setProperty('--heat-opacity', heatOpacity);
  el.classList.toggle('inferno', carrierCount >= 20);
  el.classList.toggle('hot', carrierCount >= 10);
  el.classList.toggle('warm', carrierCount >= 5);
  el.classList.toggle('dying', carrierCount === 0);

  if (p.parentId && p.depth > 0) {
    const threadLine = document.createElement('div');
    threadLine.className = 'thread-line';
    el.appendChild(threadLine);
  }
}

async function refreshPost(p) {
    const el = document.getElementById("post-" + p.id);
    if (el) await updateInner(el, p);
}

function dropPost(id) {
    const el = document.getElementById("post-" + id);
    if (el) {
        if (window.animationObserver) {
            animationObserver.unobserve(el);
        }
        const replies = el.querySelectorAll('.post.reply');
        replies.forEach(reply => {
            if (window.animationObserver) {
                animationObserver.unobserve(reply);
            }
        });
        el.classList.add("dying");
        setTimeout(() => el.remove(), 1000);
    }
    state.viewing.delete(id);
    updateStatus();
}

function getThreadSize(postId) {
  let count = 0;
  const post = state.posts.get(postId);
  if (!post) return 0;

  const visited = new Set();
  const queue = [postId];

  while (queue.length > 0) {
    const id = queue.shift();
    if (visited.has(id)) continue;
    visited.add(id);

    const p = state.posts.get(id);
    if (p) {
      count++;
      p.replies.forEach(replyId => queue.push(replyId));
    }
  }

  return count - 1; // Exclude the parent post itself
}

function toggleReplyForm(postId) {
    const form = document.getElementById(`reply-form-${postId}`);
    if (form) {
        form.style.display = form.style.display === 'none' ? 'block' : 'none';
        if (form.style.display === 'block') {
            const input = document.getElementById(`reply-input-${postId}`);
            input.focus();
            input.addEventListener('input', (e) => {
                document.getElementById(`reply-char-${postId}`).textContent = e.target.value.length;
            });
        }
    }
}

function toggleThread(postId) {
    const post = state.posts.get(postId);
    if (!post || post.replies.size === 0) return;

    const postEl = document.getElementById(`post-${postId}`);
    if (!postEl) return;

    const repliesContainer = postEl.querySelector('.replies-container');
    const collapseButton = postEl.querySelector('.collapse-thread');

    if (repliesContainer && collapseButton) {
        const isCollapsed = repliesContainer.style.display === 'none';
        if (isCollapsed) {
            repliesContainer.style.display = 'block';
            postEl.classList.remove('collapsed');
            collapseButton.textContent = '[-]';
        } else {
            repliesContainer.style.display = 'none';
            postEl.classList.add('collapsed');
            collapseButton.textContent = '[+]';
        }
    }
}
/*
function updateBonfire() {
    const bonfireContentEl = document.getElementById('bonfire-content');
    if (!bonfireContentEl) return;

    const threads = new Map();

    for (const [id, post] of state.posts) {
        const rootId = findRootPost(id);
        if (!threads.has(rootId)) {
            threads.set(rootId, {
                root: state.posts.get(rootId),
                heat: 0,
                replyCount: 0,
                totalCarriers: new Set()
            });
        }

        const thread = threads.get(rootId);
        thread.replyCount++;
        post.carriers.forEach(c => thread.totalCarriers.add(c));
        thread.heat = thread.totalCarriers.size + thread.replyCount * 2;
    }

    const hottest = Array.from(threads.values())
        .filter(t => t.heat >= 10)
        .sort((a, b) => b.heat - a.heat)
        .slice(0, 10);

    if (hottest.length > 0) {
        const bonfireHtml = hottest.map(thread => `
      <div class="bonfire-item" onclick="scrollToPost('${thread.root.id}')">
        <span class="bonfire-heat">${thread.heat} üî•</span>
        <span class="thread-stats">${thread.replyCount} replies</span>
        <span class="bonfire-preview">${(thread.root.content.substring(0, 60))}...</span>
      </div>
    `).join('');
        bonfireContentEl.innerHTML = `<div class="bonfire-posts">${bonfireHtml}</div>`;
    } else {
        bonfireContentEl.innerHTML = '<div class="empty-state">No hot threads right now. Start a conversation!</div>';
    }
}
*/
 async function updateHotTopics() {
    const bonfireContentEl = document.getElementById('bonfire-content');
    if (!bonfireContentEl) return;

    bonfireContentEl.innerHTML = '<div class="empty-state">Looking for hot topics on the network...</div>';

    if (!state.dht) {
        bonfireContentEl.innerHTML = '<div class="empty-state">Connect to the network to find topics.</div>';
        return;
    }

    try {
        const data = await state.dht.get('hot-topics:v1');
        if (!data || !data.topics || data.topics.length === 0) {
            bonfireContentEl.innerHTML = '<div class="empty-state">No hot topics found yet. Check back soon!</div>';
            return;
        }

        const topicsHtml = data.topics.map(([topic, info]) => `
            <div class="bonfire-item" onclick="renderHotPostsForTopic('${topic}')">
                <span class="bonfire-heat">${Math.round(info.score)} üìà</span>
                <span class="bonfire-preview">${topic}</span>
            </div>
        `).join('');

        bonfireContentEl.innerHTML = `<div class="bonfire-posts">${topicsHtml}</div>`;
        document.getElementById('drawer-title').textContent = 'Hot Topics';

    } catch (e) {
        console.error("Failed to fetch hot topics:", e);
        bonfireContentEl.innerHTML = '<div class="empty-state">Error fetching topics from the network.</div>';
    }
}

function renderHotPostsForTopic(topic) {
    const bonfireContentEl = document.getElementById('bonfire-content');
    if (!bonfireContentEl) return;

    document.getElementById('drawer-title').textContent = `Bonfire: ${topic}`;

    const now = Date.now();
    const topicPosts = Array.from(state.posts.values()).filter(p => {
        const postTopics = state.scribe ? state.scribe.extractTopics(p.content) : [];
        return postTopics.includes(topic);
    });

    if (topicPosts.length === 0) {
        bonfireContentEl.innerHTML = `
            <div class="empty-state">
                No posts found for ${topic} yet.
                <button class="secondary-button" onclick="updateHotTopics()">Back to Topics</button>
            </div>`;
        return;
    }

    const scoredPosts = topicPosts.map(post => {
        const ageHours = (now - post.timestamp) / 3600000;
        const rating = post.getRatingSummary();
        // Hotness score: carrier count + reply count + weighted rating score, decayed by age.
        const score = (post.carriers.size + post.replies.size * 2 + rating.weightedTotal * 5) / Math.pow(ageHours + 1, 1.2);
        return { post, score };
    });

    const hottest = scoredPosts.sort((a, b) => b.score - a.score).slice(0, 20);

    const postsHtml = hottest.map(({ post, score }) => `
        <div class="bonfire-item" onclick="scrollToPost('${post.id}')">
            <span class="bonfire-heat">${Math.round(score)} üî•</span>
            <span class="bonfire-preview">${(post.content.substring(0, 60))}...</span>
        </div>
    `).join('');

    bonfireContentEl.innerHTML = `
        <div class="bonfire-header">
            <button class="secondary-button" onclick="updateHotTopics()">‚Üê Back to Topics</button>
        </div>
        <div class="bonfire-posts">${postsHtml}</div>
    `;
}
function scrollToPost(postId) {
    const el = document.getElementById(`post-${postId}`);
    if (el) {
        el.scrollIntoView({ behavior: 'smooth', block: 'center' });
        el.style.animation = 'pulse-border 2s ease-in-out';
        setTimeout(() => {
            el.style.animation = '';
        }, 2000);
    }
}

// --- PROFILE FUNCTIONS ---
async function openProfileForHandle(handle) {
  if (!handle) return;
  
  const modal = document.getElementById('profile-modal-overlay');
  modal.style.display = 'flex';
  
  const profileContent = document.getElementById('profile-content');
  profileContent.innerHTML = '<div class="spinner"></div><div>Loading profile...</div>';
  
  state.viewingProfile = handle;
  
  // If viewing our own profile, render immediately from local state.
  if (handle === state.myIdentity.handle) {
    renderProfile(state.myIdentity.profile);
    // We don't need to subscribe to our own profile updates via the network in this case.
    return;
  }
  
  // Step 1: Try DHT first for fast initial load
  const dhtKey = `profile:${handle}`;
  console.log(`[Profile] Attempting to get profile from DHT with key: ${dhtKey}`);
  
  try {
    // Step 2: DHT Get
    const dhtProfile = await state.dht.get(dhtKey);
    
    // Step 3: Conditional Render
    if (dhtProfile) {
      console.log(`[Profile] Found profile in DHT for ${handle}`);
      // The DHT stores the complete message object with signature
      window.handleProfileUpdate(dhtProfile, null);
      // Profile will be rendered by handleProfileUpdate if signature is valid
    } else {
      console.log(`[Profile] No profile found in DHT for ${handle}, waiting for Scribe`);
      // Profile not in DHT, continue showing loading state
      // Check local cache as fallback
      const cached = state.profileCache.get(handle);
      if (cached) {
        renderProfile(cached);
      }
    }
  } catch (error) {
    console.error(`[Profile] DHT lookup failed for ${handle}:`, error);
    // Continue with Scribe subscription even if DHT fails
  }
  
  // Step 4: Always subscribe to Scribe for live updates
  await window.subscribeToProfile(handle);
}

function closeProfile() {
  const modal = document.getElementById('profile-modal-overlay');
  modal.style.display = 'none';
  
  if (state.viewingProfile && state.viewingProfile !== state.myIdentity.handle) {
    window.unsubscribeFromProfile(state.viewingProfile);
  }
  state.viewingProfile = null;
}

async function renderProfile(profileData) {
  const content = document.getElementById('profile-content');
  const isOwnProfile = profileData.handle === state.myIdentity.handle;
  
  // Apply theme if set
  const modal = document.getElementById('profile-modal');
  if (profileData.theme && modal) {
    modal.style.setProperty('--profile-bg', profileData.theme.backgroundColor);
    modal.style.setProperty('--profile-text', profileData.theme.fontColor);
    modal.style.setProperty('--profile-accent', profileData.theme.accentColor);
  }
  
  let profilePicHtml = '<div class="profile-picture-placeholder">üë§</div>';
  if (profileData.profilePictureHash) {
    const imageData = await getImageStore().retrieveImage(profileData.profilePictureHash);
    if (imageData) {
      profilePicHtml = `<img src="${imageData}" class="profile-picture" alt="${profileData.handle}'s profile picture" />`;
    } else {
      // ADDED: Request image from peers if not found locally
      console.log(`[Profile] Profile picture not found locally, requesting from peers: ${profileData.profilePictureHash}`);
      const peers = Array.from(state.peers.values()).slice(0, 3);
      for (const peer of peers) {
        if (peer.wire && !peer.wire.destroyed) {
          sendPeerFunction(peer.wire, { type: "request_image", imageHash: profileData.profilePictureHash });
        }
      }
      
      // Set up a placeholder that can be updated when image arrives
      profilePicHtml = `<div id="profile-pic-${profileData.profilePictureHash}" class="profile-picture-placeholder">
        <div class="spinner" style="width: 20px; height: 20px;"></div>
      </div>`;
      
      // Set up a listener for when the image arrives
      const checkInterval = setInterval(async () => {
        const imageData = await getImageStore().retrieveImage(profileData.profilePictureHash);
        if (imageData) {
          clearInterval(checkInterval);
          const placeholder = document.getElementById(`profile-pic-${profileData.profilePictureHash}`);
          if (placeholder && state.viewingProfile === profileData.handle) {
            placeholder.outerHTML = `<img src="${imageData}" class="profile-picture" alt="${profileData.handle}'s profile picture" />`;
          }
        }
      }, 1000);
      
      // Clear interval after 30 seconds to prevent memory leak
      setTimeout(() => clearInterval(checkInterval), 30000);
    }
  }
  
  const userPosts = Array.from(state.posts.values())
    .filter(post => post.author === profileData.handle)
    .sort((a, b) => b.timestamp - a.timestamp)
    .slice(0, 20);
  
  const postsHtml = userPosts.length > 0 ? 
    userPosts.map(post => `
      <div class="profile-post-item" onclick="scrollToPost('${post.id}'); closeProfile();">
        <div class="profile-post-content">${sanitize(post.content.substring(0, 100))}${post.content.length > 100 ? '...' : ''}</div>
        <div class="profile-post-meta">
          <span>${new Date(post.timestamp).toLocaleDateString()}</span>
          <span>${post.carriers.size} üî•</span>
        </div>
      </div>
    `).join('') : 
    '<div class="empty-state">No posts yet</div>';
  
  content.innerHTML = `
    <div class="profile-header">
      <div class="profile-picture-container">
        ${profilePicHtml}
      </div>
      <div class="profile-info">
        <h2 class="profile-handle">${profileData.handle}</h2>
        <div class="profile-bio">${DOMPurify.sanitize(profileData.bio || 'No bio yet')}</div> <!-- FIXED: Sanitize profile bio -->
        ${isOwnProfile ? '<button class="edit-profile-button" onclick="openProfileEditor()">Edit Profile</button>' : ''}
      </div>
    </div>
    <div class="profile-posts">
      <h3>Recent Posts</h3>
      <div class="profile-posts-list">
        ${postsHtml}
      </div>
    </div>
  `;
}

window.openProfileEditor = async function() {
  const profile = state.myIdentity.profile || {
    handle: state.myIdentity.handle,
    bio: '',
    profilePictureHash: null,
    theme: {
      backgroundColor: '#000000',
      fontColor: '#ffffff',
      accentColor: '#ff1493'
    },
    updatedAt: Date.now()
  };
  
  const content = document.getElementById('profile-content');
  
  let currentPicHtml = '<div class="profile-picture-placeholder">üë§</div>';
  if (profile.profilePictureHash) {
    const imageData = await getImageStore().retrieveImage(profile.profilePictureHash);
    if (imageData) {
      currentPicHtml = `<img src="${imageData}" class="profile-picture" alt="Current profile picture" />`;
    }
  }
  
  content.innerHTML = `
    <div class="profile-editor">
      <h2>Edit Profile</h2>
      
      <div class="profile-editor-section">
        <label>Profile Picture</label>
        <div class="profile-picture-editor">
          <div class="current-picture">
            ${currentPicHtml}
          </div>
          <input type="file" id="profile-picture-input" accept="image/*" style="display:none;" />
          <button onclick="document.getElementById('profile-picture-input').click()">Change Picture</button>
        </div>
        <div id="profile-picture-preview" style="display:none;">
          <img id="profile-preview-img" />
          <button onclick="clearProfilePicture()">Remove</button>
        </div>
      </div>
      
      <div class="profile-editor-section">
        <label for="profile-bio">Bio (2500 chars max)</label>
        <textarea id="profile-bio" maxlength="2500" placeholder="Tell us about yourself...">${profile.bio || ''}</textarea>
        <span class="char-count"><span id="bio-char-count">${(profile.bio || '').length}</span>/2500</span>
      </div>
      
      <div class="profile-editor-section">
        <label>Theme Colors</label>
        <div class="color-inputs">
          <div class="color-input-group">
            <label for="bg-color">Background</label>
            <input type="color" id="bg-color" value="${profile.theme.backgroundColor}" />
          </div>
          <div class="color-input-group">
            <label for="text-color">Text</label>
            <input type="color" id="text-color" value="${profile.theme.fontColor}" />
          </div>
          <div class="color-input-group">
            <label for="accent-color">Accent</label>
            <input type="color" id="accent-color" value="${profile.theme.accentColor}" />
          </div>
        </div>
      </div>
      
      <div class="profile-editor-actions">
        <button onclick="saveProfile()" class="primary-button">Save Profile</button>
        <button onclick="cancelProfileEdit()">Cancel</button>
      </div>
    </div>
  `;
  
  document.getElementById('profile-bio').addEventListener('input', (e) => {
    document.getElementById('bio-char-count').textContent = e.target.value.length;
  });
  
  document.getElementById('profile-picture-input').addEventListener('change', async (e) => {
    const file = e.target.files[0];
    if (!file) return;
    
    try {
      const base64 = await handleImageUpload(file);
      const toxic = await window.isImageToxic(base64);
      if (toxic) {
        notify(`Image appears to contain ${toxic.toLowerCase()} content`);
        e.target.value = '';
        return;
      }
      
      document.getElementById('profile-preview-img').src = base64;
      document.getElementById('profile-picture-preview').style.display = 'block';
      document.getElementById('profile-picture-preview').dataset.imageData = base64;
    } catch (error) {
      notify(error.message);
    }
  });
};

window.clearProfilePicture = function() {
  document.getElementById('profile-picture-preview').style.display = 'none';
  document.getElementById('profile-picture-preview').dataset.imageData = '';
  document.getElementById('profile-picture-input').value = '';
};

window.saveProfile = async function() {
  const bio = document.getElementById('profile-bio').value.trim();
  const bgColor = document.getElementById('bg-color').value;
  const textColor = document.getElementById('text-color').value;
  const accentColor = document.getElementById('accent-color').value;
  
  if (bio && await window.isToxic(bio)) {
    notify('Your bio may contain inappropriate content. Please revise.');
    return;
  }
  
  let profilePictureHash = state.myIdentity.profile?.profilePictureHash || null;
  let profilePictureMeta = state.myIdentity.profile?.profilePictureMeta || null; // <-- Get existing meta

  const previewDiv = document.getElementById('profile-picture-preview');
  if (previewDiv.style.display !== 'none' && previewDiv.dataset.imageData) {
    const result = await getImageStore().storeImage(previewDiv.dataset.imageData);
    profilePictureHash = result.hash;
    // Get the new metadata from the image store ***
    profilePictureMeta = getImageStore().images.get(result.hash);
  }
  
  const updatedProfile = {
    handle: state.myIdentity.handle,
    bio: bio,
    profilePictureHash: profilePictureHash,
    profilePictureMeta: profilePictureMeta, // <-- ADD THIS
    theme: {
      backgroundColor: bgColor,
      fontColor: textColor,
      accentColor: accentColor
    },
    updatedAt: Date.now()
  };
  state.myIdentity.profile = updatedProfile;
  
  // This broadcast will now include the metadata
  await window.broadcastProfileUpdate(updatedProfile);
  renderProfile(updatedProfile);
  
  state.myIdentity.profile = updatedProfile;
  
  // This function is in main.js, but we call it from the window scope
  await window.broadcastProfileUpdate(updatedProfile);
  
  renderProfile(updatedProfile);

  // Update the profile section in control panel
  const picContainer = document.getElementById('user-profile-pic');
  if (picContainer && profilePictureHash) {
    const imageData = await getImageStore().retrieveImage(profilePictureHash);
    if (imageData) {
      picContainer.innerHTML = `<img src="${imageData}" alt="Your profile" />`;
    }
  }

  notify('Profile updated successfully!');
};

window.cancelProfileEdit = function() {
  renderProfile(state.myIdentity.profile);
};

// --- TOPIC AND FEED MANAGEMENT ---

async function subscribeToTopic() {
  const input = document.getElementById('topic-input');
  let topic = input.value.trim().toLowerCase();

  if (!topic) return;

  if (!topic.startsWith('#')) {
    topic = '#' + topic;
  }

  if (!/^#\w+$/.test(topic)) {
    notify('Invalid topic format. Use #alphanumeric');
    return;
  }

  if (state.subscribedTopics.has(topic)) {
    notify('Already subscribed to ' + topic);
    return;
  }

  state.subscribedTopics.add(topic);
  addTopicToUI(topic);
  updateTopicFilter();
  saveTopicSubscriptions();
  input.value = '';
  notify(`Subscribed to ${topic}`);

  if (state.scribe) {
    await state.scribe.subscribe(topic);
  } else {
    console.warn("Scribe not ready, but UI has been updated. Network will join topic upon initialization.");
  }
}

function addTopicToUI(topic) {
    const container = document.getElementById('subscribed-topics');
    const existing = container.querySelector(`[data-topic="${topic}"]`);
    if (existing) return;

    const tag = document.createElement('div');
    tag.className = 'topic-tag active';
    tag.dataset.topic = topic;
    tag.textContent = topic;
    tag.onclick = () => toggleTopic(topic);

    container.appendChild(tag);
}

async function toggleTopic(topic) {
    const tag = document.querySelector(`[data-topic="${topic}"]`);

    // PHASE 2: Allow unsubscribing from #general to enable true feed curation.
    if (state.subscribedTopics.has(topic)) {
        if (state.scribe) {
            state.scribe.unsubscribe(topic);
        }
        state.subscribedTopics.delete(topic);
        tag.classList.remove('active');
        notify(`Unsubscribed from ${topic}`);
    } else {
        if (state.scribe) {
            await state.scribe.subscribe(topic);
        }
        state.subscribedTopics.add(topic);
        tag.classList.add('active');
        notify(`Resubscribed to ${topic}`);
    }

    updateTopicFilter();
    saveTopicSubscriptions();
    applyTopicFilter();
}

function updateTopicFilter() {
    const select = document.getElementById('topic-filter');
    const currentValue = select.value;

    select.innerHTML = '<option value="">All Topics</option>';

    state.subscribedTopics.forEach(topic => {
        const option = document.createElement('option');
        option.value = topic;
        option.textContent = topic;
        select.appendChild(option);
    });

    if (currentValue && state.subscribedTopics.has(currentValue)) {
        select.value = currentValue;
    }
}

function filterByTopic() {
    const select = document.getElementById('topic-filter');
    state.topicFilter = select.value;
    applyTopicFilter();
}

function setFeedMode(mode) {
    state.feedMode = mode;
    document.querySelectorAll('.mode-button').forEach(btn => {
        btn.classList.remove('active');
    });
    event.target.classList.add('active');
    applyTopicFilter();
}

function applyTopicFilter() {
    const posts = document.querySelectorAll('.post');
    let visibleCount = 0;

    const currentFeedMode = state.feedMode;
    const topicDropdownFilter = state.topicFilter;

    posts.forEach(postEl => {
        const postId = postEl.id.replace('post-', '');
        const post = state.posts.get(postId);
        if (!post) return;

        const postTopics = state.scribe ? state.scribe.extractTopics(post.content) : [];
        let isVisible = false;

        if (currentFeedMode === 'all') {
            isVisible = true;
        } else {
            isVisible = postTopics.some(topic => state.subscribedTopics.has(topic));
        }

        if (isVisible && topicDropdownFilter) {
            isVisible = postTopics.includes(topicDropdownFilter);
        }

        postEl.style.display = isVisible ? 'block' : 'none';
        if (isVisible) {
            visibleCount++;
        }
    });

    let emptyMessage = document.getElementById('filter-empty-message');
    if (visibleCount === 0 && (currentFeedMode === 'topics' || topicDropdownFilter)) {
        if (!emptyMessage) {
            emptyMessage = document.createElement('div');
            emptyMessage.id = 'filter-empty-message';
            emptyMessage.className = 'empty-state';
            document.getElementById('posts').appendChild(emptyMessage);
        }
        emptyMessage.textContent = topicDropdownFilter ?
            `No posts in ${topicDropdownFilter}` :
            'No posts in your subscribed topics';
    } else if (emptyMessage) {
        emptyMessage.remove();
    }
}

function discoverAndFilterTopic(topic) {
  if (!state.subscribedTopics.has(topic)) {
    state.subscribedTopics.add(topic);
    if (state.scribe) {
      state.scribe.subscribe(topic);
    }
    addTopicToUI(topic);
    updateTopicFilter();
    saveTopicSubscriptions();
    notify(`Subscribed to ${topic}`);
  }
  filterToTopic(topic);
}

function filterToTopic(topic) {
  document.getElementById('topic-filter').value = topic;
  state.topicFilter = topic;
  applyTopicFilter();
}

function saveTopicSubscriptions() {
    localStorage.setItem('ember-topics', JSON.stringify(Array.from(state.subscribedTopics)));
}

function loadTopicSubscriptions() {
    const saved = localStorage.getItem('ember-topics');
    if (saved) {
        try {
            const topics = JSON.parse(saved);
            topics.forEach(topic => {
                state.subscribedTopics.add(topic);
                addTopicToUI(topic);
            });
        } catch (e) {
            console.error('Failed to load saved topics:', e);
        }
    }

    // *** If no topics were loaded from storage, add #general by default ***
    if (state.subscribedTopics.size === 0) {
        const defaultTopic = '#general';
        state.subscribedTopics.add(defaultTopic);
        addTopicToUI(defaultTopic);
        saveTopicSubscriptions(); // Save the default so it persists
        console.log('No saved topics found. Subscribed to #general by default.');
    }
}

function updateTopicStats() {
    if (!state.scribe) return;

    const stats = state.scribe.getStats();
    const statsEl = document.getElementById('topic-stats');

    if (stats.topics.length > 0) {
        const topicDetails = stats.topics.map(t =>
            `${t.topic}: ${t.children} children${t.hasParent ? ' (connected)' : ' (root)'}`
        ).join('<br>');

        statsEl.innerHTML = `
      <div>Connected to ${stats.subscribedTopics} topic trees</div>
      <div style="font-size: 11px; margin-top: 4px;">${topicDetails}</div>
    `;
    }
}

function showTopicSuggestions(partial) {
    const suggestions = [
        '#tech', '#news', '#art', '#music', '#politics', '#science',
        '#ember', '#random', '#help', '#dev', '#memes'
    ].filter(topic => topic.startsWith(partial));

    let suggestionsEl = document.getElementById('topic-suggestions');
    if (!suggestionsEl) {
        suggestionsEl = document.createElement('div');
        suggestionsEl.id = 'topic-suggestions';
        suggestionsEl.className = 'topic-suggestions';
        document.getElementById('compose').appendChild(suggestionsEl);
    }

    suggestionsEl.innerHTML = suggestions.map(topic =>
        `<div class="suggestion" onclick="completeTopicSuggestion('${topic}')">${topic}</div>`
    ).join('');

    suggestionsEl.style.display = suggestions.length > 0 ? 'block' : 'none';
}

function completeTopicSuggestion(topic) {
    const input = document.getElementById("post-input");
    const text = input.value;
    const words = text.split(/\s+/);
    words[words.length - 1] = topic + ' ';
    input.value = words.join(' ');
    input.focus();
    hideTopicSuggestions();
}

function hideTopicSuggestions() {
    const el = document.getElementById('topic-suggestions');
    if (el) el.style.display = 'none';
}


// --- IMAGE HANDLING ---

async function handleImageUpload(file) {
    return new Promise((resolve, reject) => {
        if (file.size > 50000 * 1024) { // 50000KB limit
            reject(new Error("Image too large. Max 50MB"));
            return;
        }

        const reader = new FileReader();
        reader.onload = (e) => {
            const img = new Image();
            img.onload = () => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');

                let width = img.width;
                let height = img.height;
                const maxDim = 800;

                if (width > maxDim || height > maxDim) {
                    if (width > height) {
                        height = (height / width) * maxDim;
                        width = maxDim;
                    } else {
                        width = (width / height) * maxDim;
                        height = maxDim;
                    }
                }

                canvas.width = width;
                canvas.height = height;
                ctx.drawImage(img, 0, 0, width, height);

                const base64 = canvas.toDataURL('image/jpeg', 0.7);
                resolve(base64);
            };
            img.src = e.target.result;
        };
        reader.readAsDataURL(file);
    });
}

async function handleImageSelect(input) {
    const file = input.files[0];
    if (!file) return;

    try {
        const base64 = await handleImageUpload(file);
        const toxic = await window.isImageToxic(base64); // Assumes isImageToxic is globally available or imported
        if (toxic) {
            notify(`Image appears to contain ${toxic.toLowerCase()} content`);
            input.value = '';
            return;
        }
        document.getElementById('preview-img').src = base64;
        document.getElementById('image-preview').style.display = 'block';
        document.getElementById('image-preview').dataset.imageData = base64;
    } catch (e) {
        notify(e.message);
    }
}

function removeImage() {
    document.getElementById('image-preview').style.display = 'none';
    document.getElementById('image-preview').dataset.imageData = '';
    document.getElementById('image-input').value = '';
}


// --- GLOBAL UI & SYSTEM FUNCTIONS ---

function updateStatus() {
    const pc = state.peers.size;
    document.getElementById("peer-count").textContent = pc;
    document.getElementById("post-count").textContent = state.posts.size;
    document.getElementById("status-dot").classList.toggle("connecting", pc === 0);

    const dhtStats = state.dht ? state.dht.getStats() : null;
    const hvStats = state.hyparview ? state.hyparview.getStats() : null;

    const protocolInfo = dhtStats ? `DHT: ${dhtStats.totalPeers} peers` : '';
    const overlayInfo = hvStats ? `HyParView: ${hvStats.activeView}/${hvStats.passiveView}` : '';

    let protocolEl = document.getElementById("protocol-status");
    if (!protocolEl) {
        protocolEl = document.createElement("span");
        protocolEl.id = "protocol-status";
        document.getElementById("status").appendChild(protocolEl);
    }
    protocolEl.innerHTML = `<br/>${protocolInfo} | ${overlayInfo}`;
    
    const privacyStatus = state.dandelion?.onionLayers > 0 ? "üîí Onion Routing" : "‚ö†Ô∏è Direct";

    let privacyEl = document.getElementById("privacy-status");
    if (!privacyEl) {
        privacyEl = document.createElement("span");
        privacyEl.id = "privacy-status";
        document.getElementById("status").appendChild(privacyEl);
    }
    privacyEl.innerHTML = `<br/>${privacyStatus} | Unified Bootstrap`;

    if (state.peers.size === 0 && state.posts.size === 0) {
      let firstNodeEl = document.getElementById("first-node-status");
      if (!firstNodeEl) {
        firstNodeEl = document.createElement("div");
        firstNodeEl.id = "first-node-status";
        firstNodeEl.style.cssText = "text-align: center; padding: 10px; color: #ffa500; font-size: 12px;";
        firstNodeEl.innerHTML = "üåü Running as first node - share the network to invite others!";
        document.getElementById("status").appendChild(firstNodeEl);
      }
    } else {
      const firstNodeEl = document.getElementById("first-node-status");
      if (firstNodeEl) firstNodeEl.remove();
    }

    clearTimeout(bonfireUpdateTimeout);
    bonfireUpdateTimeout = setTimeout(() => {
        if (currentDrawer === 'bonfire') {
            updateHotTopics();
        }
    }, 1000);
}

function updateAges() {
    document.querySelectorAll(".post .age").forEach(el => {
        const id = el.closest(".post").id.replace("post-", "");
        const p = state.posts.get(id);
        if (p) el.textContent = timeAgo(p.timestamp);
    });
}

function applyTheme(theme) {
    const button = document.getElementById('theme-toggle-button');
    if (theme === 'light') {
        document.body.classList.add('light-mode');
        if (button) button.textContent = 'üåô Dark Mode';
    } else {
        document.body.classList.remove('light-mode');
        if (button) button.textContent = '‚òÄÔ∏è Light Mode';
    }
}

function setupThemeToggle() {
    const themeToggleButton = document.getElementById('theme-toggle-button');
    if (!themeToggleButton) return;

    themeToggleButton.addEventListener('click', () => {
        document.body.classList.toggle('light-mode');
        if (document.body.classList.contains('light-mode')) {
            localStorage.setItem('ephemeral-theme', 'light');
            themeToggleButton.textContent = 'üåô Dark Mode';
        } else {
            localStorage.setItem('ephemeral-theme', 'dark');
            themeToggleButton.textContent = '‚òÄÔ∏è Light Mode';
        }
    });
}

function updateLoadingMessage(message) {
    const loadingEl = document.getElementById("loading");
    if (!loadingEl || loadingEl.style.display === "none") return;

    const statusDiv = loadingEl.querySelector('.loading-content div:nth-child(2)');
    if (statusDiv) {
        statusDiv.textContent = message;
    }
}

function showConnectScreen(loadedPostCount) {
    const isReturningUser = loadedPostCount > 0;

    document.getElementById("loading").innerHTML = `
    <div class="loading-content" style="max-width: 400px; text-align: center;">
      <h1 style="font-size: 48px; margin-bottom: 20px;">üî•</h1>
      <h2>Welcome to Ember</h2>
      <p style="color: #888; margin-bottom: 20px;">
        ${isReturningUser
        ? `Welcome back! ${loadedPostCount} embers still glow from your last visit.`
        : 'A decentralized network where posts live only as long as someone tends the flame.'
    }
      </p>
      <button onclick="connectToNetwork()" class="primary-button" style="font-size: 18px; padding: 12px 30px;">
        üî• Ignite Connection
      </button>
      <p style="font-size: 12px; color: #666; margin-top: 20px;">
        By connecting, you agree to participate in a public peer-to-peer network
      </p>
    </div>
  `;
}


async function handleReplyImageSelect(input, postId) {
    const file = input.files[0];
    if (!file) return;

    try {
        const base64 = await handleImageUpload(file);
        const toxic = await window.isImageToxic(base64);
        if (toxic) {
            notify(`Image appears to contain ${toxic.toLowerCase()} content`);
            input.value = '';
            return;
        }
        
        // Set the image preview for this specific reply
        const previewImg = document.getElementById(`reply-preview-img-${postId}`);
        const previewDiv = document.getElementById(`reply-image-preview-${postId}`);
        
        if (previewImg && previewDiv) {
            previewImg.src = base64;
            previewDiv.style.display = 'block';
            previewDiv.dataset.imageData = base64;
        }
    } catch (e) {
        notify(e.message);
    }
}

function removeReplyImage(postId) {
    const previewDiv = document.getElementById(`reply-image-preview-${postId}`);
    const imageInput = document.getElementById(`reply-image-input-${postId}`);
    
    if (previewDiv) {
        previewDiv.style.display = 'none';
        previewDiv.dataset.imageData = '';
    }
    
    if (imageInput) {
        imageInput.value = '';
    }
}

// DM UI Functions
window.currentDMConversation = null;

export function openDMPanel(handle) {
  currentDMRecipient = handle;
  
  // Mark messages as read
  const key = `ember-dms-${handle}`;
  try {
    const stored = localStorage.getItem(key);
    if (stored) {
      const messages = JSON.parse(stored);
      messages.forEach(msg => {
        if (msg.direction === 'received') {
          msg.read = true;
        }
      });
      localStorage.setItem(key, JSON.stringify(messages));
    }
  } catch (e) {
    console.error('Failed to mark messages as read:', e);
  }
  
  document.getElementById('dm-panel').style.display = 'flex';
  document.getElementById('dm-recipient').textContent = handle;
  loadDMConversation(handle);
  document.getElementById('dm-input').focus();
  
  // Update inbox to reflect read status
  updateDMInbox();
}

export function closeDMPanel() {
  document.getElementById('dm-panel').style.display = 'none';
  currentDMRecipient = null; // FIX: Was window.currentDMConversation
}

export function loadDMConversation(handle) {
  const messagesEl = document.getElementById('dm-messages');
  messagesEl.innerHTML = '';
  
  // Load from localStorage
  const key = `ember-dms-${handle}`;
  let conversation = [];
  
  try {
    const stored = localStorage.getItem(key);
    if (stored) {
      conversation = JSON.parse(stored);
    }
  } catch (e) {
    console.error('Failed to load DM history:', e);
  }
  
  // Render messages
  conversation.forEach(msg => {
    addMessageToConversation(handle, msg.message, msg.direction, msg.timestamp);
  });
  
  // Scroll to bottom
  messagesEl.scrollTop = messagesEl.scrollHeight;
}

export function addMessageToConversation(handle, messageText, direction, timestamp = Date.now()) {
  const messagesEl = document.getElementById('dm-messages');
  
  const msgEl = document.createElement('div');
  msgEl.className = `dm-message ${direction}`;
  msgEl.innerHTML = `
    <div class="dm-message-content">${sanitizeDM(messageText)}</div>
    <div class="dm-message-time">${new Date(timestamp).toLocaleTimeString()}</div>
  `;
  
  messagesEl.appendChild(msgEl);
  messagesEl.scrollTop = messagesEl.scrollHeight;
}

export async function sendDM() {
  const input = document.getElementById('dm-input');
  const message = input.value.trim();
  const recipient = currentDMRecipient;
  if (!message || !recipient) return;

  // The sendDirectMessage function now handles UI updates on its own.
  const success = await window.sendDirectMessage(recipient, message);

  if (success) {
    // Just clear the input field.
    input.value = '';
  }
}

// Add to ui.js
export function updateDMInbox() {
  const conversationsEl = document.getElementById('dm-conversations');
  if (!conversationsEl) return;
  
  // Get all conversations from localStorage
  const conversations = [];
  const keys = Object.keys(localStorage).filter(k => k.startsWith('ember-dms-'));
  
  keys.forEach(key => {
    const handle = key.replace('ember-dms-', '');
    try {
      const messages = JSON.parse(localStorage.getItem(key));
      if (messages && messages.length > 0) {
        const lastMessage = messages[messages.length - 1];
        conversations.push({
          handle,
          lastMessage,
          messages
        });
      }
    } catch (e) {
      console.error('Failed to parse DM conversation:', e);
    }
  });
  
  if (conversations.length === 0) {
    conversationsEl.innerHTML = `
      <div class="dm-empty-state">
        No messages yet. Send a DM to start a conversation!
      </div>
    `;
    return;
  }
  
  // Sort by most recent
  conversations.sort((a, b) => b.lastMessage.timestamp - a.lastMessage.timestamp);
  
  // Render conversations
  conversationsEl.innerHTML = conversations.map(conv => {
    const timeAgo = getTimeAgo(conv.lastMessage.timestamp);
    const preview = conv.lastMessage.message.substring(0, 50) + 
                   (conv.lastMessage.message.length > 50 ? '...' : '');
    const isUnread = conv.lastMessage.direction === 'received' && 
                     !conv.lastMessage.read;
    
    return `
      <div class="dm-conversation-item ${isUnread ? 'unread' : ''}" 
           onclick="openDMPanel('${conv.handle}')">
        <div class="dm-sender">
          <span class="ember-indicator">üî•</span>
          ${conv.handle}
        </div>
        <div class="dm-preview">${sanitizeDM(preview)}</div>
        <div class="dm-time">${timeAgo}</div>
      </div>
    `;
  }).join('');
}

function getTimeAgo(timestamp) {
  const seconds = Math.floor((Date.now() - timestamp) / 1000);
  if (seconds < 60) return 'just now';
  if (seconds < 3600) return `${Math.floor(seconds / 60)}m`;
  if (seconds < 86400) return `${Math.floor(seconds / 3600)}h`;
  return `${Math.floor(seconds / 86400)}d`;
}

export function storeDMLocallyAndUpdateUI(otherHandle, messageText, direction) {
  const key = `ember-dms-${otherHandle}`;
  let conversation = [];
  
  try {
    const stored = localStorage.getItem(key);
    if (stored) {
      conversation = JSON.parse(stored);
    }
  } catch (e) {
    console.error('Failed to load DM history:', e);
  }
  
  conversation.push({
    message: messageText,
    direction: direction,
    timestamp: Date.now(),
    read: direction === 'sent' || direction === 'queued',
    status: direction === 'queued' ? 'pending' : 'sent' 
  });
  
  if (conversation.length > 100) {
    conversation = conversation.slice(-100);
  }
  
  localStorage.setItem(key, JSON.stringify(conversation));
  updateDMInbox();
}


// Add drawer state
let currentDrawer = 'bonfire';

// Drawer switching function
window.switchDrawer =  function(drawerId) {
  // Don't switch if already active
  if (currentDrawer === drawerId) return;
  
  // Update tab states
  document.querySelectorAll('.drawer-tab').forEach(tab => {
    tab.classList.remove('active');
  });
  document.querySelector(`[data-drawer="${drawerId}"]`).classList.add('active');
  
  // Animate drawer transition
  const currentDrawerEl = document.getElementById(`${currentDrawer}-drawer`);
  const newDrawerEl = document.getElementById(`${drawerId}-drawer`);
  
  currentDrawerEl.classList.remove('active');
  currentDrawerEl.classList.add('slide-out-left');
  
  setTimeout(() => {
    currentDrawerEl.classList.remove('slide-out-left');
    newDrawerEl.classList.add('active', 'slide-in-right');
    
    setTimeout(() => {
      newDrawerEl.classList.remove('slide-in-right');
    }, 300);
  }, 150);
  
  // Update title
  const titles = {
    'bonfire': 'The Bonfire',
    'inbox': 'Message Embers',
    'network': 'Network Status'
  };
  document.getElementById('drawer-title').textContent = titles[drawerId];
  
  // Update current drawer
  currentDrawer = drawerId;
  
  // Trigger drawer-specific updates
  if (drawerId === 'network') {
    updateNetworkVisualization();
  } else if (drawerId === 'inbox') {
    updateDMInbox();
    markAllMessagesAsRead();
  } else if (drawerId === 'bonfire') {
    updateHotTopics();
  }
};



// Update unread badge
export function updateUnreadBadge() {
  let unreadCount = 0;
  
  const keys = Object.keys(localStorage).filter(k => k.startsWith('ember-dms-'));
  keys.forEach(key => {
    try {
      const messages = JSON.parse(localStorage.getItem(key));
      unreadCount += messages.filter(m => m.direction === 'received' && !m.read).length;
    } catch (e) {
      console.error('Failed to count unread messages:', e);
    }
  });
  
  const badge = document.getElementById('inbox-unread-badge');
  if (badge) {
    if (unreadCount > 0) {
      badge.textContent = unreadCount > 99 ? '99+' : unreadCount;
      badge.style.display = 'block';
      
      // Animate the tab if not active
      if (currentDrawer !== 'inbox') {
        const inboxTab = document.querySelector('[data-drawer="inbox"]');
        inboxTab.classList.add('has-unread');
      }
    } else {
      badge.style.display = 'none';
    }
  }
}

function markAllMessagesAsRead() {
  const keys = Object.keys(localStorage).filter(k => k.startsWith('ember-dms-'));
  keys.forEach(key => {
    try {
      const stored = localStorage.getItem(key);
      if (stored) {
        const messages = JSON.parse(stored);
        let changed = false;
        messages.forEach(msg => {
          if (msg.direction === 'received' && !msg.read) {
            msg.read = true;
            changed = true;
          }
        });

        // Only write back to localStorage if a message was actually marked as read
        if (changed) {
            localStorage.setItem(key, JSON.stringify(messages));
        }
      }
    } catch (e) {
      console.error('Failed to mark messages as read:', e);
    }
  });

  // After marking all as read, update the badge to show 0
  updateUnreadBadge();
  
  // Also remove the pulsing animation from the inbox tab
  const inboxTab = document.querySelector('[data-drawer="inbox"]');
  if (inboxTab) {
      inboxTab.classList.remove('has-unread');
  }
}
// Network visualization
function updateNetworkVisualization() {
  const canvas = document.getElementById('network-canvas');
  if (!canvas) return;
  
  const ctx = canvas.getContext('2d');
  const rect = canvas.getBoundingClientRect();
  canvas.width = rect.width;
  canvas.height = 200;
  
  // Clear canvas
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  // Draw network graph (simplified visualization)
  const centerX = canvas.width / 2;
  const centerY = canvas.height / 2;
  
  // Draw self node
  ctx.beginPath();
  ctx.arc(centerX, centerY, 10, 0, Math.PI * 2);
  ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--text-accent');
  ctx.fill();
  
  // Draw peer nodes
  const peers = Array.from(state.peers.values());
  const angleStep = (Math.PI * 2) / Math.max(peers.length, 1);
  
  peers.forEach((peer, index) => {
    const angle = angleStep * index;
    const x = centerX + Math.cos(angle) * 80;
    const y = centerY + Math.sin(angle) * 80;
    
    // Draw connection line
    ctx.beginPath();
    ctx.moveTo(centerX, centerY);
    ctx.lineTo(x, y);
    ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--border-color-accent');
    ctx.globalAlpha = 0.3;
    ctx.stroke();
    ctx.globalAlpha = 1;
    
    // Draw peer node
    ctx.beginPath();
    ctx.arc(x, y, 6, 0, Math.PI * 2);
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--text-secondary');
    ctx.fill();
  });
  
  // Update metrics
  updateNetworkMetrics();
}

function updateNetworkMetrics() {
  const metrics = document.getElementById('network-metrics');
  if (!metrics) return;
  
  const dhtStats = state.dht ? state.dht.getStats() : null;
  const hvStats = state.hyparview ? state.hyparview.getStats() : null;
  
  metrics.innerHTML = `
    <div class="metric-item">
      <span class="metric-label">Total Peers</span>
      <span class="metric-value">${state.peers.size}</span>
    </div>
    <div class="metric-item">
      <span class="metric-label">DHT Nodes</span>
      <span class="metric-value">${dhtStats?.totalPeers || 0}</span>
    </div>
    <div class="metric-item">
      <span class="metric-label">Active View</span>
      <span class="metric-value">${hvStats?.activeView || 0}/${hvStats?.activeCapacity?.split('/')[1] || 0}</span>
    </div>
    <div class="metric-item">
      <span class="metric-label">Messages Seen</span>
      <span class="metric-value">${state.seenMessages.timestamps?.size || 0}</span>
    </div>
    <div class="metric-item">
      <span class="metric-label">Storage Used</span>
      <span class="metric-value">${dhtStats?.storageSize || 0} keys</span>
    </div>
  `;
}

// Add CSS class for unread animation
const style = document.createElement('style');
style.textContent = `
  .drawer-tab.has-unread {
    animation: unread-pulse 2s ease-in-out infinite;
  }
  
  @keyframes unread-pulse {
    0%, 100% { 
      border-color: var(--border-color-light);
    }
    50% { 
      border-color: var(--text-accent-hot);
      box-shadow: 0 0 10px var(--shadow-color-accent);
    }
  }
`;
document.head.appendChild(style);


// Make functions available globally
window.openDMPanel = openDMPanel;
window.closeDMPanel = closeDMPanel;
window.sendDM = sendDM;
window.renderHotPostsForTopic = renderHotPostsForTopic;


// --- EXPORTS ---
export {
    animationObserver,
    bonfireUpdateTimeout,
    showAllShards,
    notify,
    renderPost,
    updateInner,
    refreshPost,
    dropPost,
    getHeatLevel,
    getThreadSize,
    toggleReplyForm,
    toggleThread,
    updateBonfire,
    scrollToPost,
    subscribeToTopic,
    addTopicToUI,
    toggleTopic,
    updateTopicFilter,
    filterByTopic,
    setFeedMode,
    applyTopicFilter,
    discoverAndFilterTopic,
    filterToTopic,
    saveTopicSubscriptions,
    loadTopicSubscriptions,
    updateTopicStats,
    showTopicSuggestions,
    completeTopicSuggestion,
    hideTopicSuggestions,
    handleImageUpload,
    handleImageSelect,
    removeImage,
    updateStatus,
    updateAges,
    applyTheme,
    setupThemeToggle,
    updateLoadingMessage,
    showConnectScreen,
    handleReplyImageSelect, 
    removeReplyImage,
    openProfileForHandle,
    renderProfile,
    closeProfile,
    updateHotTopics
};


========================================
--- FILE: utils.js
========================================
import DOMPurify from 'dompurify'; 
import { CONFIG } from './config.js';

export class BloomFilter {
  constructor(size = 100000, numHashes = 4) {
    this.size = size;
    this.numHashes = numHashes;
    this.bits = new Uint8Array(Math.ceil(size / 8));
  }
  
  add(item) {
    for (let i = 0; i < this.numHashes; i++) {
      const hash = this.hash(item + i) % this.size;
      const byte = Math.floor(hash / 8);
      const bit = hash % 8;
      this.bits[byte] |= (1 << bit);
    }
  }
  
  has(item) {
    for (let i = 0; i < this.numHashes; i++) {
      const hash = this.hash(item + i) % this.size;
      const byte = Math.floor(hash / 8);
      const bit = hash % 8;
      if ((this.bits[byte] & (1 << bit)) === 0) return false;
    }
    return true;
  }
  
  hash(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      hash = ((hash << 5) - hash) + str.charCodeAt(i);
      hash = hash & hash;
    }
    return Math.abs(hash);
  }
}

export class HierarchicalBloomFilter {
  constructor() {
    this.levels = [
      { filter: new BloomFilter(10000, 3), maxAge: 3600000, name: 'recent' },
      { filter: new BloomFilter(50000, 4), maxAge: 86400000, name: 'daily' },
      { filter: new BloomFilter(100000, 5), maxAge: 604800000, name: 'weekly' }
    ];
    this.timestamps = new Map();
    this.maxTimestamps = 50000; // ADDED: Maximum timestamps to store
  }
  
  add(item) {
    const now = Date.now();
    
    // Add to all levels
    this.levels.forEach(level => {
      level.filter.add(item);
    });
    
    // Track timestamp with size limit
    this.timestamps.set(item, now);
    
    // Force cleanup if over limit
    if (this.timestamps.size > this.maxTimestamps) {
      this.cleanup();
    }
  }
  
  has(item) {
    const timestamp = this.timestamps.get(item);
    if (!timestamp) return false;
    
    const age = Date.now() - timestamp;
    
    // Check appropriate level based on age
    for (const level of this.levels) {
      if (age <= level.maxAge) {
        return level.filter.has(item);
      }
    }
    
    // Item is too old, remove it
    this.timestamps.delete(item);
    return false;
  }
  
  cleanup() {
    const now = Date.now();
    const maxAge = this.levels[this.levels.length - 1].maxAge;
    
    const beforeSize = this.timestamps.size;
    
    // Remove old timestamps
    const toDelete = [];
    for (const [item, timestamp] of this.timestamps) {
      if (now - timestamp > maxAge) {
        toDelete.push(item);
      }
    }
    
    toDelete.forEach(item => this.timestamps.delete(item));
    
    // If still too many, remove oldest
    if (this.timestamps.size > this.maxTimestamps * 0.8) {
      const sorted = Array.from(this.timestamps.entries())
        .sort((a, b) => a[1] - b[1]);
      
      const toRemove = sorted.slice(0, sorted.length - Math.floor(this.maxTimestamps * 0.7));
      toRemove.forEach(([item]) => this.timestamps.delete(item));
    }
    
    // Reset bloom filters if we removed many items
    if (this.timestamps.size < beforeSize / 2) {
      console.log(`Resetting bloom filters (cleaned ${beforeSize - this.timestamps.size} items)`);
      const remainingItems = Array.from(this.timestamps.keys());
      this.levels.forEach(level => {
        level.filter = new BloomFilter(level.filter.size, level.filter.numHashes);
      });
      remainingItems.forEach(item => {
        this.levels.forEach(level => level.filter.add(item));
      });
    }
  }

  reset() {
    this.levels.forEach(level => {
      level.filter = new BloomFilter(level.filter.size, level.filter.numHashes);
    });
    this.timestamps.clear();
  }
  
  getStats() {
    return {
      totalItems: this.timestamps.size,
      levels: this.levels.map(level => ({
        name: level.name,
        size: level.filter.bits.length * 8,
        maxAge: level.maxAge
      }))
    };
  }
}


export const wait = ms => new Promise(r => setTimeout(r, ms));
    
export async function waitForWebTorrent() {
      if (CONFIG.LOCAL_MODE) return;
      const t0 = performance.now();
      while (typeof WebTorrent === "undefined") {
        if (performance.now() - t0 > 10_000) throw new Error("WebTorrent failed to load in 10 s");
        await wait(100);
      }
    }


export const generateId = () => {
  const bytes = new Uint8Array(16); // 128 bits of randomness
  crypto.getRandomValues(bytes);
  return Array.from(bytes)
    .map(b => b.toString(16).padStart(2, '0'))
    .join('');
};
export function sanitize(content) {
  // 1. Trim early
  if (content.length > CONFIG.MAX_POST_SIZE) {
    content = content.slice(0, CONFIG.MAX_POST_SIZE);
  }

  // 2. Use DOMPurify when available with SAFE settings
  if (DOMPurify) {
    const purified = DOMPurify.sanitize(content, {
      ALLOWED_TAGS: ['b', 'i', 'em', 'strong', 'a', 'code', 'br'],
      ALLOWED_ATTR: ['href', 'target', 'rel'],
      ALLOW_URI_WITHOUT_PROTOCOL: false,  // CHANGED: Disallow protocol-less URLs
      ALLOWED_URI_REGEXP: /^https?:\/\//,  // ADDED: Only allow http/https
      RETURN_TRUSTED_TYPE: false
    });

    // 3. Force safe link behaviour
    DOMPurify.addHook('afterSanitizeAttributes', node => {
      if (node.tagName === 'A' && node.hasAttribute('href')) {
        node.setAttribute('target', '_blank');
        node.setAttribute('rel', 'noopener noreferrer');
        // Additional check for javascript: URLs
        if (node.getAttribute('href').toLowerCase().startsWith('javascript:')) {
          node.removeAttribute('href');
        }
      }
    });

    return purified;
  }

  // 4. Fallback: plain-text escape
  const d = document.createElement('div');
  d.textContent = content;
  return d.innerHTML;
}

export function sanitizeDM(content) {
  // Force text-only for DMs
  const d = document.createElement('div');
  d.textContent = content;
  return d.innerHTML;
}


export function timeAgo(ts) {
      const s = ~~((Date.now() - ts) / 1000);
      if (s < 5) return "just now";
      if (s < 60) return `${s}s ago`;
      const m = ~~(s / 60);
      if (m < 60) return `${m}m ago`;
      const h = ~~(m / 60);
      if (h < 24) return `${h}h ago`;
      return `${~~(h / 24)}d ago`;
    }
    
export function notify(msg, dur = 3000) {
      const n = document.createElement("div");
      n.className = "notification";
      n.textContent = msg;
      document.body.appendChild(n);
      setTimeout(() => {
        n.style.animationDirection = "reverse";
        setTimeout(() => n.remove(), 300);
      }, dur);
    }


export function arrayBufferToBase64(buffer) {
    if (!buffer) return null;
    if (typeof buffer === 'string') return buffer; // Already base64
    
    const bytes = new Uint8Array(buffer);
    let binary = '';
    for (let i = 0; i < bytes.byteLength; i++) {
        binary += String.fromCharCode(bytes[i]);
    }
    return btoa(binary);
}

export const base64ToArrayBuffer = (base64) => {
    const binary = atob(base64);
    const bytes = new Uint8Array(binary.length);
    for (let i = 0; i < binary.length; i++) {
        bytes[i] = binary.charCodeAt(i);
    }
    return bytes;
};
export function normalizePeerId(id) {
  if (!id) return null;

  if (typeof id === 'string') {
    return id;
  } else if (id instanceof Uint8Array) {
    return Array.from(id).map(b => b.toString(16).padStart(2, '0')).join('');
  } else if (id && id.constructor && id.constructor.name === 'Buffer') {
    const uint8 = new Uint8Array(id);
    return Array.from(uint8).map(b => b.toString(16).padStart(2, '0')).join('');
  } else if (id && (id.type === 'Buffer' || id.data)) {
    const uint8 = new Uint8Array(id.data || id);
    return Array.from(uint8).map(b => b.toString(16).padStart(2, '0')).join('');
  } else if (ArrayBuffer.isView(id)) {
    const uint8 = new Uint8Array(id.buffer, id.byteOffset, id.byteLength);
    return Array.from(uint8).map(b => b.toString(16).padStart(2, '0')).join('');
  }

  console.error('Unknown peer ID type:', typeof id, id);
  return null;
}

export function hexToUint8Array (hex) {
  if (hex.length % 2) throw new Error('hex length must be even');
  const bytes = new Uint8Array(hex.length / 2);
  for (let i = 0; i < bytes.length; i++) {
    bytes[i] = parseInt(hex.substr(i * 2, 2), 16);
  }
  return bytes;
}

export const JSONStringifyWithBigInt = (obj) => {
    return JSON.stringify(obj, (key, value) => {
        if (typeof value === 'bigint') {
            return value.toString() + 'n'; // Add 'n' suffix to identify BigInts
        }
        return value;
    });
};

export const JSONParseWithBigInt = (str) => {
    return JSON.parse(str, (key, value) => {
        // More strict check for BigInt format
        if (typeof value === 'string' && /^\d+n$/.test(value)) {
            // Additional validation: check if the number part is valid
            const numPart = value.slice(0, -1);
            if (/^\d+$/.test(numPart) && numPart.length < 100) { // Limit BigInt size
                try {
                    return BigInt(numPart);
                } catch (e) {
                    // If BigInt creation fails, return original string
                    return value;
                }
            }
        }
        return value;
    });
};
export const isReply = (post) => post && post.parentId;


========================================
--- FILE: vdf-worker.js
========================================
import init, { VDFComputer } from './wasm/vdf_wasm.js';

// This worker initializes its own instance of the WASM module.
let computer = null;

self.addEventListener('message', async (e) => {
    const { input, iterations, jobId } = e.data;

    try {
        // Initialize WASM on the first call
        if (!computer) {
            await init(new URL('./wasm/vdf_wasm_bg.wasm', import.meta.url));
            computer = new VDFComputer();
        }

        // Define the progress callback which sends messages back to the main thread
        const onProgress = (percentage) => {
            self.postMessage({
                type: 'progress',
                jobId: jobId,
                progress: percentage
            });
        };

        // Run the computation
        const wasmProof = await computer.compute_proof(
            input,
            BigInt(iterations),
            onProgress
        );

        // IMPORTANT: Convert the WASM proof object to a plain JS object
        // This is necessary because WASM objects don't serialize properly with postMessage
        const proof = {
            y: wasmProof.y,
            pi: wasmProof.pi,
            l: wasmProof.l,
            r: wasmProof.r,
            iterations: iterations // Use the original iterations value we passed in
        };

        // Send the serialized proof back
        self.postMessage({
            type: 'complete',
            jobId: jobId,
            proof: proof
        });

    } catch (error) {
        // Report any errors
        self.postMessage({
            type: 'error',
            jobId: jobId,
            // This is the corrected line for this file
            error: String(error)
        });
    }
});


========================================
--- FILE: vdf-wrapper.js
========================================
// File: vdf-wrapper.js
import init, { VDFComputer, VDFProof } from './wasm/vdf_wasm.js';

class WasmVDF {
    constructor() {

            // Browser environment - use Web Worker
            this.worker = new Worker(new URL('./vdf-worker.js', import.meta.url), { type: 'module' });


        
        
        // This map holds the promise handlers for active jobs
        this.pendingJobs = new Map();
        this.VDFProof = null;

        // Set up message handler for browser
            this.worker.onmessage = (event) => {
                this.handleWorkerMessage(event.data);
            };
        
    }
    
    handleWorkerMessage(data) {
        const { type, jobId, progress, proof, error } = data;

        // Find the job this message belongs to
        const job = this.pendingJobs.get(jobId);
        if (!job) return;

        switch (type) {
            case 'progress':
                // If a progress callback was provided, call it
                if (job.onProgress) {
                    job.onProgress(progress);
                }
                break;
            case 'complete':
                // The job succeeded, resolve the promise with the proof
                job.resolve(proof);
                this.pendingJobs.delete(jobId);
                break;
            case 'error':
                // The job failed, reject the promise with the error
                job.reject(new Error(error));
                this.pendingJobs.delete(jobId);
                break;
        }
    }
    
    async verifyVDFProof(input, proofData) {
        if (!this.computer || !this.VDFProof) {
            throw new Error("WASM VDF not initialized for verification.");
        }
        // Internally create the proof object from the raw data
        const proofObject = new this.VDFProof(
            proofData.y,
            proofData.pi,
            proofData.l,
            proofData.r,
            BigInt(proofData.iterations)
        );
        // Call the underlying WASM verification function
        return await this.computer.verify_proof(input, proofObject);
    }
    
    async initialize() {
        if (this.computer) return; // Only initialize once
        

            // Browser environment
            await init(new URL('./wasm/vdf_wasm_bg.wasm', import.meta.url));
        
        
        this.computer = new VDFComputer();
        this.VDFProof = VDFProof;
        console.log('Main thread WASM VDF initialized for verification tasks.');
    }
    
    // This is now the primary public method. It returns a promise.
    async computeVDFProofWithTimeout(input, iterations, onProgressCallback, timeoutMs = 35000) {

        
        // Browser environment - use worker
        return new Promise((resolve, reject) => {
            const jobId = Math.random().toString(36).substr(2, 9);

            const timeout = setTimeout(() => {
                this.pendingJobs.delete(jobId);
                reject(new Error('VDF computation timed out'));
            }, timeoutMs);
            
            // Store the promise handlers and the progress callback
            this.pendingJobs.set(jobId, {
                resolve: (proof) => {
                    clearTimeout(timeout);
                    resolve(proof);
                },
                reject: (error) => {
                    clearTimeout(timeout);
                    reject(error);
                },
                onProgress: onProgressCallback
            });

            // Send the job to the worker
            this.worker.postMessage({
                input,
                iterations: iterations.toString(),
                jobId
            });
        });
    }
}

// Export a single instance of the wrapper
const wasmVDF = new WasmVDF();
export default wasmVDF;


========================================
--- FILE: verification-queue.js
========================================
export class VerificationQueue {
    constructor() {
        this.workers = [];
        this.queue = [];
        this.processing = new Map();
        this.results = new Map();
        this.callbacks = new Map();
        
    }
    
    handleError(id, error) {
    console.error(`Processing failed for item ${id}:`, error);
    const processing = this.processing.get(id);
    if (processing) {
        this.processing.delete(id);
    }
}
    
async init() {
    const workerCount = 4;
    console.log(`Initializing ${workerCount} verification workers...`);

    for (let i = 0; i < workerCount; i++) {
        await new Promise(async (resolve, reject) => {
            let worker;

                worker = new Worker(new URL('./verify-worker.js', import.meta.url), { type: 'module' });
                worker.addEventListener('error', (error) => {
                    console.error(`Worker ${i} failed to initialize:`, error);
                    reject(error);
                }, { once: true });
                worker.addEventListener('message', (event) => {
                    this.handleWorkerMessage(event.data, i);
                });
            

            this.workers.push({
                id: i,
                worker,
                busy: false,
                currentBatch: null
            });
            console.log(`Worker ${i} created.`);
            resolve();
        });
    }
    console.log('All workers have been initialized.');
}


    async initializeWorkers(count) {
        console.log(`Initializing ${count} workers sequentially...`);
        for (let i = 0; i < count; i++) {
            // Use a Promise to wait for the worker to be successfully created or fail
            await new Promise((resolve, reject) => {
                const worker = new Worker('verify-worker.js', { type: 'module' });

                const successListener = () => {
                    // To confirm success, we can listen for the first message
                    // or just resolve on the assumption it worked if no error fired.
                    // For simplicity, we'll resolve immediately after setup.
                    console.log(`Worker ${i} initialized successfully.`);
                    this.workers.push({
                        id: i,
                        worker,
                        busy: false,
                        currentBatch: null
                    });
                    resolve();
                };

                const errorListener = (error) => {
                    console.error(`Worker ${i} failed to initialize:`, error);
                    // We'll reject, but you could add more robust retry logic here
                    reject(error); 
                };
                
                // The 'error' event fires on failure.
                worker.addEventListener('error', errorListener, { once: true });
                
                // We can assume success if the error event doesn't fire right away.
                // Setting up other listeners:
                worker.addEventListener('message', (e) => {
                    this.handleWorkerMessage(e.data, i);
                });

                // A small timeout to allow the error event to fire if there's an immediate issue.
                setTimeout(() => {
                    worker.removeEventListener('error', errorListener);
                    successListener();
                }, 100); // Wait 100ms
            });
        }
        console.log('All workers initialized.');
    }
    
    handleWorkerMessage(message, workerId) {
        const worker = this.workers[workerId];
        
        switch (message.type) {
            case 'batch_complete':
                this.processBatchResults(message.id, message.results);
                worker.busy = false;
                worker.currentBatch = null;
                this.processNext();
                break;
                
            case 'single_complete':
                this.processSingleResult(message.id, message.result);
                worker.busy = false;
                this.processNext();
                break;
                
            case 'progress':
                this.updateProgress(message);
                break;
                
            case 'error':
                console.error('Worker error:', message.error);
                this.handleError(message.id, message.error);
                worker.busy = false;
                this.processNext();
                break;
        }
    }
    
    async addBatch(posts, priority = 'normal', callback = null) {
        const batchId = crypto.randomUUID();
        
        // Split into chunks for workers
        const chunkSize = Math.ceil(posts.length / this.workers.length);
        const chunks = [];
        
        for (let i = 0; i < posts.length; i += chunkSize) {
            chunks.push(posts.slice(i, i + chunkSize));
        }
        
        if (callback) {
            this.callbacks.set(batchId, callback);
        }
        
        // Add chunks to queue with priority
        chunks.forEach((chunk, index) => {
            const item = {
                id: `${batchId}-${index}`,
                batchId,
                type: 'verify_batch',
                data: { posts: chunk },
                priority,
                addedAt: Date.now()
            };
            
            if (priority === 'high') {
                this.queue.unshift(item);
            } else {
                this.queue.push(item);
            }
        });
        
        this.processNext();
        return batchId;
    }
    
    async verifySingle(post, priority = 'high') {
        return new Promise((resolve) => {
            const id = crypto.randomUUID();
            
            const item = {
                id,
                type: 'verify_single',
                data: { post },
                priority,
                addedAt: Date.now(),
                resolve
            };
            
            if (priority === 'high') {
                this.queue.unshift(item);
            } else {
                this.queue.push(item);
            }
            
            this.processNext();
        });
    }
    
    processNext() {
        // Find available workers
        const availableWorkers = this.workers.filter(w => !w.busy);
        
        if (availableWorkers.length === 0 || this.queue.length === 0) {
            return;
        }
        
        // Assign work to available workers
        while (availableWorkers.length > 0 && this.queue.length > 0) {
            const worker = availableWorkers.shift();
            const item = this.queue.shift();
            
            worker.busy = true;
            worker.currentBatch = item.id;
            
            this.processing.set(item.id, {
                workerId: worker.id,
                item,
                startTime: Date.now()
            });
            
            worker.worker.postMessage({
                type: item.type,
                data: item.data,
                id: item.id
            });
        }
    }
    
    processBatchResults(id, results) {
        const processing = this.processing.get(id);
        if (!processing) return;
        
        const { item } = processing;
        this.processing.delete(id);
        
        // Clean old results if too many
        if (this.results.size > 10000) {
            const entries = Array.from(this.results.entries());
            entries.slice(0, 5000).forEach(([id]) => this.results.delete(id));
        }
        
        // Check if entire batch is complete
        const batchId = item.batchId;
        if (batchId) {
            const allComplete = !Array.from(this.processing.values())
                .some(p => p.item.batchId === batchId);
            
            if (allComplete) {
                const callback = this.callbacks.get(batchId);
                if (callback) {
                    const batchResults = results;
                    callback(batchResults);
                    this.callbacks.delete(batchId);
                }
            }
        }
    }
    
    processSingleResult(id, result) {
        const processing = this.processing.get(id);
        if (!processing) return;
        
        const { item } = processing;
        this.processing.delete(id);
        
        this.results.set(result.id, result);
        
        if (item.resolve) {
            item.resolve(result);
        }
    }
    
    reassignWorkerTasks(workerId) {
        const worker = this.workers[workerId];
        
        // Find tasks assigned to failed worker
        const tasksToReassign = Array.from(this.processing.entries())
            .filter(([id, info]) => info.workerId === workerId)
            .map(([id, info]) => info.item);
        
        // Re-add to front of queue
        tasksToReassign.forEach(task => {
            this.processing.delete(task.id);
            this.queue.unshift(task);
        });
        
        // Restart worker
        worker.worker.terminate();
        worker.worker = new Worker('verify-worker.js', { type: 'module' });
        worker.busy = false;
        
        // Re-setup event listeners
        worker.worker.addEventListener('message', (e) => {
            this.handleWorkerMessage(e.data, workerId);
        });
        
        this.processNext();
    }
    
    updateProgress(message) {
        // Emit progress event
        window.dispatchEvent(new CustomEvent('verification-progress', {
            detail: {
                completed: message.completed,
                total: message.total
            }
        }));
    }
    
    getResult(postId) {
        return this.results.get(postId);
    }
    
    clearResults() {
        this.results.clear();
    }
    
    getStats() {
        return {
            queueLength: this.queue.length,
            processing: this.processing.size,
            results: this.results.size,
            workers: this.workers.map(w => ({
                id: w.id,
                busy: w.busy
            }))
        };
    }
}




========================================
--- FILE: verify-worker.js
========================================
import nacl from 'tweetnacl';
// Import the WASM module
import init, { VDFComputer, VDFProof } from './wasm/vdf_wasm.js';

let computer = null;
let initialized = false;

// Initialize WASM once
async function initializeWasm() {
    if (!initialized) {
        await init(new URL('./wasm/vdf_wasm_bg.wasm', import.meta.url));

        computer = new VDFComputer();
        initialized = true;
        console.log('[Worker] WASM VDF initialized');
    }
}


/**
 * Converts a Base64 string to a Uint8Array 
 */
function base64ToArrayBuffer(base64) {
    const binary = atob(base64);
    const bytes = new Uint8Array(binary.length);
    for (let i = 0; i < binary.length; i++) {
        bytes[i] = binary.charCodeAt(i);
    }
    return bytes;
}
/**
 * Converts a Uint8Array into a Base64 string.
 */
function arrayBufferToBase64(buffer) {
    let binary = '';
    // The post object arrives via structured cloning, so buffer might be a plain object
    const bytes = new Uint8Array(Object.values(buffer));
    const len = bytes.byteLength;
    for (let i = 0; i < len; i++) {
        binary += String.fromCharCode(bytes[i]);
    }
    return btoa(binary);
}

function verifySignature(post) {
    console.log(`[SIG_VERIFY] --- Starting verification for post ${post.id} ---`);
    console.log('[SIG_VERIFY] Post fields:', Object.keys(post));
    
    if (!post.signature || !post.authorPublicKey) {
        console.error(`[SIG_VERIFY] ‚ùå FAILED: Post ${post.id} is missing signature or public key.`);
        return false;
    }
    console.log(`[SIG_VERIFY] Post has signature and public key. Proceeding...`);
    
    try {
        const publicKeyBytes = new Uint8Array(Object.values(post.authorPublicKey));
        const signatureBytes = new Uint8Array(Object.values(post.signature));

        console.log(`[SIG_VERIFY] Correctly handled keys and signature as byte arrays.`);
        console.log(`[SIG_VERIFY]   > Public Key length: ${publicKeyBytes.length} bytes`);
        console.log(`[SIG_VERIFY]   > Signature length: ${signatureBytes.length} bytes`);
        
        // For reconstructing the message, we must convert the public key
        // back to the Base64 string that was used when the message was originally signed.
        const authorPublicKeyBase64 = arrayBufferToBase64(post.authorPublicKey);

        // Reconstruct the exact data object that was signed.
        // This includes the VDF fields, ensuring they are covered by the signature check.
        const signableData = {
            id: post.id,
            content: post.content,
            timestamp: post.timestamp,
            parentId: post.parentId,
            imageHash: post.imageHash,
            authorPublicKey: authorPublicKeyBase64, // Use the Base64 string here
            vdfInput: post.vdfInput, // Add the VDF input for verification
            vdfProof: post.vdfProof ? { // Re-serialize the proof for a perfect match
                y: post.vdfProof.y,
                pi: post.vdfProof.pi,
                l: post.vdfProof.l,
                r: post.vdfProof.r,
                iterations: post.vdfProof.iterations ? post.vdfProof.iterations.toString() : null
            } : null
        };
        console.log('[SIG_VERIFY] Reconstructed signableData object:', signableData);
        
        // This string MUST EXACTLY MATCH the one created before signing.
        const messageToVerifyString = JSON.stringify(signableData);
        console.log('[SIG_VERIFY] Stringified data to verify:', messageToVerifyString);

        const messageBytes = new TextEncoder().encode(messageToVerifyString);
        
        // Attempt to open the signature
        console.log('[SIG_VERIFY] Calling nacl.sign.open...');
        const verifiedMessageBytes = nacl.sign.open(signatureBytes, publicKeyBytes);

        if (verifiedMessageBytes === null) {
            console.error(`[SIG_VERIFY] ‚ùå FAILED: nacl.sign.open returned null. The signature is cryptographically invalid for the given public key and message.`);
            return false;
        }
        console.log('[SIG_VERIFY] ‚úÖ nacl.sign.open succeeded. Signature is valid for the public key.');
        
        // Final check: Does the message content match?
        const decodedMessage = new TextDecoder().decode(verifiedMessageBytes);
        console.log('[SIG_VERIFY] Decoded message from signature:', decodedMessage);
        if (decodedMessage !== messageToVerifyString) {
            console.error(`[SIG_VERIFY] ‚ùå FAILED: Message content mismatch after verification!`);
            console.error(`[SIG_VERIFY]   > Expected: ${messageToVerifyString}`);
            console.error(`[SIG_VERIFY]   > Got:      ${decodedMessage}`);
            return false;
        }

        console.log(`[SIG_VERIFY] ‚úÖ SUCCESS: Message content matches. Signature for post ${post.id} is fully verified.`);
        return true;

    } catch (e) {
        console.error(`[SIG_VERIFY] ‚ùå FAILED: An unexpected error occurred during verification for post ${post.id}:`, e);
        return false;
    }
}

// Main message handler
self.addEventListener('message', async function(e) {
    const { type, data, id } = e.data;
    
    try {
        await initializeWasm();
        
        switch (type) {
            case 'verify_batch':
                const results = await verifyBatch(data.posts);
            
                self.postMessage({ type: 'batch_complete', id, results });
                break;
                
            case 'verify_single':
                const result = await verifySinglePost(data.post);
                self.postMessage({ type: 'single_complete', id, result });
     
           break;
        }
    } catch (error) {
        self.postMessage({ 
            type: 'error', 
            id, 
            error: String(error) 
        });
    }
});

async function verifyBatch(posts) {
    const results = [];
    
    for (const post of posts) {
        const result = await verifySinglePost(post);
        results.push(result);
        
        // Send progress updates
        if (results.length % 10 === 0) {
            self.postMessage({ 
                type: 'progress', 
                completed: results.length, 
                total: posts.length 
            });
        }
    }
    
    return results;
}

async function verifySinglePost(post) {
    const verification = {
        id: post.id,
        valid: false,
        errors: []
    };

    console.log(`[Worker] Starting verification for post ${post.id}`);

    try {
        // --- 1. Verify author VDF (with new validation) ---
        if (!post.authorVdfProof || typeof post.authorVdfProof !== 'object' || !post.authorVdfProof.y) {
            console.log(`[Worker] Author VDF proof missing or malformed:`, post.authorVdfProof);
            verification.errors.push('Missing or malformed author VDF proof');
            return verification;
        }

        console.log(`[Worker] Verifying author VDF proof...`);
        const authorProof = new VDFProof(
            post.authorVdfProof.y,
            post.authorVdfProof.pi,
            post.authorVdfProof.l,
            post.authorVdfProof.r,
            BigInt(post.authorVdfProof.iterations) // Convert back to BigInt for WASM
        );

        const authorVdfValid = await computer.verify_proof(
            post.authorVdfInput,
            authorProof
        );

        console.log(`[Worker] Author VDF verification result: ${authorVdfValid}`);
        if (!authorVdfValid) {
            verification.errors.push('Invalid author VDF proof');
        }

        // --- 2. Verify post VDF if present ---
        if (post.vdfProof) {
            if (typeof post.vdfProof !== 'object' || !post.vdfProof.y) {
                console.log(`[Worker] Post VDF proof malformed:`, post.vdfProof);
                verification.errors.push('Malformed post VDF proof');
            } else {
                console.log(`[Worker] Verifying post VDF proof...`);
                const postProof = new VDFProof(
                    post.vdfProof.y,
                    post.vdfProof.pi,
                    post.vdfProof.l,
                    post.vdfProof.r,
                    BigInt(post.vdfProof.iterations) // Convert back to BigInt for WASM
                );

                const postVdfValid = await computer.verify_proof(
                    post.vdfInput,
                    postProof
                );

                console.log(`[Worker] Post VDF verification result: ${postVdfValid}`);
                if (!postVdfValid) {
                    verification.errors.push('Invalid post VDF proof');
                }
            }
        }

        // --- 3. Verify signature ---
        console.log(`[Worker] Verifying signature...`);
        const signatureValid = verifySignature(post);
        console.log(`[Worker] Signature verification result: ${signatureValid}`);
        if (!signatureValid) {
            verification.errors.push('Invalid signature');
        }

        // The post is valid only if there are no errors
        if (verification.errors.length === 0) {
            verification.valid = true;
            console.log(`[Worker] Post ${post.id} verification SUCCESS`);
        } else {
            console.log(`[Worker] Post ${post.id} verification FAILED. Errors:`, verification.errors);
        }

    } catch (error) {
        console.error(`[Worker] Verification error for post ${post.id}:`, error);
        verification.errors.push(error.message);
    }

    return verification;
}


========================================
--- FILE: vite.config.js
========================================
// vite.config.js
import { defineConfig } from 'vite';

export default defineConfig({
  resolve: {
    alias: {
      webtorrent: 'webtorrent/dist/webtorrent.min.js',
    },
  },
  build: {
    target: 'esnext',
    outDir: 'dist',
    rollupOptions: {
      onwarn(warning, warn) {
        // Log circular dependencies to help debug
        if (warning.code === 'CIRCULAR_DEPENDENCY') {
          console.log('Circular dependency:', warning.message);
          return;
        }
        warn(warning);
      },
      output: {
        manualChunks: {
          // Split vendor chunks to avoid issues
          'vendor': ['tweetnacl', 'webtorrent', 'dompurify'],
          'tensorflow': ['@tensorflow/tfjs', 'nsfwjs']
        }
      }
    }
  },
  optimizeDeps: {
    exclude: ['nsfwjs'] // Sometimes helps with TensorFlow issues
  }
});


========================================
--- FILE: package.json
========================================
{
  "name": "ember-headless-relay",
  "version": "1.0.0",
  "description": "Headless Ember relay node for strengthening the network",
  "type": "module",
  "main": "main.js",
    "imports": {
    "buffer": "buffer/index.js",
    "buffer/": "buffer/"
  },
  "scripts": {
    "dev": "vite",
    "build": "vite build"
  },
  "keywords": [
    "ember",
    "p2p",
    "relay",
    "headless"
  ],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "dompurify": "^3.2.6",
    "fs": "^0.0.1-security",
    "http-server": "^14.1.1",
    "nsfwjs": "^4.2.1",
    "process": "^0.11.10",
    "tweetnacl": "^1.0.3",
    "webtorrent": "^2.6.10"
  },
  "devDependencies": {
    "@babel/core": "^7.28.0",
    "@babel/preset-env": "^7.28.0",
    "babel-jest": "^30.0.4",
    "jest": "^30.0.4",
    "vite": "^5.3.1",
    "vite-plugin-node-polyfills": "^0.23.0"
  }
}


========================================
--- FILE: identity/identity-flow.js
========================================
import nacl from 'tweetnacl';
import { notify } from '../ui.js';
import { serviceCallbacks } from '../services/callbacks.js';
import { state } from '../state.js';
import { arrayBufferToBase64, JSONStringifyWithBigInt } from '../utils.js';
import { HyParView } from '../p2p/hyparview.js';
import wasmVDF from '../vdf-wrapper.js';

export async function createNewIdentity() {
  return new Promise(async (resolve, reject) => {
          console.log('[DEBUG] createNewIdentity called.'); //

    const overlay = document.getElementById('identity-creation-overlay');
    const step0 = document.getElementById('identity-step-0-disclaimer');
    const acknowledgeButton = document.getElementById('acknowledge-button');
    
    acknowledgeButton.onclick = () => {
              console.log('[DEBUG] Acknowledge button clicked.'); //

      step0.style.display = 'none';
      showHandleSelection();
    };
    
    overlay.style.display = 'flex';
    
    async function showHandleSelection() {
              console.log('[DEBUG] showHandleSelection called.'); //

      const step3 = document.getElementById('identity-step-3-prompt');
      
      step3.innerHTML = `
        <p>Choose your unique handle:</p>
        <input type="text" id="identity-handle-input" placeholder="e.g., alice_crypto" />
        <div id="handle-availability" style="margin-top: 10px; font-size: 12px;"></div>
        <button id="identity-confirm-button" class="primary-button" disabled>Claim Handle</button>
      `;
      step3.style.display = 'block';
      
      const handleInput = document.getElementById('identity-handle-input');
      const availabilityDiv = document.getElementById('handle-availability');
      const confirmButton = document.getElementById('identity-confirm-button');
      
      let checkTimeout;
      let lastCheckedHandle = '';
      
      // Real-time handle checking
      handleInput.oninput = async (e) => {
        const handle = e.target.value.trim();
        
        // Clear previous timeout
        if (checkTimeout) clearTimeout(checkTimeout);
        
        // Validate format first
        if (!handle) {
          availabilityDiv.innerHTML = '';
          confirmButton.disabled = true;
          return;
        }
        
        if (handle.length < 3) {
          availabilityDiv.innerHTML = '<span style="color: #ff6b4a">Handle must be at least 3 characters</span>';
          confirmButton.disabled = true;
          return;
        }
        
        if (!/^[a-zA-Z0-9_]+$/.test(handle)) {
          availabilityDiv.innerHTML = '<span style="color: #ff6b4a">Only letters, numbers, and underscores allowed</span>';
          confirmButton.disabled = true;
          return;
        }
        
        // Show checking status
        availabilityDiv.innerHTML = '<span style="color: #ff8c42">Checking availability...</span>';
        confirmButton.disabled = true;
        
        // Debounce the actual check
        checkTimeout = setTimeout(async () => {
                      console.log('[DEBUG] Checking handle availability for:', handle); //

          try {
            // First check if we even have peers
            if (state.peers.size === 0) {
              // We're the first node! All handles are available
                            console.log('[DEBUG] No peers found. Assuming handle is available.'); //

              availabilityDiv.innerHTML = '<span style="color: #44ff44">‚úì Handle available! (First node)</span>';
              confirmButton.disabled = false;
              lastCheckedHandle = handle;
                            console.log('[DEBUG] lastCheckedHandle is now:', lastCheckedHandle); //

              return;
            }
            
            // Set a timeout for the DHT lookup
            const checkPromise = state.identityRegistry.lookupHandle(handle);
            const timeoutPromise = new Promise((resolve) => 
              setTimeout(() => resolve({ timeout: true }), 3000)
            );
            
            const result = await Promise.race([checkPromise, timeoutPromise]);
            
            if (handle !== handleInput.value.trim()) return; // Handle changed while checking
            
            if (result && result.timeout) {
              // DHT lookup timed out - probably no peers responding
              availabilityDiv.innerHTML = '<span style="color: #ffa500">‚ö†Ô∏è Network timeout - proceeding anyway</span>';
              confirmButton.disabled = false;
              lastCheckedHandle = handle;
            } else if (result) {
              availabilityDiv.innerHTML = '<span style="color: #ff6b4a">‚ùå Handle already taken</span>';
              confirmButton.disabled = true;
            } else {
              availabilityDiv.innerHTML = '<span style="color: #44ff44">‚úì Handle available!</span>';
              confirmButton.disabled = false;
              lastCheckedHandle = handle;
            }
          } catch (e) {
            // Network error - we might be the only node
            console.warn("Handle check failed:", e);
            availabilityDiv.innerHTML = '<span style="color: #ffa500">‚ö†Ô∏è Network unavailable - proceeding as first node</span>';
            confirmButton.disabled = false;
            lastCheckedHandle = handle;
          }
        }, 500);// 500ms debounce
      };
      
      confirmButton.onclick = async () => {
        const handle = handleInput.value.trim();
                console.log('[DEBUG] Claim Handle button clicked.'); //
        console.log('[DEBUG] Current handle value:', handle); //
        console.log('[DEBUG] lastCheckedHandle value:', lastCheckedHandle); //

        // Double-check it's still available
        if (handle !== lastCheckedHandle) {
                      console.log('[DEBUG] Gatekeeper FAILED: handle does not match lastCheckedHandle.'); //

          availabilityDiv.innerHTML = '<span style="color: #ff6b4a">Please wait for availability check</span>';
          return;
        }
                console.log('[DEBUG] Gatekeeper PASSED. Proceeding to VDF computation.'); //

        // Disable inputs during VDF computation
        handleInput.disabled = true;
        confirmButton.disabled = true;
        
        // Now compute VDF
        await computeVDFAndRegister(handle, resolve);
      };
      
      handleInput.focus();
    }
    
    async function computeVDFAndRegister(handle, resolve) {
      const step3 = document.getElementById('identity-step-3-prompt');
      const step2 = document.getElementById('identity-step-2-pow');
      
      // Hide handle selection
      step3.style.display = 'none';
      
      // Show VDF computation
      step2.innerHTML = `
        <div class="spinner"></div>
        <div id="identity-status-text-2">
          <strong>Computing proof of work for:</strong> ${handle}
        </div>
        <progress id="identity-progress-bar" value="0" max="100"></progress>
        <div id="identity-progress-percent">0%</div>
      `;
      step2.style.display = 'block';
      
      try {
        // Calibration (quick)
        const calibrationIterations = 5000n;
        const calibrationStart = performance.now();
        await wasmVDF.computeVDFProofWithTimeout(
            "calibration-test",
            calibrationIterations,
            () => {}
        );
        const calibrationTime = performance.now() - calibrationStart;
        
        const iterationsPerMs = Number(calibrationIterations) / calibrationTime;
        const targetWorkTime = 30000;
        const targetIterations = BigInt(Math.max(1000, Math.min(Math.floor(iterationsPerMs * targetWorkTime), 1000000)));
        
        // Compute VDF
        const progressBar = document.getElementById('identity-progress-bar');
        const progressPercent = document.getElementById('identity-progress-percent');
        
        const onProgress = (percentage) => {
            if (progressBar) progressBar.value = percentage;
            if (progressPercent) progressPercent.textContent = `${Math.round(percentage)}%`;
        };
        
        const uniqueId = Math.random().toString(36).substr(2, 9);
        const vdfInput = "ephemeral-identity-creation-" + handle + "-" + uniqueId;
        
        const wasmProof = await wasmVDF.computeVDFProofWithTimeout(
            vdfInput, 
            targetIterations, 
            onProgress
        );
        
        const proofResult = {
            y: wasmProof.y,
            pi: wasmProof.pi,
            l: wasmProof.l,
            r: wasmProof.r,
            iterations: wasmProof.iterations
        };
        
        // Generate keypair
        const keyPair = nacl.sign.keyPair();
        const encryptionKeyPair = nacl.box.keyPair(); // NEW: encryption keys
        const nodeId = new Uint8Array(await crypto.subtle.digest('SHA-1', keyPair.publicKey));
        
        // Create identity object with default profile
        state.myIdentity = {
            handle: handle,
            publicKey: arrayBufferToBase64(keyPair.publicKey),
            secretKey: keyPair.secretKey,
            encryptionPublicKey: arrayBufferToBase64(encryptionKeyPair.publicKey), 
            encryptionSecretKey: encryptionKeyPair.secretKey, 
            vdfProof: proofResult,
            vdfInput: vdfInput,
            uniqueId: uniqueId,
            nodeId: nodeId,
            deviceCalibration: {
                iterationsPerMs: iterationsPerMs,
                calibrationTime: calibrationTime,
                targetIterations: Number(targetIterations)
            },
            profile: {
                handle: handle,
                bio: '',
                profilePictureHash: null,
                theme: {
                    backgroundColor: '#000000',
                    fontColor: '#ffffff',
                    accentColor: '#ff1493'
                },
                updatedAt: Date.now()
            }
        };
        
        // Register immediately in DHT
        try {
            const identityClaim = await state.identityRegistry.registerIdentity(
                handle,
                keyPair,
                proofResult,
                vdfInput
            );
            state.myIdentity.identityClaim = identityClaim;
            state.myIdentity.isRegistered = true;
            state.myIdentity.registrationVerified = true;
        } catch (e) {
            // This will now correctly catch if a handle is already taken
            notify(e.message);
            // Re-show the handle selection screen so the user can pick another
            step2.style.display = 'none';
            showHandleSelection();
            return; // Stop the process
        }
        
        
        // Update the DHT nodeId now that we have our real identity
        if (state.dht && state.myIdentity.nodeId) {
          state.dht.nodeId = state.myIdentity.nodeId;
          state.dht.bootstrap().catch(e => console.error("DHT bootstrap failed:", e));
          // Re-initialize HyParView with correct node ID
          if (state.hyparview) {
            state.hyparview.destroy();
          }
          state.hyparview = new HyParView(state.myIdentity.nodeId, state.dht);
          // Don't await bootstrap here as it might block
          state.hyparview.bootstrap().catch(e => 
            console.error("HyParView bootstrap failed:", e)
          );
        }
        
        
        // Save to localStorage
        const serializableIdentity = {
            ...state.myIdentity,
            publicKey: arrayBufferToBase64(keyPair.publicKey),
            secretKey: Array.from(keyPair.secretKey),
            encryptionPublicKey: arrayBufferToBase64(encryptionKeyPair.publicKey), 
            encryptionSecretKey: Array.from(encryptionKeyPair.secretKey), 
            vdfProof: state.myIdentity.vdfProof,
            deviceCalibration: state.myIdentity.deviceCalibration,
            nodeId: Array.from(state.myIdentity.nodeId),
            profile: state.myIdentity.profile
        };
        localStorage.setItem("ephemeral-id", JSONStringifyWithBigInt(serializableIdentity));
        
        // Success!
        step2.innerHTML = `
          <div style="text-align: center;">
            <h3 style="color: #44ff44;">‚úì Identity Registered!</h3>
            <p>Welcome to Ember, <strong>${handle}</strong>!</p>
          </div>
        `;

        // ADDED: Broadcast initial profile
        console.log('[Identity] Broadcasting initial profile...');
        await serviceCallbacks.broadcastProfileUpdate(state.myIdentity.profile);
        console.log('[Identity] Initial profile broadcast complete');

        setTimeout(() => {
          document.getElementById('identity-creation-overlay').style.display = 'none';
          notify(`Identity "${handle}" successfully registered! üéâ`);
          serviceCallbacks.initializeUserProfileSection();
          resolve();
        }, 2000);
        
      } catch (error) {
        console.error("Identity registration failed:", error);
        step2.innerHTML = `
          <div style="text-align: center;">
            <h3 style="color: #ff6b4a;">Registration Failed</h3>
            <p>${error.message}</p>
            <button onclick="location.reload()" class="primary-button">Try Again</button>
          </div>
        `;
      }
    }
  });
}


========================================
--- FILE: identity/identity-manager.js
========================================
import nacl from 'tweetnacl'; 
import wasmVDF from '../vdf-wrapper.js';
import { state } from '../state.js';
import { base64ToArrayBuffer, arrayBufferToBase64 } from '../utils.js';

// --- NEW, ROBUST IDENTITY REGISTRY ---
export class IdentityRegistry {
  constructor(dht) {
    this.dht = dht;
    this.verifiedIdentities = new Map(); // handle -> identity info
  }
  
  // --- STEP 1: Main registration function ---
  // Stores the full identity claim using the PUBLIC KEY as the address.
async registerIdentity(handle, keyPair, vdfProof, vdfInput) {
  console.log(`[Identity] Starting registration for handle: ${handle}`);
  
  const publicKeyB64 = arrayBufferToBase64(keyPair.publicKey);

  // First, check if the desired handle is already taken
  const existingPubkey = await this.dht.get(`handle-to-pubkey:${handle.toLowerCase()}`);
  if (existingPubkey) {
    throw new Error(`Handle "${handle}" is already registered.`);
  }

  // Create the primary identity claim
  const claim = {
    handle: handle,
    publicKey: publicKeyB64,
    encryptionPublicKey: state.myIdentity.encryptionPublicKey,
    vdfProof: {
      y: vdfProof.y,
      pi: vdfProof.pi,
      l: vdfProof.l,
      r: vdfProof.r,
      iterations: vdfProof.iterations.toString()
    },
    vdfInput: vdfInput,
    claimedAt: Date.now(),
    nodeId: arrayBufferToBase64(await crypto.subtle.digest('SHA-1', keyPair.publicKey))
  };
  
  // Sign the ENTIRE claim
  const claimData = JSON.stringify(claim);
  const signature = nacl.sign(new TextEncoder().encode(claimData), keyPair.secretKey);
  claim.signature = arrayBufferToBase64(signature);

  // Store with high replication factor for identity data
  const identityOptions = {
    propagate: true,
    refresh: true,
    replicationFactor: 30 // Higher replication for critical identity data
  };

  // Store the FULL claim at the pubkey address
  const pubkeyAddress = `pubkey:${publicKeyB64}`;
  const pubkeyResult = await this.dht.store(pubkeyAddress, claim, identityOptions);
  
  if (pubkeyResult.replicas < 3) {
    console.warn(`[Identity] Low replication for identity claim: ${pubkeyResult.replicas} replicas`);
  }

  // Store the secondary mapping from handle -> pubkey
  const handleAddress = `handle-to-pubkey:${handle.toLowerCase()}`;
  //const handleResult = await this.dht.store(handleAddress, { publicKey: publicKeyB64 }, identityOptions);
  const handleResult = await this.dht.store(handleAddress, publicKeyB64, identityOptions);

  if (handleResult.replicas < 3) {
    console.warn(`[Identity] Low replication for handle mapping: ${handleResult.replicas} replicas`);
  }

  console.log(`[Identity] Successfully registered ${handle} with ${pubkeyResult.replicas} replicas`);
  return claim;
}
  
  // --- STEP 2: Main lookup function ---
  // Now, to look up a user, we first find their pubkey, then get their full data.
async lookupHandle(handle) {
  const handleAddress = `handle-to-pubkey:${handle.toLowerCase()}`;
  console.log(`[DM] Looking up handle: ${handle} at DHT address: ${handleAddress}`);

  // Get the public key from DHT
  const publicKeyB64 = await this.dht.get(handleAddress);
  if (!publicKeyB64 || typeof publicKeyB64 !== 'string') {
    console.warn(`[DM] No valid mapping found for handle ${handle}.`);
    return null;
  }

  // Fetch the full claim
  const pubkeyAddress = `pubkey:${publicKeyB64}`;
  const actualClaim = await this.dht.get(pubkeyAddress);
  
  if (!actualClaim) {
    console.warn(`[DM] Found pubkey for ${handle}, but the full claim is missing.`);
    return null;
  }

  // Verify the claim
  try {
    const isValid = await this.verifyClaim(actualClaim);
    if (isValid) {
      console.log(`[DM] Claim for ${handle} is verified.`);
      return actualClaim;
    } else {
      console.warn(`[DM] Claim verification failed for ${handle}.`);
      return null;
    }
  } catch (error) {
    console.error(`[DM] Error verifying claim for ${handle}:`, error);
    return null;
  }
}



  
  // --- STEP 3: Verification Logic (mostly unchanged, but still important) ---
async verifyClaim(claim) {
    try {
        console.log("[Identity] Starting claim verification for handle:", claim.handle);
        
        // Create a copy of the claim without the signature for verification
        const { signature, ...dataToVerify } = claim;
        const signedString = JSON.stringify(dataToVerify);
        
        // Get the public key and signature as buffers
        const publicKey = base64ToArrayBuffer(claim.publicKey);
        const signatureBuffer = base64ToArrayBuffer(signature);
        
        console.log("[Identity] Verifying signature...");
        const verifiedMessage = nacl.sign.open(signatureBuffer, publicKey);
        
        if (!verifiedMessage) {
            console.warn("[Identity] nacl.sign.open returned null. Invalid signature.");
            return false;
        }

        const decodedMessage = new TextDecoder().decode(verifiedMessage);
        if (decodedMessage !== signedString) {
            console.warn("[Identity] Signature is valid, but message content does not match.");
            console.log("[Identity] Expected:", signedString.substring(0, 100) + "...");
            console.log("[Identity] Got:", decodedMessage.substring(0, 100) + "...");
            return false;
        }
        
        console.log("[Identity] Signature verified, checking VDF proof...");
        
        // VDF verification
        if (!claim.vdfProof || !claim.vdfInput) {
            console.warn("[Identity] Missing VDF proof or input");
            return false;
        }
        
        console.log("[Identity] VDF proof structure:", Object.keys(claim.vdfProof));
        console.log("[Identity] Calling wasmVDF.verifyVDFProof...");
        
        const vdfValid = await wasmVDF.verifyVDFProof(claim.vdfInput, claim.vdfProof);
        console.log("[Identity] VDF verification result:", vdfValid);
        
        return vdfValid;

    } catch (e) {
        console.error("[Identity] Claim verification failed:", e);
        return false;
    }
}

  // --- STEP 4: Other functions remain largely the same ---
  
  async verifyAuthorIdentity(post) {
    const claim = await this.lookupHandle(post.author);
    if (!claim) {
      console.warn(`[Identity] No registration found for handle: ${post.author}`);
      return false;
    }
    
    const registeredPubKey = claim.publicKey;
    const postPubKey = arrayBufferToBase64(post.authorPublicKey);
    
    if (registeredPubKey !== postPubKey) {
      console.warn(`[Identity] Public key mismatch for ${post.author}! Possible impersonation.`);
      return false;
    }
    
    this.verifiedIdentities.set(post.author, claim);
    return true;
  }
  
  
  
  
  async verifyOwnIdentity(identity, maxRetries = 5) {
      for (let attempt = 0; attempt < maxRetries; attempt++) {
        try {
          const claim = await this.lookupHandle(identity.handle);
          if (claim) {
            const ourPubKey = arrayBufferToBase64(identity.publicKey);
            return claim.publicKey === ourPubKey;
          }
          if (this.dht.buckets.every(bucket => bucket.length === 0)) {
            console.log(`[Identity] No peers available yet (attempt ${attempt + 1}/${maxRetries}), retrying...`);
            await new Promise(resolve => setTimeout(resolve, 1000 * (attempt + 1)));
            continue;
          }
          return false;
        } catch (e) {
          console.warn(`[Identity] Verification attempt ${attempt + 1} failed:`, e);
          if (attempt < maxRetries - 1) {
            await new Promise(resolve => setTimeout(resolve, 1000 * (attempt + 1)));
          }
        }
      }
      return this.dht.buckets.every(bucket => bucket.length === 0);
  }
  
  async updatePeerLocation(handle, nodeId, wirePeerId) {
  const routingKey = `routing:${handle.toLowerCase()}`;
  console.log(`[Identity] Updating routing info for ${handle} with wire peer ID: ${wirePeerId}`);
  
  const routingInfo = {
    handle: handle,
    nodeId: arrayBufferToBase64(nodeId), // Store as base64 for consistency
    wirePeerId: wirePeerId, // The actual WebRTC peer ID for current connection
    timestamp: Date.now(),
    ttl: 300000 // 5 minutes
  };
  
  // Store locally first
  await this.dht.store(routingKey, routingInfo, { propagate: true });
  
  // Also store reverse mapping for quick lookups
  const reverseKey = `wire-to-handle:${wirePeerId}`;
  await this.dht.store(reverseKey, { handle: handle }, { propagate: true });
  
  console.log(`[Identity] Routing info stored for ${handle} at key ${routingKey}`);
  return true;
}

async lookupPeerLocation(handle) {
  const routingKey = `routing:${handle.toLowerCase()}`;
  console.log(`[Identity] Looking up current peer location for ${handle}`);
  
  const routingInfo = await this.dht.get(routingKey);
  
  if (!routingInfo) {
    console.log(`[Identity] No routing info found for ${handle}`);
    return null;
  }
  
  // Check if routing info is still valid
  const age = Date.now() - routingInfo.timestamp;
  if (age > routingInfo.ttl) {
    console.log(`[Identity] Routing info for ${handle} has expired (age: ${age}ms)`);
    return null;
  }
  
  console.log(`[Identity] Found routing info for ${handle}, wire peer ID: ${routingInfo.wirePeerId}`);
  return routingInfo;
}

async removeExpiredRouting() {
  const routingPrefix = 'routing:';
  const wirePrefix = 'wire-to-handle:';
  
  for (const [key, value] of this.dht.storage) {
    if (key.startsWith(routingPrefix)) {
      // For routing entries, check the routing info's own timestamp
      const routingInfo = value.value || value; // Handle both wrapped and unwrapped values
      if (routingInfo.timestamp && Date.now() - routingInfo.timestamp > (routingInfo.ttl || 300000)) {
        console.log(`[Identity] Removing expired routing entry: ${key} (age: ${Date.now() - routingInfo.timestamp}ms)`);
        this.dht.storage.delete(key);
      }
    } else if (key.startsWith(wirePrefix)) {
      // For wire-to-handle mappings, check if they have a timestamp
      if (value.timestamp && Date.now() - value.timestamp > 300000) {
        console.log(`[Identity] Removing expired wire mapping: ${key}`);
        this.dht.storage.delete(key);
      }
    }
  }
}
  
}


========================================
--- FILE: identity/vdf.js
========================================
import { state } from '../state.js';
import { notify } from '../ui.js';
import wasmVDF from '../vdf-wrapper.js';

export class ProgressiveVDF {
  constructor() {
    this.spamCache = new Map();
    this.userPostTimes = new Map();
  }
  
  // Get device-specific iteration count for target time
getIterationsForTime(targetTimeMs) {
  if (!state.myIdentity?.deviceCalibration?.iterationsPerMs) {
    // Fallback for identities created before calibration
    console.warn("[VDF] No calibration data, using fallback iterations");
    return Math.max(2000, Math.floor(targetTimeMs * 3)); // Increased minimum and multiplier
  }
  
  const iterationsPerMs = state.myIdentity.deviceCalibration.iterationsPerMs;
  const targetIterations = Math.floor(iterationsPerMs * targetTimeMs);
  
  console.log(`[VDF] Target time: ${targetTimeMs}ms, device speed: ${iterationsPerMs.toFixed(2)} iter/ms, iterations: ${targetIterations}`);
  
  return Math.max(2000, targetIterations); // Increased minimum to 2000 iterations
}
  
  // Calculate target time based on content and user behavior  
  calculateTargetTime(content, userId) {
    let baseTimeMs = 1000; // Base 1 second
    
    // Check user's recent posting frequency
    const now = Date.now();
    const userTimes = this.userPostTimes.get(userId) || [];
    const recentPosts = userTimes.filter(t => now - t < 3600000); // Last hour
    
    if (recentPosts.length > 10) {
      baseTimeMs *= 8; // Heavy poster: 8 seconds
    } else if (recentPosts.length > 5) {
      baseTimeMs *= 4; // Frequent poster: 4 seconds
    } else if (recentPosts.length > 2) {
      baseTimeMs *= 2; // Active poster: 2 seconds
    }
    
    // Check for spam patterns
    const contentLower = content.toLowerCase();
    const spamPatterns = [
      /(.)\1{4,}/, // Repeated characters
      /https?:\/\/[^\s]+/g, // Multiple URLs
      /\b(viagra|casino|forex|crypto)\b/i,
    ];
    
    const spamScore = spamPatterns.reduce((score, pattern) => {
      const matches = contentLower.match(pattern);
      return score + (matches ? matches.length : 0);
    }, 0);
    
    if (spamScore > 2) baseTimeMs *= 3; // Spam-like content: longer delay
    
    // Short posts get higher difficulty (likely spam)
    if (content.length < 20) baseTimeMs *= 2;
    
    // Cap maximum time to 30 seconds
    return Math.min(baseTimeMs, 30000);
  }
  
  async computeAdaptiveProof(content, userId, customInput = null) {
    const now = Date.now();
    
    // Calculate target time based on user behavior and content
    const targetTimeMs = this.calculateTargetTime(content, userId);
    
    // Convert time to device-specific iterations
    const iterations = this.getIterationsForTime(targetTimeMs);
    
    // Update user post times
    const times = this.userPostTimes.get(userId) || [];
    times.push(now);
    if (times.length > 20) times.shift(); // Keep last 20
    this.userPostTimes.set(userId, times);
    
    console.log(`[VDF] User ${userId}: target ${targetTimeMs}ms ‚Üí ${iterations} iterations`);
    
    const estimatedTime = Math.round(targetTimeMs / 1000);
    notify(`Computing proof of work... (~${estimatedTime}s)`, Math.max(3000, targetTimeMs));
    
    // Use custom input if provided, otherwise create default
    const vdfInput = customInput || (content + userId + now);
    
    const startTime = performance.now();
    
    try {
      const result = await wasmVDF.computeVDFProofWithTimeout(
        vdfInput,
        BigInt(iterations)
      );
      
      const actualTime = performance.now() - startTime;
      console.log(`[VDF] Completed ${iterations} iterations in ${actualTime.toFixed(0)}ms (target: ${targetTimeMs}ms)`);
      
      return result;
    } catch (error) {
      console.error(`[VDF] Failed after ${performance.now() - startTime}ms:`, error);
      throw error;
    }
  }
  
  // For replies, use shorter times
  async computeReplyProof(content, userId, customInput = null) {
    // Replies get reduced time penalty
    const baseTime = this.calculateTargetTime(content, userId);
    const replyTime = Math.max(500, Math.floor(baseTime * 0.5)); // Half time for replies, minimum 0.5s
    
    const iterations = this.getIterationsForTime(replyTime);
    
    console.log(`[VDF] Reply proof: ${replyTime}ms ‚Üí ${iterations} iterations`);
    
    const vdfInput = customInput || (content + userId + Date.now());
    
    return await wasmVDF.computeVDFProofWithTimeout(
      vdfInput,
      BigInt(iterations)
    );
  }
}


========================================
--- FILE: models/post.js
========================================
import nacl from 'tweetnacl'; 
import { state } from '../state.js';
import { getImageStore } from '../services/instances.js';

import { generateId, sanitize, arrayBufferToBase64, base64ToArrayBuffer } from '../utils.js';
import { CONFIG } from '../config.js';

function serializeVdfProof(proof) {
    if (!proof) return null;
    return {
        y: proof.y,
        pi: proof.pi,
        l: proof.l,
        r: proof.r,
        iterations: proof.iterations ? proof.iterations.toString() : null
    };
}

/* ---------- POST CLASS WITH SIGNATURES ---------- */
export class Post {
    constructor(content, parentId = null, imageData = null) {
        // ADDED: Validate content before creating post
        if (!content || typeof content !== 'string') {
            throw new Error('Post content must be a non-empty string');
        }
        
        if (content.length > CONFIG.MAX_POST_SIZE) {
            throw new Error(`Post content too long: ${content.length} characters (max ${CONFIG.MAX_POST_SIZE})`);
        }
        
        // Core post data
        this.id = generateId();
        this.content = sanitize(content);
        this.timestamp = Date.now();
        this.parentId = parentId;
        this.imageData = imageData; // Temporary storage for base64 before processing
        this.imageHash = null; // Will be populated by processImage()

        // Author's identity information
        if (!state.myIdentity || !state.myIdentity.handle) {
            throw new Error('Cannot create post without identity');
        }
        
        this.author = state.myIdentity.handle;
        this.authorPublicKey = state.myIdentity.publicKey;
        this.authorUniqueId = state.myIdentity.uniqueId;
        this.authorVdfInput = state.myIdentity.vdfInput;

        // Deep copy the VDF proof to ensure BigInt is preserved
        if (state.myIdentity.vdfProof) {
            this.authorVdfProof = {
                y: state.myIdentity.vdfProof.y,
                pi: state.myIdentity.vdfProof.pi,
                l: state.myIdentity.vdfProof.l,
                r: state.myIdentity.vdfProof.r,
                iterations: state.myIdentity.vdfProof.iterations
            };
        } else {
            this.authorVdfProof = null;
        }
        //nb do not sign ratings. they are mutable. 
        //we will use basic bayesian conjugate pair - beta-binomial.
        this.ratings = new Map(); // voter handle -> { vote: 'up'|'down', reputation: number }
        this.ratingStats = {
            alpha: 1, // Beta distribution parameter (successes + 1)
            beta: 1,  // Beta distribution parameter (failures + 1)
            totalWeight: 0,
            score: 0.5 // Prior: neutral
        };
        
        this.signature = null;

        // Ephemeral state
        this.carriers = new Set([state.myIdentity.handle]);
        this.replies = new Set();
        this.depth = 0;
        
        // Trust-related transient properties (not serialized)
        this.trustScore = 0;
        this.attesters = new Set();
        this.attestationTimestamps = new Map();
    }

    async processImage() {
        if (this.imageData && !this.imageHash) {
            const imageStore = getImageStore();
            const result = await imageStore.storeImage(this.imageData);
            this.imageHash = result.hash;
            // The Merkle root is part of imageStore.images.get(this.imageHash).merkleRoot
            this.imageData = null; // Clear raw data after processing
            console.log(`[Post] Image processed, hash: ${this.imageHash?.substring(0, 8)}...`);
        }
    }

    /**
     * Creates a consistent, stringified version of the post data for signing.
     * Includes imageHash for content integrity.
     * @returns {Uint8Array} - The byte array to be signed or verified.
     */
    toSignable() {
      // Ensure publicKey is always in the same format
      let publicKeyBase64;
      if (typeof this.authorPublicKey === 'string') {
        // Already base64
        publicKeyBase64 = this.authorPublicKey;
      } else if (this.authorPublicKey instanceof ArrayBuffer || this.authorPublicKey instanceof Uint8Array) {
        // Convert to base64
        publicKeyBase64 = arrayBufferToBase64(this.authorPublicKey);
      } else {
        console.error('Unknown publicKey type:', typeof this.authorPublicKey);
        publicKeyBase64 = '';
      }

      // This cryptographically links the proof-of-work to the post content and author.
      const signableData = {
        id: this.id,
        content: this.content,
        timestamp: this.timestamp,
        parentId: this.parentId,
        imageHash: this.imageHash,
        authorPublicKey: publicKeyBase64,
        vdfInput: this.vdfInput, // Add VDF input to the signature
        vdfProof: this.vdfProof ? serializeVdfProof(this.vdfProof) : null // Add serialized VDF proof
      };
      const signedString = JSON.stringify(signableData);
      return new TextEncoder().encode(signedString);
    }

    /**
     * Signs the post using the user's private key.
     * @param {Uint8Array} secretKey - The user's secret signing key.
     */
    sign(secretKey) {
        // Re-create the signable data at the moment of signing
        // to capture any properties added after the constructor, like the reply's VDF proof.
        const signableData = {
          id: this.id,
          content: this.content,
          timestamp: this.timestamp,
          parentId: this.parentId,
          imageHash: this.imageHash,
          authorPublicKey: arrayBufferToBase64(this.authorPublicKey),
          vdfInput: this.vdfInput,
          vdfProof: this.vdfProof ? serializeVdfProof(this.vdfProof) : null
        };

        const messageBytes = new TextEncoder().encode(JSON.stringify(signableData));
        this.signature = nacl.sign(messageBytes, secretKey);
        console.log(`[Post] Post signed. Signature: ${arrayBufferToBase64(this.signature).substring(0, 16)}...`);
    }

    /**
     * Verifies the post's signature.
     * @returns {boolean} - True if the signature is valid, false otherwise.
     */
    verify() {
        if (!this.signature || !this.authorPublicKey) {
            console.warn("[Post] Verification failed: Post is missing signature or public key.");
            return false;
        }

        // Use the same logic as the new sign() method to reconstruct the data.
        const signableData = {
          id: this.id,
          content: this.content,
          timestamp: this.timestamp,
          parentId: this.parentId,
          imageHash: this.imageHash,
          authorPublicKey: arrayBufferToBase64(this.authorPublicKey),
          vdfInput: this.vdfInput,
          vdfProof: this.vdfProof ? serializeVdfProof(this.vdfProof) : null
        };
        
        const messageToVerifyBytes = new TextEncoder().encode(JSON.stringify(signableData));
        const originalMessage = nacl.sign.open(this.signature, this.authorPublicKey);

        if (originalMessage === null) {
            console.warn("[Post] Verification failed: nacl.sign.open returned null (invalid signature).");
            return false;
        }

        const decodedOriginal = new TextDecoder().decode(originalMessage);
        const decodedSignable = new TextDecoder().decode(messageToVerifyBytes);

        if (decodedOriginal !== decodedSignable) {
            console.error("[Post] Verification failed: Re-decoded message from signature does NOT match re-created signable data!");
            console.error("  Original from signature:", decodedOriginal);
            console.error("  Re-created signable data:", decodedSignable);
            return false;
        }
        
        console.log("[Post] Signature successfully verified.");
        return true;
    }


    /**
     * Add an attestation from a peer
     * @param {string} attesterHandle - The handle of the attesting peer
     * @param {number} reputationScore - The reputation score of the attester
     * @returns {boolean} - True if attestation was new, false if already existed
     */
    addAttestation(attesterHandle, reputationScore) {
        if (this.attesters.has(attesterHandle)) {
            return false; // Already attested
        }
        
        this.attesters.add(attesterHandle);
        this.attestationTimestamps.set(attesterHandle, Date.now());
        
        // Add reputation score to trust score
        // Use logarithmic scaling to prevent single high-rep peer from dominating
        // But ensure even rep=0 peers contribute something (minimum 1 point)
        const scoreContribution = Math.max(1, Math.log(1 + reputationScore) * 10);
        this.trustScore += scoreContribution;
        
        console.log(`[Post] Added attestation from ${attesterHandle}, trust score now: ${this.trustScore.toFixed(2)}`);
        return true;
    }

    /**
     * Check if post has sufficient trust to skip verification
     * @param {number} threshold - The trust threshold required
     * @returns {boolean}
     */
    hasSufficientTrust(threshold) {
        return this.trustScore >= threshold;
    }

    /**
     * Get age of oldest attestation in milliseconds
     * @returns {number}
     */
    getOldestAttestationAge() {
        if (this.attestationTimestamps.size === 0) return 0;
        
        const now = Date.now();
        let oldestAge = 0;
        
        for (const timestamp of this.attestationTimestamps.values()) {
            const age = now - timestamp;
            if (age > oldestAge) oldestAge = age;
        }
        
        return oldestAge;
    }

    /**
     * Add or update a rating using beta-binomial model
     * @param {string} voterHandle - Handle of the voter
     * @param {string} vote - 'up' or 'down'
     * @param {number} voterReputation - Reputation score of the voter
     * @returns {boolean} - True if rating was new or changed
     */
    addRating(voterHandle, vote, voterReputation) {
        const existingRating = this.ratings.get(voterHandle);
        
        // If same vote, no change needed
        if (existingRating && existingRating.vote === vote) {
            return false;
        }
        
        // Weight based on reputation (log scale with minimum)
        const weight = Math.max(0.1, Math.log10(voterReputation + 10));
        
        // Remove old vote effect if changing vote
        if (existingRating) {
            if (existingRating.vote === 'up') {
                this.ratingStats.alpha -= existingRating.weight;
            } else {
                this.ratingStats.beta -= existingRating.weight;
            }
            this.ratingStats.totalWeight -= existingRating.weight;
        }
        
        // Add new vote
        this.ratings.set(voterHandle, { vote, weight, reputation: voterReputation });
        
        if (vote === 'up') {
            this.ratingStats.alpha += weight;
        } else {
            this.ratingStats.beta += weight;
        }
        this.ratingStats.totalWeight += weight;
        
        // Calculate score using beta distribution mean
        // For beta-binomial, the posterior mean is alpha/(alpha+beta)
        this.ratingStats.score = this.calculateBayesianScore();
        
        console.log(`[Rating] ${voterHandle} rated post ${this.id} as ${vote} (weight: ${weight.toFixed(2)}, score: ${this.ratingStats.score.toFixed(3)})`);
        
        return true;
    }

    /**
     * Calculate Bayesian score using beta-binomial posterior
     * This gives us a score that accounts for uncertainty
     */
    calculateBayesianScore() {
        // Beta distribution parameters (with prior of alpha=1, beta=1)
        const a = this.ratingStats.alpha;
        const b = this.ratingStats.beta;
        const n = a + b - 2; // Total weighted votes (minus prior)
        
        if (n <= 0) return 0.5; // No votes, return neutral prior
        
        // Posterior mean
        const mean = a / (a + b);
        
        // For ranking, we want to penalize uncertainty
        // Use lower bound of credible interval (similar to Wilson score idea)
        // This approximation works well for beta distribution
        const z = 1.96; // 95% confidence
        const variance = (a * b) / ((a + b) * (a + b) * (a + b + 1));
        const stderr = Math.sqrt(variance);
        
        // Lower bound of credible interval
        const lowerBound = mean - z * stderr;
        
        // Ensure bounds
        return Math.max(0, Math.min(1, lowerBound));
    }

    /**
     * Get rating summary for display
     */
    getRatingSummary() {
        const upvotes = Array.from(this.ratings.values()).filter(r => r.vote === 'up').length;
        const downvotes = Array.from(this.ratings.values()).filter(r => r.vote === 'down').length;
        
        // Calculate confidence based on total weighted votes
        // More votes = higher confidence
        const confidence = 1 - Math.exp(-this.ratingStats.totalWeight / 10);
        
        return {
            score: this.ratingStats.score,
            confidence: confidence,
            upvotes,
            downvotes,
            total: this.ratings.size,
            weightedTotal: this.ratingStats.totalWeight
        };
    }



    /**
     * Prepares the entire Post object for network transmission.
     * Converts Uint8Array fields to Base64 strings for reliable JSON transport.
     * @returns {object} - A JSON-serializable object.
     */
    toJSON() {
        const publicKeyBase64 = arrayBufferToBase64(this.authorPublicKey);
        
        // Get fresh image metadata if available
        let imageMeta = null;
        const imageStore = getImageStore();
        if (this.imageHash && imageStore && imageStore.images.has(this.imageHash)) {
            const metadata = imageStore.images.get(this.imageHash);
            imageMeta = {
                merkleRoot: metadata.merkleRoot,
                chunks: metadata.chunks,
                size: metadata.size,
                created: metadata.created
            };
        }
        
        return {
            id: this.id,
            content: this.content,
            timestamp: this.timestamp,
            parentId: this.parentId,
            imageHash: this.imageHash,
            imageMeta: imageMeta,  
            author: this.author,
            authorPublicKey: publicKeyBase64,
            authorUniqueId: this.authorUniqueId,
            authorVdfProof: serializeVdfProof(this.authorVdfProof), // Serialize properly
            authorVdfInput: this.authorVdfInput,
            vdfProof: this.vdfProof ? serializeVdfProof(this.vdfProof) : null, // Also serialize post VDF if present
            vdfInput: this.vdfInput,
            signature: this.signature ? arrayBufferToBase64(this.signature) : null,
            carriers: [...this.carriers],
            replies: [...this.replies],
            depth: this.depth,
            ratings: Array.from(this.ratings.entries()).map(([handle, data]) => ({
                handle,
                vote: data.vote,
                weight: data.weight
            })),
            ratingStats: this.ratingStats
        };
    }

    /**
     * Reconstructs a Post object from incoming network data.
     * Converts Base64 string fields back into Uint8Arrays.
     * @param {object} j - The raw object from a JSON payload.
     * @returns {Post} - A complete Post instance.
     */
    static fromJSON(j) {
        // ADDED: Validate input structure
        if (!j || typeof j !== 'object') {
            throw new Error('Invalid post data: must be an object');
        }
        
        // ADDED: Required field validation
        const requiredFields = ['id', 'content', 'timestamp', 'author'];
        for (const field of requiredFields) {
            if (!(field in j)) {
                throw new Error(`Invalid post data: missing required field "${field}"`);
            }
        }
        
        // ADDED: Type validation
        if (typeof j.id !== 'string' || typeof j.content !== 'string' || 
            typeof j.timestamp !== 'number' || typeof j.author !== 'string') {
            throw new Error('Invalid post data: incorrect field types');
        }
        
        const p = Object.create(Post.prototype);
        
        // Copy all basic properties with validation
        p.id = j.id;
        p.content = sanitize(j.content); // Re-sanitize for safety
        p.timestamp = j.timestamp;
        p.parentId = j.parentId || null;
        p.imageHash = j.imageHash || null;
        p.imageData = j.imageData || null;
        p.author = j.author;
        p.authorUniqueId = j.authorUniqueId || null;
        p.authorVdfInput = j.authorVdfInput || null;
        p.vdfInput = j.vdfInput || null;
        p.depth = typeof j.depth === 'number' ? j.depth : 0;

        // Deserialize VDF proofs with validation
        if (j.authorVdfProof && typeof j.authorVdfProof === 'object') {
            p.authorVdfProof = {
                y: j.authorVdfProof.y,
                pi: j.authorVdfProof.pi,
                l: j.authorVdfProof.l,
                r: j.authorVdfProof.r,
                iterations: j.authorVdfProof.iterations ? BigInt(j.authorVdfProof.iterations) : null
            };
        } else {
            p.authorVdfProof = null;
        }
        
        if (j.vdfProof && typeof j.vdfProof === 'object') {
            p.vdfProof = {
                y: j.vdfProof.y,
                pi: j.vdfProof.pi,
                l: j.vdfProof.l,
                r: j.vdfProof.r,
                iterations: j.vdfProof.iterations ? BigInt(j.vdfProof.iterations) : null
            };
        } else {
            p.vdfProof = null;
        }

        // Store image metadata if available
        if (j.imageMeta && j.imageHash) {
            const imageStore = getImageStore();
            if (imageStore && !imageStore.images.has(j.imageHash)) {
                imageStore.images.set(j.imageHash, j.imageMeta);
                console.log(`[Post.fromJSON] Stored image metadata for ${j.imageHash.substring(0, 8)}...`);
            }
        }

        // Handle public key conversion with validation
        if (typeof j.authorPublicKey === 'string') {
            p.authorPublicKey = base64ToArrayBuffer(j.authorPublicKey);
        } else if (j.authorPublicKey && (j.authorPublicKey.type === 'Buffer' || j.authorPublicKey.data)) {
            p.authorPublicKey = new Uint8Array(j.authorPublicKey.data || j.authorPublicKey);
        } else if (j.authorPublicKey instanceof Uint8Array) {
            p.authorPublicKey = j.authorPublicKey;
        } else {
            p.authorPublicKey = null;
        }
        
        // Handle signature conversion with validation
        if (typeof j.signature === 'string') {
            p.signature = base64ToArrayBuffer(j.signature);
        } else if (j.signature && (j.signature.type === 'Buffer' || j.signature.data)) {
            p.signature = new Uint8Array(j.signature.data || j.signature);
        } else if (j.signature instanceof Uint8Array) {
            p.signature = j.signature;
        } else {
            p.signature = null;
        }
        
        // Convert arrays back to Sets with validation
        p.carriers = new Set(Array.isArray(j.carriers) ? j.carriers : []);
        p.replies = new Set(Array.isArray(j.replies) ? j.replies : []);
        
        // Initialize trust properties for loaded/received posts
        p.trustScore = 0;
        p.attesters = new Set();
        p.attestationTimestamps = new Map();
        
        //community ratings:
        p.ratings = new Map();
        if (j.ratings && Array.isArray(j.ratings)) {
            j.ratings.forEach(r => {
                p.ratings.set(r.handle, {
                    vote: r.vote,
                    weight: r.weight || 1,
                    reputation: r.reputation || 0
                });
            });
        }

        p.ratingStats = j.ratingStats || {
            alpha: 1,
            beta: 1,
            totalWeight: 0,
            score: 0.5
        };
        
        
        console.log('[Post.fromJSON] Reconstructed post:', {
            id: p.id,
            author: p.author,
            hasPublicKey: !!p.authorPublicKey,
            hasSignature: !!p.signature,
            hasAuthorVdfProof: !!p.authorVdfProof,
            authorVdfIterations: p.authorVdfProof?.iterations?.toString()
        });
        
        return p;
    }
}


========================================
--- FILE: p2p/dht.js
========================================
import { messageBus } from './message-bus.js';

// --- KADEMLIA DHT IMPLEMENTATION ---
export class KademliaDHT {
  constructor(nodeId) {
    this.nodeId = nodeId; // 20-byte ID as Uint8Array
    this.k = 20; // Bucket size
    this.alpha = 3; // Concurrency parameter
    this.buckets = new Array(160).fill(null).map(() => []); // 160 k-buckets
    this.storage = new Map(); // Local storage for key-value pairs
    this.rpcHandlers = new Map();
    this.pendingRPCs = new Map();
    this.rpcTimeout = 5000;
    this.refreshQueue = new Map(); // key -> { value, lastRefresh, options }
    this.refreshInterval = 3600000; // 1 hour
    this.replicationFactor = 20; // k parameter
    this.republishInterval = 86400000; // 24 hours
    this.refreshTimer = null;
    this.replicationStatus = new Map(); // key -> { replicas, lastCheck }

    // Initialize RPC handlers
    this.setupRPCHandlers();
  }
  
  async getWithTimeout(key, timeoutMs = 5000) {
      // If no peers, check local storage only
      if (this.buckets.every(bucket => bucket.length === 0)) {
        console.log(`[DHT] No peers - checking local storage for ${key}`);
        return this.storage.get(key) || null;
      }
      
      // Otherwise do normal lookup with timeout
      const getPromise = this.get(key);
      const timeoutPromise = new Promise((resolve) => 
        setTimeout(() => resolve(null), timeoutMs)
      );
      
      return Promise.race([getPromise, timeoutPromise]);
    }
  
   // Compares two Uint8Arrays, returns -1, 0, or 1
  compareUint8Arrays(a, b) {
    const len = Math.min(a.length, b.length);
    for (let i = 0; i < len; i++) {
      if (a[i] < b[i]) return -1;
      if (a[i] > b[i]) return 1;
    }
    if (a.length < b.length) return -1;
    if (a.length > b.length) return 1;
    return 0;
  }
  // XOR distance between two node IDs
  distance(id1, id2) {
    const dist = new Uint8Array(20);
    for (let i = 0; i < 20; i++) {
      dist[i] = id1[i] ^ id2[i];
    }
    return dist;
  }
  
  // Find the bucket index for a given node ID
  getBucketIndex(nodeId) {
    const dist = this.distance(this.nodeId, nodeId);
    
    // Find the highest bit position
    for (let i = 0; i < 160; i++) {
      const byteIndex = Math.floor(i / 8);
      const bitIndex = 7 - (i % 8);
      
      if ((dist[byteIndex] >> bitIndex) & 1) {
        return 159 - i;
      }
    }
    return 0; // Same node
  }
  
  // Add a peer to the appropriate k-bucket
  addPeer(peerId, peerInfo) {
    if (this.uint8ArrayEquals(peerId, this.nodeId)) return; // Don't add self
    
    const bucketIndex = this.getBucketIndex(peerId);
    const bucket = this.buckets[bucketIndex];
    
    // Check if peer already exists in bucket
    const existingIndex = bucket.findIndex(p => this.uint8ArrayEquals(p.id, peerId));
    
    if (existingIndex !== -1) {
      // Move to end (most recently seen)
      const peer = bucket.splice(existingIndex, 1)[0];
      bucket.push(peer);
      return;
    }
    
    // Add new peer
    if (bucket.length < this.k) {
      bucket.push({
        id: peerId,
        wire: peerInfo.wire,
        lastSeen: Date.now(),
        rtt: 0,
        failures: 0
      });
      console.log(`Added peer to k-bucket ${bucketIndex}, bucket size: ${bucket.length}`);
    } else {
      // Bucket full - ping oldest peer
      const oldest = bucket[0];
      this.ping(oldest).then(isAlive => {
        if (!isAlive) {
          // Replace with new peer
          bucket.shift();
          bucket.push({
            id: peerId,
            wire: peerInfo.wire,
            lastSeen: Date.now(),
            rtt: 0,
            failures: 0
          });
          console.log(`Replaced stale peer in k-bucket ${bucketIndex}`);
        }
      });
    }
  }
  
  // Remove a peer from k-buckets
  removePeer(peerId) {
    const bucketIndex = this.getBucketIndex(peerId);
    const bucket = this.buckets[bucketIndex];
    
    const index = bucket.findIndex(p => this.uint8ArrayEquals(p.id, peerId));
    if (index !== -1) {
      bucket.splice(index, 1);
      console.log(`[DHT] Removed peer from k-bucket ${bucketIndex}, bucket size: ${bucket.length}`);
    }
  }
  
  // Helper to compare Uint8Arrays
  uint8ArrayEquals(a, b) {
    if (a.length !== b.length) return false;
    for (let i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) return false;
    }
    return true;
  }
  
  // Convert string/hex to Uint8Array
  hexToUint8Array(hex) {
    if (hex.startsWith('0x')) {
      hex = hex.slice(2);
    }
    
    if (hex.length % 2) {
      hex = '0' + hex;
    }
    
    const bytes = new Uint8Array(hex.length / 2);
    for (let i = 0; i < bytes.length; i++) {
      bytes[i] = parseInt(hex.substr(i * 2, 2), 16);
    }
    return bytes;
  }
  
  // Convert Uint8Array to hex string
  uint8ArrayToHex(bytes) {
    return Array.from(bytes)
      .map(b => b.toString(16).padStart(2, '0'))
      .join('');
  }
  
  // Hash to node ID using Web Crypto API
  async hashToNodeId(data) {
    const encoder = new TextEncoder();
    const dataBuffer = encoder.encode(data);
    const hashBuffer = await crypto.subtle.digest('SHA-1', dataBuffer);
    return new Uint8Array(hashBuffer);
  }
  
  // Find the k closest peers to a target ID
  findClosestPeers(targetId, count = this.k, excludePeerId = null) {
    const allPeers = [];
    
    for (const bucket of this.buckets) {
      for (const peer of bucket) {
        if (excludePeerId && this.uint8ArrayEquals(peer.id, excludePeerId)) continue;
        if (!peer.wire || peer.wire.destroyed) continue;
        
        const distance = this.distance(targetId, peer.id);
        allPeers.push({ peer, distance });
      }
    }
    
    // Sort by distance
    allPeers.sort((a, b) => {
      for (let i = 0; i < 20; i++) {
        if (a.distance[i] !== b.distance[i]) {
          return a.distance[i] - b.distance[i];
        }
      }
      return 0;
    });
    
    return allPeers.slice(0, count).map(item => item.peer);
  }
  
    handleCheckValue(params, senderId) {
      const { key } = params;
      return {
        hasValue: this.storage.has(key),
        timestamp: this.storage.has(key) ? this.storage.get(key).timestamp : null
      };
    }
  
  // Setup RPC handlers
  setupRPCHandlers() {
    this.rpcHandlers.set('PING', this.handlePing.bind(this));
    this.rpcHandlers.set('FIND_NODE', this.handleFindNode.bind(this));
    this.rpcHandlers.set('FIND_VALUE', this.handleFindValue.bind(this));
    this.rpcHandlers.set('STORE', this.handleStore.bind(this));
    this.rpcHandlers.set('CHECK_VALUE', this.handleCheckValue.bind(this));
  }

  // Generate RPC ID
  generateRPCId() {
    return Math.random().toString(36).substr(2, 20);
  }
  
  // Send RPC to a peer
  async sendRPC(peer, method, params) {
    const rpcId = this.generateRPCId();
    
    return new Promise((resolve, reject) => {
      const timeout = setTimeout(() => {
        this.pendingRPCs.delete(rpcId);
        peer.failures++;
        reject(new Error('RPC timeout'));
      }, this.rpcTimeout);
      
      this.pendingRPCs.set(rpcId, { resolve, reject, timeout });
      
      messageBus.sendPeer(peer.wire, {
        type: 'dht_rpc',
        method,
        params,
        rpcId,
        senderId: this.uint8ArrayToHex(this.nodeId)
      });
    });
  }
  
  // Handle incoming RPC
  handleRPC(msg, fromWire) {
    const { method, params, rpcId, senderId } = msg;
    
    if (msg.isResponse) {
      // Handle RPC response
      const pending = this.pendingRPCs.get(rpcId);
      if (pending) {
        clearTimeout(pending.timeout);
        pending.resolve(msg.result);
        this.pendingRPCs.delete(rpcId);
      }
      return;
    }
    
    // Handle RPC request
    const handler = this.rpcHandlers.get(method);
    if (handler) {
      const result = handler(params, senderId);
      messageBus.sendPeer(fromWire, {
        type: 'dht_rpc',
        isResponse: true,
        rpcId,
        result
      });
    }
  }
  
  // RPC Handlers
  handlePing(params, senderId) {
    return { alive: true, nodeId: this.uint8ArrayToHex(this.nodeId) };
  }
  
  handleFindNode(params, senderId) {
    const targetId = this.hexToUint8Array(params.targetId);
    const closest = this.findClosestPeers(targetId, this.k);
    
    return {
      peers: closest.map(p => ({
        id: this.uint8ArrayToHex(p.id)
      }))
    };
  }
  
  handleFindValue(params, senderId) {
    const key = params.key;
    
    // Check if we have the value
    if (this.storage.has(key)) {
      return {
        found: true,
        value: this.storage.get(key)
      };
    }
    
    // Return closest peers
    const keyId = this.hashToNodeId(key);
    const closest = this.findClosestPeers(keyId, this.k);
    
    return {
      found: false,
      peers: closest.map(p => ({
        id: this.uint8ArrayToHex(p.id)
      }))
    };
  }
  
    handleStore(params, senderId) {
      const { key, value } = params;
      
      // ADDED: Validate key and value
      if (!key || typeof key !== 'string' || key.length > 256) {
        console.warn('[DHT] Invalid key in STORE request');
        return { stored: false, error: 'Invalid key' };
      }
      
      // ADDED: Size limit for values
      const valueStr = JSON.stringify(value);
      if (valueStr.length > 64 * 1024) { // 64KB max per value
        console.warn('[DHT] Value too large in STORE request');
        return { stored: false, error: 'Value too large' };
      }
      
      // Check total storage BEFORE adding
      const currentSize = Array.from(this.storage.values())
        .reduce((sum, v) => sum + JSON.stringify(v).length, 0);
      
      const MAX_STORAGE_BYTES = 50 * 1024 * 1024; // 50MB total
      
      if (currentSize + valueStr.length > MAX_STORAGE_BYTES) {
        // Implement LRU eviction
        const entries = Array.from(this.storage.entries())
          .map(([k, v]) => ({
            key: k,
            value: v,
            size: JSON.stringify(v).length,
            timestamp: v.timestamp || 0
          }))
          .sort((a, b) => a.timestamp - b.timestamp); // Oldest first
        
        let freedSpace = 0;
        while (currentSize + valueStr.length - freedSpace > MAX_STORAGE_BYTES && entries.length > 0) {
          const oldest = entries.shift();
          this.storage.delete(oldest.key);
          freedSpace += oldest.size;
        }
        
        if (currentSize + valueStr.length - freedSpace > MAX_STORAGE_BYTES) {
          return { stored: false, error: 'Storage full' };
        }
      }
      
      // Store with CONSISTENT format - wrap the value
      const storageEntry = {
        value: value,  // ‚Üê Wrap the value consistently
        timestamp: Date.now(),
        size: valueStr.length,
        storedBy: senderId
      };
      
      this.storage.set(key, storageEntry);
      
      return { stored: true };
    }
  
  // High-level operations
  async ping(peer) {
    try {
      const result = await this.sendRPC(peer, 'PING', {});
      peer.lastSeen = Date.now();
      peer.failures = 0;
      return true;
    } catch (e) {
      return false;
    }
  }
  
  // Iterative find node
  async findNode(targetId) {
    const seen = new Set();
    const shortlist = this.findClosestPeers(targetId, this.alpha);
    
    if (shortlist.length === 0) return [];
    
    let closestNode = shortlist[0];
    let closestDistance = this.distance(targetId, closestNode.id);
    
    let iterations = 0;
    const maxIterations = 20;
    while (iterations++ < maxIterations) {
      // Query alpha peers in parallel
      const queries = [];
      let queried = 0;
      
      for (const peer of shortlist) {
        const peerId = this.uint8ArrayToHex(peer.id);
        if (seen.has(peerId) || queried >= this.alpha) continue;
        
        seen.add(peerId);
        queried++;
        
        queries.push(
          this.sendRPC(peer, 'FIND_NODE', { 
            targetId: this.uint8ArrayToHex(targetId) 
          }).catch(() => null)
        );
      }
      
      if (queries.length === 0) break;
      
      const results = await Promise.all(queries);
      let improved = false;
      
      for (const result of results) {
        if (!result || !result.peers) continue;
        
        for (const peerInfo of result.peers) {
          const peerId = this.hexToUint8Array(peerInfo.id);
          
          // Check if we have this peer in our buckets
          let found = false;
          for (const bucket of this.buckets) {
            const peer = bucket.find(p => this.uint8ArrayEquals(p.id, peerId));
            if (peer && !seen.has(peerInfo.id)) {
              shortlist.push(peer);
              
              const distance = this.distance(targetId, peerId);
              if (this.compareUint8Arrays(distance, closestDistance) < 0) {

                closestDistance = distance;
                closestNode = peer;
                improved = true;
              }
              
              found = true;
              break;
            }
          }
        }
      }
      
      if (!improved) break;
      
      // Sort shortlist by distance
      shortlist.sort((a, b) => {
        const distA = this.distance(targetId, a.id);
        const distB = this.distance(targetId, b.id);
        for (let i = 0; i < 20; i++) {
          if (distA[i] !== distB[i]) {
            return distA[i] - distB[i];
          }
        }
        return 0;
      });
    }
    
    return shortlist.slice(0, this.k);
  }
  
  // Store a value in the DHT
    async store(key, value, options = {}) {
      const { 
        propagate = true, 
        refresh = true,
        isRefresh = false,
        replicationFactor = this.replicationFactor 
      } = options;
      
      const keyId = await this.hashToNodeId(key);
      
      // Store locally first with metadata
      const storageEntry = {
        value,
        timestamp: Date.now(),
        refresh,
        storedBy: this.uint8ArrayToHex(this.nodeId)
      };
      
      this.storage.set(key, storageEntry);
      console.log(`[DHT] Stored ${key} locally${isRefresh ? ' (refresh)' : ''}`);
      
      // Add to refresh queue if requested
      if (refresh && !isRefresh) {
        this.refreshQueue.set(key, {
          value,
          lastRefresh: Date.now(),
          options: { propagate, replicationFactor }
        });
      }
      
      if (!propagate) {
        return { stored: true, replicas: 1 };
      }
      
      // Find k closest peers for replication
      const totalPeers = this.buckets.reduce((sum, bucket) => sum + bucket.length, 0);
      if (totalPeers === 0) {
        console.log(`[DHT] No peers available - stored ${key} locally only`);
        return { stored: true, replicas: 1 };
      }
      
      const closest = await this.findNode(keyId);
      if (closest.length === 0) {
        console.log(`[DHT] No reachable peers for replication of ${key}`);
        return { stored: true, replicas: 1 };
      }
      
      // Attempt to store on k closest peers
      const targetReplicas = Math.min(replicationFactor, closest.length);
      const storePromises = [];
      const replicationResults = [];
      
      for (let i = 0; i < targetReplicas; i++) {
        const peer = closest[i];
        const promise = this.sendRPC(peer, 'STORE', { key, value })
          .then(result => {
            if (result && result.stored) {
              replicationResults.push({ peer: peer.id, success: true });
              return true;
            }
            replicationResults.push({ peer: peer.id, success: false, reason: 'rejected' });
            return false;
          })
          .catch(error => {
            replicationResults.push({ peer: peer.id, success: false, reason: error.message });
            return false;
          });
        
        storePromises.push(promise);
      }
      
      const results = await Promise.all(storePromises);
      const successCount = results.filter(r => r === true).length;
      
      console.log(`[DHT] Stored key ${key} at ${successCount}/${targetReplicas} remote nodes (plus local)`);
      
      // Log detailed results for debugging
      if (successCount < targetReplicas / 2) {
        console.warn(`[DHT] Poor replication for ${key}:`, replicationResults);
      }
      
      // Update replication status
      this.replicationStatus.set(key, {
        replicas: successCount + 1, // +1 for local
        lastCheck: Date.now()
      });
      
      return { 
        stored: true, 
        replicas: successCount + 1,
        details: replicationResults 
      };
    }
  
  // Retrieve a value from the DHT
async get(key) {
  // Check local storage first
  const localValue = this.storage.get(key);
  if (localValue) {
    console.log(`[DHT] Found ${key} in local storage`);
    return localValue.value; // Always return the wrapped value
  }
  
  const keyId = await this.hashToNodeId(key);
  const seen = new Set();
  const shortlist = this.findClosestPeers(keyId, this.alpha);
  
  // Try multiple peers in parallel for faster lookups
  const parallelQueries = 3;
  let foundValue = null;
  
  while (shortlist.length > 0 && !foundValue) {
    const batch = shortlist.splice(0, parallelQueries);
    const queries = batch.map(async (peer) => {
      const peerId = this.uint8ArrayToHex(peer.id);
      if (seen.has(peerId)) return null;
      seen.add(peerId);
      
      try {
        const result = await this.sendRPC(peer, 'FIND_VALUE', { key });
        
      // When storing values from remote peers:
      if (result.found) {
        // Store locally for caching with consistent format
        this.storage.set(key, {
          value: result.value,  // ‚Üê Ensure consistent wrapping
          timestamp: Date.now(),
          cached: true,
          cachedFrom: peerId
        });
        
        return result.value; // Return unwrapped value
      }
        
        // Add returned peers to shortlist
        if (result.peers) {
          for (const peerInfo of result.peers) {
            if (!seen.has(peerInfo.id)) {
              // Find peer in our buckets
              for (const bucket of this.buckets) {
                const p = bucket.find(peer => 
                  this.uint8ArrayToHex(peer.id) === peerInfo.id
                );
                if (p) {
                  shortlist.push(p);
                  break;
                }
              }
            }
          }
        }
        
        return null;
      } catch (e) {
        // Continue with next peer
        return null;
      }
    });
    
    const results = await Promise.all(queries);
    foundValue = results.find(v => v !== null);
    
    if (foundValue) {
      console.log(`[DHT] Found value for ${key} from network`);
      return foundValue;
    }
    
    // Sort shortlist by distance for next iteration
    shortlist.sort((a, b) => {
      const distA = this.distance(keyId, a.id);
      const distB = this.distance(keyId, b.id);
      return this.compareUint8Arrays(distA, distB);
    });
  }
  
  console.log(`[DHT] Value not found for key: ${key}`);
  return null;
}
  
  // Bootstrap the DHT by finding our own node ID
  async bootstrap() {
    console.log("Bootstrapping DHT...");
    const closest = await this.findNode(this.nodeId);
    console.log(`DHT bootstrap complete, found ${closest.length} peers`);
      // Start refresh timer after bootstrap
    this.startRefreshTimer();
  }
  
  // Get routing table statistics
getStats() {
  let totalPeers = 0;
  let activeBuckets = 0;
  
  for (let i = 0; i < this.buckets.length; i++) {
    const bucketSize = this.buckets[i].length;
    totalPeers += bucketSize;
    if (bucketSize > 0) activeBuckets++;
  }
  
  // Calculate replication health
  let wellReplicated = 0;
  let underReplicated = 0;
  
  for (const [key, status] of this.replicationStatus) {
    if (status.replicas >= this.k / 2) {
      wellReplicated++;
    } else {
      underReplicated++;
    }
  }
  
  return {
    totalPeers,
    activeBuckets,
    avgBucketSize: activeBuckets > 0 ? (totalPeers / activeBuckets).toFixed(2) : 0,
    storageSize: this.storage.size,
    localKeys: this.storage.size,
    refreshQueueSize: this.refreshQueue.size,
    replicationHealth: {
      wellReplicated,
      underReplicated,
      total: this.replicationStatus.size
    }
  };
}
  
    /**
   * Serializes the entire DHT state for saving.
   * @returns {object} - An object containing the routing table and storage.
   */
serialize() {
  const serializedBuckets = this.buckets.map(bucket =>
    bucket.map(peer => ({
      id: this.uint8ArrayToHex(peer.id),
      lastSeen: peer.lastSeen,
      failures: peer.failures,
    }))
  );
  
  // Serialize refresh queue
  const serializedRefreshQueue = Array.from(this.refreshQueue.entries()).map(([key, data]) => ({
    key,
    value: data.value,
    lastRefresh: data.lastRefresh,
    options: data.options
  }));
  
  return {
    buckets: serializedBuckets,
    storage: Array.from(this.storage.entries()),
    refreshQueue: serializedRefreshQueue,
    replicationStatus: Array.from(this.replicationStatus.entries())
  };
}


  /**
   * Deserializes and loads the DHT state from a saved object.
   * @param {object} state - The saved state from serialize().
   */
deserialize(state) {
  if (state.buckets) {
    this.buckets = state.buckets.map(bucket =>
      bucket.map(peer => ({
        id: this.hexToUint8Array(peer.id),
        wire: null,
        lastSeen: peer.lastSeen,
        failures: peer.failures,
      }))
    );
    console.log(`[DHT] Loaded ${state.buckets.flat().length} peers into routing table.`);
  }
  
  if (state.storage) {
    this.storage = new Map(state.storage);
    console.log(`[DHT] Loaded ${this.storage.size} key-value pairs into DHT storage.`);
  }
  
  if (state.refreshQueue) {
    this.refreshQueue = new Map(state.refreshQueue.map(item => [
      item.key,
      {
        value: item.value,
        lastRefresh: item.lastRefresh,
        options: item.options
      }
    ]));
    console.log(`[DHT] Loaded ${this.refreshQueue.size} keys into refresh queue.`);
  }
  
  if (state.replicationStatus) {
    this.replicationStatus = new Map(state.replicationStatus);
  }
  
  // Restart refresh timer if we have data to refresh
  if (this.refreshQueue.size > 0) {
    this.startRefreshTimer();
  }
}
  startRefreshTimer() {
  if (this.refreshTimer) return;
  
  // Run refresh every 10 minutes
  this.refreshTimer = setInterval(() => {
    this.refreshStoredValues().catch(e => 
      console.error('[DHT] Refresh error:', e)
    );
  }, 600000); // 10 minutes
  
  console.log('[DHT] Started refresh timer');
}

stopRefreshTimer() {
  if (this.refreshTimer) {
    clearInterval(this.refreshTimer);
    this.refreshTimer = null;
  }
}

async refreshStoredValues() {
  const now = Date.now();
  let refreshedCount = 0;
  
  for (const [key, refreshData] of this.refreshQueue) {
    const timeSinceRefresh = now - (refreshData.lastRefresh || 0);
    
    // Skip if recently refreshed
    if (timeSinceRefresh < this.refreshInterval) {
      continue;
    }
    
    try {
      // Re-store to ensure replication
      await this.store(key, refreshData.value, {
        ...refreshData.options,
        isRefresh: true
      });
      
      refreshData.lastRefresh = now;
      refreshedCount++;
      
      console.log(`[DHT] Refreshed key: ${key}`);
    } catch (e) {
      console.error(`[DHT] Failed to refresh key ${key}:`, e);
    }
  }
  
  if (refreshedCount > 0) {
    console.log(`[DHT] Refreshed ${refreshedCount} keys`);
  }
  
  // Also check replication status
  await this.checkReplicationStatus();
}

async checkReplicationStatus() {
  const keysToCheck = Array.from(this.refreshQueue.keys()).slice(0, 10); // Check 10 at a time
  
  for (const key of keysToCheck) {
    const status = await this.getReplicationStatus(key);
    this.replicationStatus.set(key, {
      replicas: status.replicas,
      lastCheck: Date.now()
    });
    
    // If under-replicated, force refresh
    if (status.replicas < Math.floor(this.replicationFactor / 2)) {
      console.log(`[DHT] Key ${key} under-replicated (${status.replicas} replicas), forcing refresh`);
      const refreshData = this.refreshQueue.get(key);
      if (refreshData) {
        refreshData.lastRefresh = 0; // Force refresh on next cycle
      }
    }
  }
}

async getReplicationStatus(key) {
  const keyId = await this.hashToNodeId(key);
  const closestPeers = await this.findNode(keyId);
  
  let replicaCount = 0;
  const checkPromises = closestPeers.slice(0, this.k).map(async (peer) => {
    try {
      const result = await this.sendRPC(peer, 'CHECK_VALUE', { key });
      if (result.hasValue) {
        replicaCount++;
      }
    } catch (e) {
      // Peer didn't respond or doesn't have value
    }
  });
  
  await Promise.all(checkPromises);
  
  // Include ourselves if we have it
  if (this.storage.has(key)) {
    replicaCount++;
  }
  
  return { replicas: replicaCount, checked: checkPromises.length };
}
  
  shutdown() {
  this.stopRefreshTimer();
  console.log('[DHT] Shutdown complete');
}
  
}


========================================
--- FILE: p2p/epidemic-gossip.js
========================================
import { state } from '../state.js';
import { sendPeer } from './network-manager.js';

export class EpidemicGossip {
  constructor() {
    this.messageTTL = new Map(); // Track message hops
    this.maxHops = 6;
  }
  
  selectRandomPeers(count, excludePeers = []) {
    const available = Array.from(state.peers.values())
      .filter(p => !excludePeers.includes(p.wire) && !p.wire.destroyed);
    
    // Fisher-Yates shuffle
    for (let i = available.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [available[i], available[j]] = [available[j], available[i]];
    }
    
    return available.slice(0, count);
  }
  
  sendWithExponentialBackoff(peer, msg, attempt = 0) {
    if (attempt > 3) return;
    
    const delay = Math.min(1000 * Math.pow(2, attempt), 5000);
    setTimeout(() => {
      if (!peer.wire.destroyed && peer.wire.ephemeral_msg?._ready) {
        sendPeer(peer.wire, msg);
      } else if (attempt < 3) {
        this.sendWithExponentialBackoff(peer, msg, attempt + 1);
      }
    }, delay + Math.random() * 100);
  }
}


========================================
--- FILE: p2p/hyparview.js
========================================
import { messageBus } from './message-bus.js';

// --- HYPARVIEW PROTOCOL IMPLEMENTATION ---
export class HyParView {
  constructor(nodeId, dht) {
    this.nodeId = nodeId;
    this.dht = dht;
    
    // Protocol parameters
    this.activeViewSize = 5; // Small active view
    this.passiveViewSize = 30; // Larger passive view
    this.shuffleLength = 4; // Number of peers to exchange in shuffle
    this.shuffleInterval = 10000; // 10 seconds
    
    // Views
    this.activeView = new Map(); // peerId -> peer info
    this.passiveView = new Map(); // peerId -> peer info
    
    // Protocol state
    this.shuffleTimer = null;
    this.joinTimer = null;
    this.isBootstrapping = false;
    
    // Start periodic shuffle
    this.startShuffle();
  }
  
  // Add a peer to active view
  addToActiveView(peerId, peerInfo) {
    const peerIdStr = this.dht.uint8ArrayToHex(peerId);
    
    if (this.activeView.has(peerIdStr)) return true;
    
    // Check if active view is full
    if (this.activeView.size >= this.activeViewSize) {
      // Try to drop a peer
      const dropped = this.dropFromActiveView();
      if (!dropped) return false;
    }
    
    this.activeView.set(peerIdStr, {
      id: peerId,
      wire: peerInfo.wire,
      addedAt: Date.now(),
      isOutgoing: peerInfo.isOutgoing || false
    });
    
    console.log(`[HyParView] Added peer to active view. Active: ${this.activeView.size}/${this.activeViewSize}`);
    
    // Remove from passive view if present
    this.passiveView.delete(peerIdStr);
    
    return true;
  }
  
  // Add a peer to passive view
  addToPassiveView(peerId, peerInfo) {
    const peerIdStr = this.dht.uint8ArrayToHex(peerId);
    
    if (this.activeView.has(peerIdStr) || this.passiveView.has(peerIdStr)) {
      return false;
    }
    
    if (this.passiveView.size >= this.passiveViewSize) {
      // Drop random peer from passive view
      const keys = Array.from(this.passiveView.keys());
      const randomKey = keys[Math.floor(Math.random() * keys.length)];
      this.passiveView.delete(randomKey);
    }
    
    this.passiveView.set(peerIdStr, {
      id: peerId,
      wire: peerInfo.wire || null,
      addedAt: Date.now(),
      priority: peerInfo.priority || 0
    });
    
    console.log(`[HyParView] Added peer to passive view. Passive: ${this.passiveView.size}/${this.passiveViewSize}`);
    
    return true;
  }
  
  // Drop a peer from active view (prioritize dropping incoming connections)
  dropFromActiveView() {
    let candidates = [];
    
    // Prefer to drop incoming connections
    for (const [peerId, peer] of this.activeView) {
      if (!peer.isOutgoing) {
        candidates.push(peerId);
      }
    }
    
    // If no incoming connections, consider all
    if (candidates.length === 0) {
      candidates = Array.from(this.activeView.keys());
    }
    
    if (candidates.length === 0) return false;
    
    // Drop random candidate
    const toDrop = candidates[Math.floor(Math.random() * candidates.length)];
    const peer = this.activeView.get(toDrop);
    
    this.activeView.delete(toDrop);
    
    // Move to passive view
    this.addToPassiveView(peer.id, peer);
    
    // Send DISCONNECT message
    if (peer.wire && !peer.wire.destroyed) {
      messageBus.sendPeer(peer.wire, {
        type: 'hyparview',
        subtype: 'DISCONNECT'
      });
    }
    
    return true;
  }
  
  // Handle peer failure
  handlePeerFailure(peerId) {
    const peerIdStr = this.dht.uint8ArrayToHex(peerId);
    
    if (!this.activeView.has(peerIdStr)) return;
    
    console.log(`[HyParView] Peer failed: ${peerIdStr.substring(0, 12)}...`);
    
    // Remove from active view
    this.activeView.delete(peerIdStr);
    
    // Try to replace with peer from passive view
    if (this.passiveView.size > 0) {
      const candidates = Array.from(this.passiveView.values())
        .filter(p => p.wire && !p.wire.destroyed)
        .sort((a, b) => b.priority - a.priority);
      
      if (candidates.length > 0) {
        const replacement = candidates[0];
        this.promoteToActiveView(replacement.id);
      }
    }
    
    // If active view is too small, trigger recovery
    if (this.activeView.size < Math.floor(this.activeViewSize / 2)) {
      this.triggerRecovery();
    }
  }
  
  // Promote a peer from passive to active view
  promoteToActiveView(peerId) {
    const peerIdStr = this.dht.uint8ArrayToHex(peerId);
    const peer = this.passiveView.get(peerIdStr);
    
    if (!peer) return false;
    
    // Send JOIN request
    if (peer.wire && !peer.wire.destroyed) {
      messageBus.sendPeer(peer.wire, {
        type: 'hyparview',
        subtype: 'JOIN',
        ttl: 3,
        sender: this.dht.uint8ArrayToHex(this.nodeId)
      });
      
      return this.addToActiveView(peerId, { ...peer, isOutgoing: true });
    }
    
    return false;
  }
  
  // Handle incoming HyParView messages
  handleMessage(msg, fromWire) {
    switch (msg.subtype) {
      case 'JOIN':
        this.handleJoin(msg, fromWire);
        break;
      case 'FORWARD_JOIN':
        this.handleForwardJoin(msg, fromWire);
        break;
      case 'NEIGHBOR':
        this.handleNeighbor(msg, fromWire);
        break;
      case 'SHUFFLE':
        this.handleShuffle(msg, fromWire);
        break;
      case 'SHUFFLE_REPLY':
        this.handleShuffleReply(msg, fromWire);
        break;
      case 'DISCONNECT':
        this.handleDisconnect(msg, fromWire);
        break;
    }
  }
  
  // Handle JOIN request
  handleJoin(msg, fromWire) {
    const senderId = this.dht.hexToUint8Array(msg.sender);
    
    // Add to active view if possible
    const added = this.addToActiveView(senderId, { wire: fromWire, isOutgoing: false });
    
    if (added) {
      // Forward JOIN to other peers
      if (msg.ttl > 0) {
        const activeList = Array.from(this.activeView.values())
          .filter(p => this.dht.uint8ArrayToHex(p.id) !== msg.sender);
        
        if (activeList.length > 0) {
          const target = activeList[Math.floor(Math.random() * activeList.length)];
          
          messageBus.sendPeer(target.wire, {
            type: 'hyparview',
            subtype: 'FORWARD_JOIN',
            ttl: msg.ttl - 1,
            sender: msg.sender,
            forwarder: this.dht.uint8ArrayToHex(this.nodeId)
          });
        }
      }
    } else {
      // Add to passive view
      this.addToPassiveView(senderId, { wire: fromWire });
    }
  }
  
  // Handle FORWARD_JOIN
  handleForwardJoin(msg, fromWire) {
    const senderId = this.dht.hexToUint8Array(msg.sender);
    
    if (msg.ttl === 0 || this.activeView.size >= this.activeViewSize) {
      // Send NEIGHBOR message back to original sender
      const senderPeer = this.findPeerByWire(fromWire);
      if (senderPeer) {
        messageBus.sendPeer(fromWire, {
          type: 'hyparview',
          subtype: 'NEIGHBOR',
          target: msg.sender,
          priority: this.activeView.size < this.activeViewSize ? 'high' : 'low'
        });
      }
    } else {
      // Continue forwarding
      const activeList = Array.from(this.activeView.values())
        .filter(p => this.dht.uint8ArrayToHex(p.id) !== msg.sender && 
                    this.dht.uint8ArrayToHex(p.id) !== msg.forwarder);
      
      if (activeList.length > 0) {
        const target = activeList[Math.floor(Math.random() * activeList.length)];
        
        messageBus.sendPeer(target.wire, {
          type: 'hyparview',
          subtype: 'FORWARD_JOIN',
          ttl: msg.ttl - 1,
          sender: msg.sender,
          forwarder: this.dht.uint8ArrayToHex(this.nodeId)
        });
      }
    }
  }
  
  // Handle NEIGHBOR message
  handleNeighbor(msg, fromWire) {
    const peerId = fromWire.peerId;
    
    if (msg.priority === 'high') {
      this.addToActiveView(peerId, { wire: fromWire, isOutgoing: false });
    } else {
      this.addToPassiveView(peerId, { wire: fromWire, priority: 1 });
    }
  }
  
  // Handle SHUFFLE request
  handleShuffle(msg, fromWire) {
    const senderId = fromWire.peerId;
    
    // Select random peers from passive view
    const passiveList = Array.from(this.passiveView.entries());
    const selected = [];
    
    for (let i = 0; i < this.shuffleLength && passiveList.length > 0; i++) {
      const index = Math.floor(Math.random() * passiveList.length);
      const [peerId, peer] = passiveList.splice(index, 1)[0];
      selected.push(peerId);
    }
    
    // Send reply
    messageBus.sendPeer(fromWire, {
      type: 'hyparview',
      subtype: 'SHUFFLE_REPLY',
      peers: selected
    });
    
    // Add received peers to passive view
    if (msg.peers) {
      for (const peerId of msg.peers) {
        this.addToPassiveView(this.dht.hexToUint8Array(peerId), { priority: 0 });
      }
    }
  }
  
  // Handle SHUFFLE_REPLY
  handleShuffleReply(msg, fromWire) {
    if (msg.peers) {
      for (const peerId of msg.peers) {
        this.addToPassiveView(this.dht.hexToUint8Array(peerId), { priority: 0 });
      }
    }
  }
  
  // Handle DISCONNECT
  handleDisconnect(msg, fromWire) {
    const peer = this.findPeerByWire(fromWire);
    if (peer) {
      const peerIdStr = this.dht.uint8ArrayToHex(peer.id);
      this.activeView.delete(peerIdStr);
      console.log(`[HyParView] Peer disconnected: ${peerIdStr.substring(0, 12)}...`);
    }
  }
  
  // Find peer by wire connection
  findPeerByWire(wire) {
    for (const [peerId, peer] of this.activeView) {
      if (peer.wire === wire) return peer;
    }
    for (const [peerId, peer] of this.passiveView) {
      if (peer.wire === wire) return peer;
    }
    return null;
  }
  
  // Start periodic shuffle
  startShuffle() {
    this.shuffleTimer = setInterval(() => {
      this.performShuffle();
    }, this.shuffleInterval);
  }
  
  // Perform shuffle operation
  performShuffle() {
    if (this.activeView.size === 0) return;
    
    // Select random active peer
    const activePeers = Array.from(this.activeView.values());
    const target = activePeers[Math.floor(Math.random() * activePeers.length)];
    
    // Select random subset from active and passive views
    const toSend = [];
    const combined = [
      ...Array.from(this.activeView.keys()),
      ...Array.from(this.passiveView.keys())
    ];
    
    for (let i = 0; i < this.shuffleLength && combined.length > 0; i++) {
      const index = Math.floor(Math.random() * combined.length);
      toSend.push(combined.splice(index, 1)[0]);
    }
    
    if (toSend.length > 0 && target.wire && !target.wire.destroyed) {
      messageBus.sendPeer(target.wire, {
        type: 'hyparview',
        subtype: 'SHUFFLE',
        peers: toSend
      });
    }
  }
  
  // Trigger recovery when active view is too small
  triggerRecovery() {
    console.log(`[HyParView] Triggering recovery. Active view size: ${this.activeView.size}`);
    
    // Try to promote peers from passive view
    const candidates = Array.from(this.passiveView.values())
      .filter(p => p.wire && !p.wire.destroyed);
    
    const needed = this.activeViewSize - this.activeView.size;
    for (let i = 0; i < needed && i < candidates.length; i++) {
      this.promoteToActiveView(candidates[i].id);
    }
    
    // If still not enough peers, use DHT to find more
    if (this.activeView.size < this.activeViewSize) {
      this.dht.findNode(this.nodeId).then(peers => {
        for (const peer of peers) {
          if (this.activeView.size >= this.activeViewSize) break;
          
          const peerId = peer.id;
          if (!this.activeView.has(this.dht.uint8ArrayToHex(peerId))) {
            this.addToActiveView(peerId, { wire: peer.wire, isOutgoing: true });
          }
        }
      });
    }
  }
  
  // Bootstrap the overlay
  async bootstrap() {
    console.log("[HyParView] Starting bootstrap...");
    this.isBootstrapping = true;
    
    // Use DHT to find initial peers
    const peers = await this.dht.findNode(this.nodeId);
    
    for (const peer of peers) {
      if (this.activeView.size >= this.activeViewSize) break;
      
      // Send JOIN request
      messageBus.sendPeer(peer.wire, {
        type: 'hyparview',
        subtype: 'JOIN',
        ttl: 3,
        sender: this.dht.uint8ArrayToHex(this.nodeId)
      });
      
      this.addToActiveView(peer.id, { wire: peer.wire, isOutgoing: true });
    }
    
    this.isBootstrapping = false;
    console.log(`[HyParView] Bootstrap complete. Active: ${this.activeView.size}, Passive: ${this.passiveView.size}`);
  }
  
  // Get current statistics
  getStats() {
    return {
      activeView: this.activeView.size,
      passiveView: this.passiveView.size,
      activeCapacity: `${this.activeView.size}/${this.activeViewSize}`,
      passiveCapacity: `${this.passiveView.size}/${this.passiveViewSize}`
    };
  }
  
  // Get active peers for message propagation
  getActivePeers() {
    return Array.from(this.activeView.values())
      .filter(p => p.wire && !p.wire.destroyed);
  }
  
  // Cleanup on shutdown
  destroy() {
    if (this.shuffleTimer) {
      clearInterval(this.shuffleTimer);
    }
    
    // Send disconnect to all active peers
    for (const peer of this.activeView.values()) {
      if (peer.wire && !peer.wire.destroyed) {
        messageBus.sendPeer(peer.wire, {
          type: 'hyparview',
          subtype: 'DISCONNECT'
        });
      }
    }
    
    this.activeView.clear();
    this.passiveView.clear();
  }
}


========================================
--- FILE: p2p/message-bus.js
========================================
// p2p/message-bus.js
class MessageBus {
  constructor() {
    this.handlers = new Map();
    this.sendPeerFn = null;
  }
  
  // Register the sendPeer function
  setSendPeer(fn) {
    this.sendPeerFn = fn;
  }
  
  // Wrapper for sendPeer
  sendPeer(wire, msg) {
    if (!this.sendPeerFn) {
      throw new Error('sendPeer not initialized');
    }
    return this.sendPeerFn(wire, msg);
  }
  
  // Register message handlers
  registerHandler(type, handler) {
    this.handlers.set(type, handler);
  }
  
  // Handle incoming messages
  async handleMessage(type, data, fromWire) {
    const handler = this.handlers.get(type);
    if (handler) {
      return await handler(data, fromWire);
    }
  }
}

export const messageBus = new MessageBus();


========================================
--- FILE: p2p/network-manager.js
========================================
// This module handles the core WebTorrent setup, peer wire management,
// and acts as the main dispatcher for all incoming P2P messages.

// --- IMPORTS ---
import WebTorrent from 'webtorrent';
// Import shared state and services directly from the state module
import { state } from '../state.js';
import { getServices } from '../services/instances.js';
import { messageBus } from './message-bus.js';

// Message handler registry
const messageHandlers = new Map();
export function registerHandler(type, handler) {
  messageHandlers.set(type, handler);
}


import { updateConnectionStatus, notify, updateStatus, refreshPost, renderPost, setSendPeer, updateProfilePicturesInPosts } from '../ui.js';
import { CONFIG } from '../config.js';
import { generateId, hexToUint8Array, normalizePeerId, arrayBufferToBase64, base64ToArrayBuffer } from '../utils.js';
import { KademliaDHT } from './dht.js';
import { HyParView } from './hyparview.js';
import { Scribe } from './scribe.js';
//import { Plumtree } from './plumtree.js';
import nacl from 'tweetnacl'; 


// --- FUNCTION DEFINITIONS ---

function initNetwork() { // It no longer needs to be async
  updateConnectionStatus("Initializing WebTorrent...");

  const isIOS = typeof navigator !== 'undefined' && /iPad|iPhone|iPod/.test(navigator.userAgent);
  console.log("Initializing network... iOS:", isIOS);

 
  if (!window.RTCPeerConnection) {
    console.error("WebRTC not supported!");
    updateConnectionStatus("WebRTC not supported on this device", 'error');
    notify("WebRTC not supported on this device");
    return;
  }

  updateConnectionStatus("Setting up peer connections...");
  const trackers = [
    'wss://tracker.openwebtorrent.com',
    'wss://tracker.webtorrent.dev',
    'wss://tracker.btorrent.xyz',
    'wss://tracker.files.fm:7073/announce',
  ];
  state.trackers = trackers;

  try {
    // This line will now use the `WebTorrent` variable we just defined above.
    state.client = new WebTorrent({
      dht: true,
      maxConns: 100,
      tracker: {
        announce: trackers,
        rtcConfig: {
          iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:stun1.l.google.com:19302' }
          ]
        }
      },
      trickle: true
    });


    updateConnectionStatus("Joining DHT bootstrap network...");

    const bootstrapData = new Blob(['Ember-DHT-Bootstrap-v1'], { type: 'text/plain' });
    state.client.seed(bootstrapData, {
      name: 'ember-bootstrap.txt',
      announce: state.trackers || []
    }, torrent => {
      console.log(`Connected to bootstrap network: ${torrent.infoHash}`);
      updateConnectionStatus("Connected to Ember bootstrap network!");
      
      torrent.on('wire', (wire, addr) => {
        handleBootstrapWire(wire, addr);
      });
      
      torrent.on('error', (err) => {
        console.error('Bootstrap torrent error:', err);
        updateConnectionStatus(`Bootstrap error: ${err.message}`, 'error');
      });
      
      // Check peer count after a delay
      setTimeout(() => {
        if (torrent.numPeers === 0) {
          updateConnectionStatus("No peers found - you might be the first node! üåü", 'info');
        }
      }, 10000);
    });

    // ADDED: Handle seed errors
    state.client.on('error', (err) => {
      if (err.message.includes('seed')) {
        console.error('Failed to seed bootstrap:', err);
        updateConnectionStatus('Failed to join bootstrap network', 'error');
        
        // Attempt recovery
        setTimeout(() => {
          console.log('Attempting to reconnect...');
          location.reload();
        }, 5000);
      }
    });



  } catch (e) {
    console.error("Failed to create WebTorrent client:", e);
    updateConnectionStatus(`Failed to initialize: ${e.message}`, 'error');
    throw e;
  }

  state.client.on("error", e => {
    console.error("Client error:", e.message);
    updateConnectionStatus(`Network error: ${e.message}`, 'error');
    if (!/Connection error|WebSocket/.test(e.message)) {
      notify("Network error: " + e.message);
    }
  });

  state.client.on('warning', (err) => {
    console.warn('WebTorrent warning:', err);
  });

  updateConnectionStatus("Network ready - using unified bootstrap");

  let lastPeerCount = 0;
    const statusCheckInterval = setInterval(() => {
      const currentPeerCount = state.peers.size;
      
      if (currentPeerCount !== lastPeerCount) {
        console.log(`Peer count changed: ${lastPeerCount} ‚Üí ${currentPeerCount}`);
        if (currentPeerCount > 0 && lastPeerCount === 0) {
          updateConnectionStatus(`Connected! ${currentPeerCount} peer${currentPeerCount > 1 ? 's' : ''}`, 'success');
          notify("üî• Another node joined the network!");
        } else if (currentPeerCount > lastPeerCount) {
          updateConnectionStatus(`${currentPeerCount} peers connected`, 'success');
        }
        lastPeerCount = currentPeerCount;
      }
      
      // Special handling for first node
      const timeSinceStart = Date.now() - (window.networkStartTime || Date.now());
      if (state.peers.size === 0 && timeSinceStart > 15000) {
        // After 15 seconds with no peers, assume we're first
        updateConnectionStatus("Running as first node - waiting for others to join... üåü", 'info');
        clearInterval(statusCheckInterval); // Stop checking so frequently
      }
    }, 1000);

  window.networkStartTime = Date.now();
  console.log("Network initialization complete", {
    client: !!state.client,
    trackers: trackers.length
  });
}

function handleBootstrapWire(wire, addr) {
  const originalId = wire.peerId;
  const idKey = normalizePeerId(originalId);

  if (!idKey) {
    console.error('Invalid bootstrap peer ID');
    return;
  }
  if (state.peers.has(idKey)) return;

  console.log(`Bootstrap peer connected: ${idKey.substring(0, 12)}...`);
  wire.peerId = idKey;

  const peerData = {
    wire,
    addr,
    id: originalId,
    idKey: idKey,
    messageTimestamps: [],
    shardIndex: 'bootstrap',
    connectedAt: Date.now(),
    bytesReceived: 0,
    bytesSent: 0
  };

  state.peers.set(idKey, peerData);

  if (state.dht && originalId) {
    let uint8Id;
    if (originalId instanceof Uint8Array) {
      uint8Id = originalId;
    } else if (ArrayBuffer.isView(originalId)) {
      uint8Id = new Uint8Array(originalId.buffer, originalId.byteOffset, originalId.byteLength);
    } else if (typeof originalId === 'string') {
      const hex = originalId.replace(/^0x/, '');
      if (hex.length % 2 === 0) {
        uint8Id = new Uint8Array(hex.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));
      }
    } else if (originalId && (originalId.type === 'Buffer' || originalId.data)) {
      uint8Id = new Uint8Array(originalId.data || originalId);
    }

    if (uint8Id) {
      state.dht.addPeer(uint8Id, peerData);
    }
  }

  if (state.hyparview && state.hyparview.activeView.size < state.hyparview.activeViewSize) {
    state.hyparview.addToActiveView(originalId, { wire, isOutgoing: false });
  }

  attachEphemeralExtension(wire);

    // Set up a delayed identity announcement
    setTimeout(async () => {
      if (wire.destroyed) return;
      
      // If we have an identity, announce our routing info
      if (state.myIdentity && state.identityRegistry) {
        try {
          await state.identityRegistry.updatePeerLocation(
            state.myIdentity.handle,
            state.myIdentity.nodeId,
            idKey // This is the normalized peer ID
          );
          console.log(`[Network] Announced routing info for ${state.myIdentity.handle}`);
          
          // Also send a direct announcement to this peer
          sendPeer(wire, {
            type: 'identity_announce',
            handle: state.myIdentity.handle,
            publicKey: state.myIdentity.publicKey,
            wirePeerId: idKey
          });
        } catch (e) {
          console.error('[Network] Failed to update peer location:', e);
        }
      }
    }, 2000); // Wait 2 seconds for connection to stabilize


  wire.on('close', () => {
    console.log(`Bootstrap peer disconnected: ${idKey.substring(0, 12)}...`);
    state.peers.delete(idKey);
    if (state.dht && originalId) state.dht.removePeer(originalId);
    if (state.hyparview && originalId) state.hyparview.handlePeerFailure(originalId);
    updateStatus();
  });

  wire.on('error', err => console.error(`Bootstrap wire error:`, err.message));
}

function handleWire(wire, addr) {
  // ADDED: Connection rate limiting
  if (!state.connectionTracker) {
    state.connectionTracker = new Map();
  }
  
  // Extract IP from address
    let ip = 'unknown';
    if (addr) {
        const lastColon = addr.lastIndexOf(':');
        if (addr.startsWith('[') && addr.includes(']')) {
            // IPv6 like [::1]:port
            ip = addr.substring(0, addr.indexOf(']') + 1);
        } else if (lastColon > addr.indexOf(':')) {
            // IPv4 like 127.0.0.1:port
            ip = addr.substring(0, lastColon);
        } else {
            // Address without port
            ip = addr;
        }
    }
    
  const now = Date.now();
  
  // Track connections per IP
  let ipData = state.connectionTracker.get(ip);
  if (!ipData) {
    ipData = { connections: [], blocked: false };
    state.connectionTracker.set(ip, ipData);
  }
  
  // Remove old connections (older than 1 minute)
  ipData.connections = ipData.connections.filter(time => now - time < 60000);
  
  // Check if IP is blocked
  if (ipData.blocked && now - ipData.blockedTime < 300000) { // 5 minute block
    console.warn(`Rejecting connection from blocked IP: ${ip}`);
    wire.destroy();
    return;
  }
  
  // Check rate limit (max 10 connections per minute per IP)
  if (ipData.connections.length >= 10) {
    console.warn(`Rate limit exceeded for IP: ${ip}`);
    ipData.blocked = true;
    ipData.blockedTime = now;
    wire.destroy();
    return;
  }
  
  // Track this connection
  ipData.connections.push(now);
  
  // Clean up tracker periodically
  if (state.connectionTracker.size > 1000) {
    const cutoff = now - 600000; // 10 minutes
    const toDelete = [];
    state.connectionTracker.forEach((data, ip) => {
      if (data.connections.length === 0 && (!data.blocked || now - data.blockedTime > 600000)) {
        toDelete.push(ip);
      }
    });
    toDelete.forEach(ip => state.connectionTracker.delete(ip));
  }
  
  const originalId = wire.peerId;
  const idKey = normalizePeerId(originalId);

  if (!idKey) {
    console.error('Invalid peer ID, rejecting connection');
    return;
  }
  if (state.peers.has(idKey)) return;

  wire.peerId = idKey;
  console.log(`New peer connection: ${idKey.substring(0, 12)}...`);

  const peerData = {
    wire,
    addr,
    id: originalId,
    idKey: idKey,
    messageTimestamps: [],
    connectedAt: Date.now(),
    bytesReceived: 0,
    bytesSent: 0
  };

  state.peers.set(idKey, peerData);

  if (state.dht) {
    let uint8Id;
    if (originalId instanceof Uint8Array) {
      uint8Id = originalId;
    } else if (ArrayBuffer.isView(originalId)) {
      uint8Id = new Uint8Array(originalId.buffer, originalId.byteOffset, originalId.byteLength);
    } else if (typeof originalId === 'string') {
      const hex = originalId.replace(/^0x/, '');
      if (hex.length % 2 === 0) {
        uint8Id = new Uint8Array(hex.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));
      }
    } else if (originalId && (originalId.type === 'Buffer' || originalId.data)) {
      uint8Id = new Uint8Array(originalId.data || originalId);
    }
    if (uint8Id) {
      state.dht.addPeer(uint8Id, peerData);
    }
  }

  if (state.hyparview && state.hyparview.activeView.size < state.hyparview.activeViewSize) {
    state.hyparview.addToActiveView(originalId, { wire, isOutgoing: false });
  }

  getServices().peerManager.updateScore(idKey, 'connection', 1);
  updateStatus();

  wire.on('download', (bytes) => {
    peerData.bytesReceived += bytes;
    getServices().peerManager.updateScore(idKey, 'data', bytes / 1000);
  });

  wire.on('upload', (bytes) => {
    peerData.bytesSent += bytes;
  });

  attachEphemeralExtension(wire);


setTimeout(async () => {
  if (wire.destroyed) return;
  
  if (state.myIdentity && state.identityRegistry) {
    try {
      await state.identityRegistry.updatePeerLocation(
        state.myIdentity.handle,
        state.myIdentity.nodeId,
        idKey
      );
      console.log(`[Network] Announced routing info for ${state.myIdentity.handle}`);
      
      sendPeer(wire, {
        type: 'identity_announce',
        handle: state.myIdentity.handle,
        publicKey: state.myIdentity.publicKey,
        wirePeerId: idKey
      });
    } catch (e) {
      console.error('[Network] Failed to update peer location:', e);
    }
  }
}, 2000);


  const delay = Math.random() * 10000;
  setTimeout(() => {
    if (!wire.destroyed) {
      sendPeer(wire, { type: 'request_posts' });
    }
  }, delay);

  wire.on('close', () => {
    console.log(`Disconnected from peer: ${idKey}`);
    getServices().peerManager.updateScore(idKey, 'disconnection', 1);
    state.peers.delete(idKey);
    if (state.dht && originalId) state.dht.removePeer(originalId);
    if (state.hyparview && originalId) state.hyparview.handlePeerFailure(originalId);
    updateStatus();
  });

  wire.on('error', err => console.error(`Wire error ${idKey}:`, err.message));
}

function broadcast(message, excludePeerWire = null) {
  // Use the resilient active view from HyParView for gossip
  if (!state.hyparview) {
    console.warn("[Broadcast] HyParView not initialized. Cannot broadcast.");
    return;
  }

  const activePeers = state.hyparview.getActivePeers();
  if (activePeers.length === 0) {
    console.warn("[Broadcast] No active peers in HyParView to broadcast to.");
    return;
  }

  console.log(`[Broadcast] Gossiping message type "${message.type}" to ${activePeers.length} active peers.`);
  
  for (const peer of activePeers) {
    // Check if the peer wire is valid and not the one to exclude
    if (peer.wire && !peer.wire.destroyed && peer.wire !== excludePeerWire) {
      sendPeer(peer.wire, message);
    }
  }
}



const sendPeer = (wire, msg) => {
  if (!wire || wire.destroyed) return;

  try {
    const encoder = new TextEncoder();
    const msgStr = JSON.stringify(msg);
    
    // Add debug logging for chunk responses
    if (msg.type === 'chunk_response') {
      console.log(`[SendPeer] Sending chunk_response with ${msg.chunks.length} chunks for image ${msg.imageHash.substring(0, 8)}...`);
      console.log(`[SendPeer] Message size: ${msgStr.length} bytes (max: ${CONFIG.MAX_MESSAGE_SIZE})`);
    }
    
    if (msgStr.length > CONFIG.MAX_MESSAGE_SIZE) {
      console.warn("Message too large, dropping:", msgStr.length);
      return;
    }
    const data = encoder.encode(msgStr);

    // Add more debug info
    const extensionReady = wire.ephemeral_msg && wire.ephemeral_msg._ready;
    if (msg.type === 'chunk_response') {
      console.log(`[SendPeer] Extension ready: ${extensionReady}, wire destroyed: ${wire.destroyed}`);
    }

    if (wire.ephemeral_msg && wire.ephemeral_msg._ready && wire.ephemeral_msg.peerId !== undefined) {
      wire.extended(wire.ephemeral_msg.peerId, data);
      if (msg.type === 'chunk_response') {
        console.log('[SendPeer] Sent via ephemeral_msg extension');
      }
    } else if (wire.extendedMapping && wire.extendedMapping.ephemeral_msg !== undefined) {
      wire.extended(wire.extendedMapping.ephemeral_msg, data);
      if (msg.type === 'chunk_response') {
        console.log('[SendPeer] Sent via extendedMapping');
      }
    } else {
      if (!wire._pendingMessages) {
        wire._pendingMessages = [];
        // Start a timeout only for the *first* queued message
        wire._pendingTimeout = setTimeout(() => {
            if (wire._pendingMessages && wire._pendingMessages.length > 0) {
                console.warn(`[Extension] Clearing ${wire._pendingMessages.length} queued messages for unresponsive peer: ${wire.peerId}`);
                wire._pendingMessages = []; // Clear the queue
            }
        }, 15000); // 15 second timeout
      }

      wire._pendingMessages.push(msg);
      if (wire._pendingMessages.length > CONFIG.MAX_PENDING_MESSAGES) {
          wire._pendingMessages.shift(); // Remove oldest message
      }
      console.log(`[Extension] Queued message. Queue size: ${wire._pendingMessages.length}`);
    }
  } catch (e) {
    console.warn("sendPeer fail", e.message);
  }
};

// Initialize messageBus with sendPeer
messageBus.setSendPeer(sendPeer);

setSendPeer(sendPeer);


function attachEphemeralExtension(wire) {
  function EphemeralExtension() {
    const self = this;
    self._ready = false;
  }
  EphemeralExtension.prototype.name = 'ephemeral_msg';

EphemeralExtension.prototype.onExtendedHandshake = function (handshake) {
    if (!handshake.m || typeof handshake.m.ephemeral_msg === 'undefined') {
      console.warn('Peer does not support ephemeral_msg');
      // If handshake fails, clear any pending timeout and messages
      if (wire._pendingTimeout) clearTimeout(wire._pendingTimeout);
      wire._pendingMessages = [];
      return;
    }
    this.peerId = handshake.m.ephemeral_msg;
    this._ready = true;
    wire.ephemeral_msg = this;
    console.log('Extension ready! PeerID:', this.peerId);
    
    // Clear the timeout now that the handshake is successful
    if (wire._pendingTimeout) {
        clearTimeout(wire._pendingTimeout);
        wire._pendingTimeout = null;
    }
    
    if (wire._pendingMessages && wire._pendingMessages.length > 0) {
      console.log(`[Extension] Sending ${wire._pendingMessages.length} queued messages`);
      wire._pendingMessages.forEach(msg => sendPeer(wire, msg));
      wire._pendingMessages = [];
    }
    setTimeout(() => {
      if (!wire.destroyed && this._ready) {
        sendPeer(wire, { type: 'request_posts' });
        console.log('Sent initial request_posts');
      }
    }, 1000);
  };

  EphemeralExtension.prototype.onMessage = function (buf) {
    try {
      const msg = JSON.parse(new TextDecoder().decode(buf));
      console.log('Received message:', msg.type);
      handlePeerMessage(msg, wire);
    } catch (e) {
      console.error('Bad peer message:', e);
    }
  };
  wire.use(EphemeralExtension);
}

async function authenticatePeer(wire, peerId) {
  // Generate challenge
  const challenge = new Uint8Array(32);
  crypto.getRandomValues(challenge);
  const challengeB64 = arrayBufferToBase64(challenge);
  
  // Store challenge for verification
  if (!state.peerChallenges) state.peerChallenges = new Map();
  state.peerChallenges.set(peerId, { challenge: challengeB64, timestamp: Date.now() });
  
  // Send authentication request
  return new Promise((resolve) => {
    const timeout = setTimeout(() => {
      state.peerChallenges.delete(peerId);
      resolve(false);
    }, 10000); // 10 second timeout
    
    sendPeer(wire, {
      type: 'auth_challenge',
      challenge: challengeB64
    });
    
    // Store resolver for when we get response
    state.peerChallenges.get(peerId).resolver = (success) => {
      clearTimeout(timeout);
      resolve(success);
    };
  });
}





async function handlePeerMessage(msg, fromWire) {
  if (msg.msgId && state.seenMessages.has(msg.msgId)) {
    return;
  }
  if (msg.msgId) {
    state.seenMessages.add(msg.msgId);
  }

  const peerId = fromWire.peerId;
  const peerData = state.peers.get(peerId);
  if (peerData) {
    const now = Date.now();
    peerData.messageTimestamps.push(now);
    peerData.messageTimestamps = peerData.messageTimestamps.filter(
      ts => now - ts < CONFIG.RATE_LIMIT_WINDOW
    );
    const rateLimitedMessageTypes = ['new_post', 'parent_update'];
    if (rateLimitedMessageTypes.includes(msg.type)) {
      if (peerData.messageTimestamps.length > CONFIG.RATE_LIMIT_MESSAGES) {
        console.warn(`Rate limit exceeded for peer ${peerId} for message type: ${msg.type}. Dropping message.`);
        return;
      }
    }
  }
  
  if (state.trafficMixer && (msg.type === "new_post" || msg.type === "carrier_update")) {
      state.trafficMixer.addToMixPool(msg, fromWire);
  }

  const handler = messageHandlers.get(msg.type);
  if (handler) {
    await handler(msg, fromWire);
    return;
  }

  switch (msg.type) {
    case "dht_rpc":
      if (state.dht) state.dht.handleRPC(msg, fromWire);
      break;
    case "hyparview":
      if (state.hyparview) state.hyparview.handleMessage(msg, fromWire);
      break;
    case "scribe":
      if (state.scribe) state.scribe.handleMessage(msg, fromWire);
      break;

    case "request_image_chunks":
      if (msg.imageHash && Array.isArray(msg.chunkHashes) && msg.chunkHashes.length <= 100) {
        handleChunkRequest(msg.imageHash, msg.chunkHashes, fromWire);
      }
      break;

    case "chunk_response":
      if (msg.imageHash && msg.chunks) {
        handleChunkResponse(msg);
      }
      break;

    case "peer_exchange":
      if (msg.peers && Array.isArray(msg.peers)) {
        msg.peers.forEach(peerInfo => {
          try {
            let peerId;
            if (typeof peerInfo.id === 'string') {
              peerId = hexToUint8Array(peerInfo.id);
            } else if (peerInfo.id instanceof Uint8Array) {
              peerId = peerInfo.id;
            } else if (peerInfo.id && (peerInfo.id.type === 'Buffer' || peerInfo.id.data)) {
              peerId = new Uint8Array(peerInfo.id.data || peerInfo.id);
            }
            if (peerId && state.dht) {
              // Check if the peer is our own ID. Only perform this check if our identity has been created.
              const isSelf = state.myIdentity && state.dht.uint8ArrayEquals(peerId, state.myIdentity.nodeId);
              
              if (!isSelf) {
                state.dht.addPeer(peerId, { wire: null });
              }
            }
          } catch (e) {
            console.error("Error in peer exchange:", e);
          }
        });
      }
      break;

    case "noise":
      return;

    case "request_image":
      handleImageRequest(msg.imageHash, fromWire);
      break;
    case "image_response":
      handleImageResponse(msg);
      break;

    case "request_posts":
      if (fromWire) {
        const list = [...state.posts.values()].map(p => p.toJSON());
        sendPeer(fromWire, { type: "posts_response", posts: list });
      }
      break;


    case "auth_challenge":
      if (state.myIdentity && state.myIdentity.secretKey) {
        const signature = nacl.sign(
          base64ToArrayBuffer(msg.challenge),
          state.myIdentity.secretKey
        );
        sendPeer(fromWire, {
          type: 'auth_response',
          signature: arrayBufferToBase64(signature),
          handle: state.myIdentity.handle,
          publicKey: state.myIdentity.publicKey
        });
      }
      break;

    case "auth_response":
      const peerId = fromWire.peerId;
      const challenge = state.peerChallenges?.get(peerId);
      if (challenge && msg.signature && msg.publicKey) {
        const verified = nacl.sign.open(
          base64ToArrayBuffer(msg.signature),
          base64ToArrayBuffer(msg.publicKey)
        );
        if (verified && arrayBufferToBase64(verified) === challenge.challenge) {
          // Authentication successful
          const peerData = state.peers.get(peerId);
          if (peerData) {
            peerData.authenticated = true;
            peerData.handle = msg.handle;
            peerData.publicKey = msg.publicKey;
          }
          challenge.resolver(true);
        } else {
          challenge.resolver(false);
        }
        state.peerChallenges.delete(peerId);
      }
      break;
    case "identity_announce":
      if (msg.handle && msg.publicKey && msg.wirePeerId) {
        console.log(`[Network] Received identity announcement from ${msg.handle}`);
        
        // Store the wire-to-handle mapping locally for quick lookups
        if (!state.peerIdentities) state.peerIdentities = new Map();
        state.peerIdentities.set(fromWire.peerId, {
          handle: msg.handle,
          publicKey: msg.publicKey,
          timestamp: Date.now()
        });
        
        // Update the peer data with identity info
        const peerData = state.peers.get(fromWire.peerId);
        if (peerData) {
          peerData.handle = msg.handle;
          peerData.identityVerified = false; // Will verify later
          
          // Verify the identity claim asynchronously
          state.identityRegistry.lookupHandle(msg.handle).then(claim => {
            if (claim && claim.publicKey === msg.publicKey) {
              peerData.identityVerified = true;
              console.log(`[Network] Verified identity for peer ${msg.handle}`);
            }
          });
        }
      }
      break;
    case "dm_delivered":
        if (msg.messageId) {
            console.log(`[DM] Received delivery confirmation for message ${msg.messageId}`);
            getServices().stateManager.markMessageDelivered(msg.messageId);
            
            // Update UI to show delivered status
            notify(`Message to ${msg.recipient} delivered ‚úì`);
        }
        break;
    case "routing_update":
      if (msg.handle && msg.nodeId && msg.peerId && msg.timestamp) {
        console.log(`[Network] Received routing update from ${msg.handle}`);
        
        // Verify the update is recent
        const age = Date.now() - msg.timestamp;
        if (age > 300000) { // 5 minutes
          console.log(`[Network] Ignoring stale routing update (${age}ms old)`);
          break;
        }
        
        // Store in our local routing cache
        if (!state.peerRoutingCache) state.peerRoutingCache = new Map();
        state.peerRoutingCache.set(msg.handle, {
          nodeId: msg.nodeId,
          peerId: msg.peerId,
          timestamp: msg.timestamp,
          publicKey: msg.publicKey,
          fromWire: fromWire.peerId
        });
        
        // Update the DHT if we have it
        if (state.identityRegistry) {
          const routingKey = `routing:${msg.handle.toLowerCase()}`;
          const routingInfo = {
            handle: msg.handle,
            nodeId: msg.nodeId,
            wirePeerId: msg.peerId,
            timestamp: msg.timestamp,
            ttl: 300000
          };
          
          // FIXED: Use proper DHT store method with propagate: false
          state.dht.store(routingKey, routingInfo, { propagate: false })
            .then(() => {
              console.log(`[Network] Stored routing info for ${msg.handle} in local DHT`);
            })
            .catch(e => {
              console.error(`[Network] Failed to store routing info:`, e);
            });
        }
        
        // Update peer identity mapping
        const peerData = state.peers.get(fromWire.peerId);
        if (peerData) {
          peerData.handle = msg.handle;
          peerData.lastRoutingUpdate = Date.now();
        }
      }
      break;

    case "routing_heartbeat":
      if (msg.handle && msg.timestamp) {
        // Update last seen time for this peer's routing
        if (state.peerRoutingCache && state.peerRoutingCache.has(msg.handle)) {
          const cached = state.peerRoutingCache.get(msg.handle);
          cached.lastHeartbeat = Date.now();
        }
        
        // Update peer data
        const peerData = state.peers.get(fromWire.peerId);
        if (peerData) {
          peerData.lastHeartbeat = Date.now();
        }
      }
      break;
  }
}




async function handleImageRequest(imageHash, fromWire) {
    const metadata = getServices().imageStore.images.get(imageHash);
    if (!metadata) {
        console.log(`[ImageRequest] Peer requested image ${imageHash.substring(0, 8)}... but we don't have its metadata.`);
        return;
    }
    console.log(`[ImageRequest] Peer requested image ${imageHash.substring(0, 8)}.... We have metadata and will send available chunks.`);

    const chunks = [];
    for (const chunkMeta of metadata.chunks) {
        const chunkData = getServices().imageStore.chunks.get(chunkMeta.hash);
        if (chunkData) {
            chunks.push({ hash: chunkMeta.hash, data: chunkData });
        } else {
            console.warn(`[ImageRequest] Missing chunk ${chunkMeta.hash.substring(0, 8)}... for image ${imageHash.substring(0, 8)}... that we should have.`);
        }
    }

    sendPeer(fromWire, {
        type: "image_response",
        imageHash: imageHash,
        metadata: metadata,
        chunks: chunks
    });
}

async function handleImageResponse(msg) {
    console.log(`[ImageResponse] Received image response for hash: ${msg.imageHash.substring(0, 8)}...`);
    if (!getServices().imageStore.images.has(msg.imageHash) && msg.metadata) {
        getServices().imageStore.images.set(msg.imageHash, msg.metadata);
    }

    if (msg.chunks && Array.isArray(msg.chunks)) {
        for (const chunk of msg.chunks) {
            if (chunk.hash && chunk.data && !getServices().imageStore.chunks.has(chunk.hash)) {
                // For simplicity, we assume the chunk hash is valid here. A robust implementation would verify it.
                getServices().imageStore.chunks.set(chunk.hash, chunk.data);
            }
        }
    }

    const imageData = await getServices().imageStore.retrieveImage(msg.imageHash);

    if (imageData) {
        // Check if a post was waiting for this image in the verification queue
        const pendingPost = Array.from(state.pendingVerification.values()).find(p => p.imageHash === msg.imageHash);

        if (pendingPost) {
            console.log(`[Image] Found pending post ${pendingPost.id} for received image. Promoting to feed.`);
            pendingPost.imageData = imageData;

            // Perform the final processing steps that were deferred in handleVerificationResults
            if (pendingPost.parentId) {
                const parent = state.posts.get(pendingPost.parentId);
                if (parent) {
                    parent.replies.add(pendingPost.id);
                    pendingPost.depth = Math.min(parent.depth + 1, 5);
                    refreshPost(parent);
                } else {
                    pendingPost.depth = 1;
                }
            }

            state.posts.set(pendingPost.id, pendingPost);
            renderPost(pendingPost); // Render for the first time
            
            // Trigger attestation through registered handler
            const attestationHandler = messageHandlers.get('generate_attestation');
            if (attestationHandler) {
                attestationHandler(pendingPost);
            }

            // Finally, remove it from the pending queue
            state.pendingVerification.delete(pendingPost.id);
            notify(`Added 1 new post (with image)`);
            return; // Exit after handling the pending post
        }

        // Fallback for existing posts that might have been rendered with placeholders
        for (const [id, post] of state.posts) {
            if (post.imageHash === msg.imageHash && !post.imageData) {
                post.imageData = imageData;
                refreshPost(post);
            }
        }
    // Trigger a UI scan for any placeholders that can now be filled ***
    updateProfilePicturesInPosts(); 
    } else {
        // The image is still not complete, request the remaining chunks
        const metadata = getServices().imageStore.images.get(msg.imageHash);
        if (metadata) {
            const missingChunkHashes = metadata.chunks
                .filter(chunkMeta => !getServices().imageStore.chunks.has(chunkMeta.hash))
                .map(chunkMeta => chunkMeta.hash);

            if (missingChunkHashes.length > 0) {
                console.log(`[ImageResponse] Still missing ${missingChunkHashes.length} chunks. Requesting again.`);
                const peers = Array.from(state.peers.values()).slice(0, 3);
                for (const peer of peers) {
                    sendPeer(peer.wire, {
                        type: "request_image_chunks",
                        imageHash: msg.imageHash,
                        chunkHashes: missingChunkHashes
                    });
                }
            }
        }
    }
}

function handleChunkRequest(imageHash, requestedHashes, fromWire) {
    console.log(`[ChunkRequest] Peer requested ${requestedHashes.length} chunks for image ${imageHash.substring(0, 8)}...`);
    
    const chunks = [];
    for (const hash of requestedHashes) {
        const chunk = getServices().imageStore.chunks.get(hash);
        if (chunk) {
            chunks.push({ hash, data: chunk });
        }
    }
    
    if (chunks.length > 0) {
        console.log(`[ChunkRequest] Sending ${chunks.length} chunks for image ${imageHash.substring(0, 8)}...`);
        sendPeer(fromWire, {
            type: "chunk_response",
            imageHash: imageHash,
            chunks: chunks,
            requestId: requestedHashes.requestId
        });
    } else {
        console.log(`[ChunkRequest] No chunks found for image ${imageHash.substring(0, 8)}...`);
    }
}

async function handleChunkResponse(msg) {
    if (!msg || !msg.imageHash || !Array.isArray(msg.chunks)) {
        console.warn("Received an incomplete chunk response, ignoring.");
        return;
    }
    
    console.log(`[ChunkResponse] Received ${msg.chunks.length} chunks for image ${msg.imageHash.substring(0, 8)}...`);
    
    let newChunksCount = 0;
    for (const { hash, data } of msg.chunks) {
        if (!getServices().imageStore.chunks.has(hash)) {
            // Verify chunk hash before storing
            const actualHash = await getServices().imageStore.sha256(data);
            if (actualHash === hash) {
                getServices().imageStore.chunks.set(hash, data);
                newChunksCount++;
                
                // Notify any pending requests via a custom event
                if (msg.requestId) {
                    window.dispatchEvent(new CustomEvent(`chunk_received_${msg.requestId}`, {
                        detail: {
                            chunkHash: hash,
                            imageHash: msg.imageHash
                        }
                    }));
                }
            } else {
                console.warn(`[ChunkResponse] Chunk hash mismatch! Expected ${hash.substring(0, 8)}..., got ${actualHash.substring(0, 8)}...`);
            }
        }
    }
    
    if (newChunksCount > 0) {
        console.log(`[ChunkResponse] Stored ${newChunksCount} new chunks for image ${msg.imageHash.substring(0, 8)}...`);
        
        // Try to retrieve the image now that we have new chunks
        const imageData = await getServices().imageStore.retrieveImage(msg.imageHash);
        if (imageData) {
            // Update all posts that need this image
            for (const [id, post] of state.posts) {
                if (post.imageHash === msg.imageHash && !post.imageData) {
                    post.imageData = imageData;
                    refreshPost(post);
                }
            }
        }
    }
}


// --- EXPORTS ---
// Export the functions that main.js needs to call.
export {
  initNetwork,
  sendPeer,  
  broadcast,
  handlePeerMessage
};


========================================
--- FILE: p2p/noise-generator.js
========================================
import { state } from '../state.js';
import { sendPeer } from './network-manager.js';

export class NoiseGenerator {
  constructor() {
    this.noiseInterval = 10000; // 10 seconds
    this.startNoise();
  }
  
  startNoise() {
   //maintenance loop takes care of this
  }
  
  generateNoise() {
    if (state.peers.size < 2) return;
    
    // Random chance to send noise
    if (Math.random() > 0.3) return;
    
    const peers = Array.from(state.peers.values());
    const randomPeer = peers[Math.floor(Math.random() * peers.length)];
    
    const noiseMsg = {
      type: "noise",
      data: Array(Math.floor(Math.random() * 1024))
        .fill(0)
        .map(() => Math.random().toString(36))
        .join(''),
      timestamp: Date.now()
    };
    
    sendPeer(randomPeer.wire, noiseMsg);
  }
}


========================================
--- FILE: p2p/scribe.js
========================================
import { messageBus } from './message-bus.js';
import { generateId } from '../utils.js';
import { state } from '../state.js';

// --- SCRIBE MULTICAST PROTOCOL ---
export class Scribe {
  constructor(nodeId, dht) {
    this.nodeId = nodeId;
    this.dht = dht;
    
    // Topic management
    this.subscribedTopics = new Map(); // topic -> { rendezvousId, parent, children, lastRefresh }
    this.topicMessages = new Map(); // topic -> recent message IDs (for dedup)
    
    // Protocol parameters
    this.heartbeatInterval = 30000; // 30 seconds
    this.treeRepairTimeout = 60000; // 60 seconds
    this.maxChildren = 16; // Max children per node in multicast tree
    
    // Start maintenance
    this.maintenanceTimer = null;
  }
  
  // Extract topics from post content
    extractTopics(content) {
        const topics = new Set();
        
        // ADDED: Limit content length for regex
        const maxContentLength = 1125;
        const truncatedContent = content.length > maxContentLength 
            ? content.substring(0, maxContentLength) 
            : content;
        
        // Extract hashtags with limits
        const MAX_TOPICS = 10;
        const MAX_TOPIC_LENGTH = 50;
        
        const hashtags = truncatedContent.match(/#\w{1,50}/g) || [];
        
        // ADDED: Limit number of hashtags processed
        hashtags.slice(0, MAX_TOPICS).forEach(tag => {
            const cleaned = tag.toLowerCase();
            if (cleaned.length <= MAX_TOPIC_LENGTH) {
                topics.add(cleaned);
            }
        });
        
        // Extract keywords with same limits
        const keywords = ['tech', 'news', 'art', 'music', 'politics', 
                         'science', 'bitcoin', 'finance', 'war', 'coding', 
                         'computers', 'cryptography', 'cryptocurrency'];
        const contentLower = truncatedContent.toLowerCase();
        
        let keywordsAdded = 0;
        for (const keyword of keywords) {
            if (topics.size >= MAX_TOPICS) break;
            if (contentLower.includes(keyword) && keywordsAdded < 5) {
                topics.add(`#${keyword}`);
                keywordsAdded++;
            }
        }
        
        // PHASE 2: Only add #general if NO other topics were found.
        if (topics.size === 0) {
            topics.add('#general');
        }
        
        return Array.from(topics);
    }
  
  // Get rendezvous node for a topic
  async getRendezvousNode(topic) {
    return await this.dht.hashToNodeId(topic);
  }
  
  //track topics    
    async trackTopicActivity(topic) {
        if (!this.dht) return;
        const key = `topic-activity:${topic}`;
        try {
            const existing = await this.dht.get(key);
            const now = Date.now();
            let score = 1;
            if (existing) {
                // Simple decay: reduce score by half every hour
                const ageHours = (now - existing.lastSeen) / 3600000;
                const decayFactor = Math.pow(0.5, ageHours);
                score = (existing.score * decayFactor) + 1;
            }
            await this.dht.store(key, { score: score, lastSeen: now });
        } catch (e) {
            console.error(`[Scribe] Failed to track activity for topic ${topic}:`, e);
        }
      }
  
  
  // Subscribe to a topic
  async subscribe(topic) {
    if (this.subscribedTopics.has(topic)) return;
    
    console.log(`[Scribe] Subscribing to topic: ${topic}`);
    
    const rendezvousId = await this.getRendezvousNode(topic);
    const topicInfo = {
      rendezvousId,
      parent: null,
      children: new Set(),
      lastRefresh: Date.now()
    };
    
    this.subscribedTopics.set(topic, topicInfo);
    
    // Find route to rendezvous node
    const route = await this.dht.findNode(rendezvousId);
    
    if (route.length === 0) {
      // We are the rendezvous node
      console.log(`[Scribe] We are the rendezvous node for ${topic}`);
      return;
    }
    
    // Send JOIN request along the route
    const nextHop = route[0];
    this.sendJoinRequest(topic, nextHop);
  }
  
  // Unsubscribe from a topic
  unsubscribe(topic) {
    const topicInfo = this.subscribedTopics.get(topic);
    if (!topicInfo) return;
    
    console.log(`[Scribe] Unsubscribing from topic: ${topic}`);
    
    // Notify parent
    if (topicInfo.parent) {
      messageBus.sendPeer(topicInfo.parent.wire, {
        type: 'scribe',
        subtype: 'LEAVE',
        topic,
        childId: this.dht.uint8ArrayToHex(this.nodeId)
      });
    }
    
    // Notify children to find new parent
    topicInfo.children.forEach(child => {
      messageBus.sendPeer(child.wire, {
        type: 'scribe',
        subtype: 'PARENT_FAILED',
        topic
      });
    });
    
    this.subscribedTopics.delete(topic);
    this.topicMessages.delete(topic);
  }
  
  // Send JOIN request
  sendJoinRequest(topic, peer) {
    messageBus.sendPeer(peer.wire, {
      type: 'scribe',
      subtype: 'JOIN',
      topic,
      nodeId: this.dht.uint8ArrayToHex(this.nodeId)
    });
  }
  
  // Handle incoming Scribe messages
  handleMessage(msg, fromWire) {
    switch (msg.subtype) {
      case 'JOIN':
        this.handleJoin(msg, fromWire);
        break;
      case 'LEAVE':
        this.handleLeave(msg, fromWire);
        break;
      case 'MULTICAST':
        this.handleMulticast(msg, fromWire);
        break;
      case 'HEARTBEAT':
        this.handleHeartbeat(msg, fromWire);
        break;
      case 'PARENT_FAILED':
        this.handleParentFailed(msg, fromWire);
        break;
    }
  }
  
  
  
  
  // Handle JOIN request
  async handleJoin(msg, fromWire) {
    const { topic, nodeId } = msg;
    const senderId = this.dht.hexToUint8Array(nodeId);
    
    const topicInfo = this.subscribedTopics.get(topic);
    const rendezvousId = await this.getRendezvousNode(topic);
    
    // Check if we're closer to rendezvous than sender
    const ourDistance = this.dht.distance(this.nodeId, rendezvousId);
    const senderDistance = this.dht.distance(senderId, rendezvousId);
    
    if (!topicInfo && this.compareDistances(ourDistance, senderDistance) > 0) {
      // Forward JOIN to next hop
      const route = await this.dht.findNode(rendezvousId);
      if (route.length > 0) {
        messageBus.sendPeer(route[0].wire, msg);
      }
      return;
    }
    
    // We're on the multicast tree - accept as child
    if (!topicInfo) {
      // Create topic subscription
      this.subscribedTopics.set(topic, {
        rendezvousId,
        parent: null,
        children: new Set(),
        lastRefresh: Date.now()
      });
    }
    
    const info = this.subscribedTopics.get(topic);
    
    if (info.children.size < this.maxChildren) {
      // Accept as child
      info.children.add({
        id: senderId,
        wire: fromWire,
        joinedAt: Date.now()
      });
      
      console.log(`[Scribe] Added child for topic ${topic}. Children: ${info.children.size}`);
      
      // Send acceptance
      messageBus.sendPeer(fromWire, {
        type: 'scribe',
        subtype: 'JOIN_ACK',
        topic
      });
    } else {
      // Reject - tree node full
      messageBus.sendPeer(fromWire, {
        type: 'scribe',
        subtype: 'JOIN_REJECT',
        topic
      });
    }
  }
  
  // Compare two distances
  compareDistances(dist1, dist2) {
    for (let i = 0; i < dist1.length; i++) {
      if (dist1[i] !== dist2[i]) {
        return dist1[i] - dist2[i];
      }
    }
    return 0;
  }
  
  // Handle LEAVE message
  handleLeave(msg, fromWire) {
    const { topic, childId } = msg;
    const topicInfo = this.subscribedTopics.get(topic);
    
    if (!topicInfo) return;
    
    // Remove child
    topicInfo.children = new Set(
      Array.from(topicInfo.children).filter(
        child => this.dht.uint8ArrayToHex(child.id) !== childId
      )
    );
    
    console.log(`[Scribe] Child left topic ${topic}. Children: ${topicInfo.children.size}`);
  }
  
  // Multicast a message to a topic
  async multicast(topic, message) {
    const topicInfo = this.subscribedTopics.get(topic);
    if (!topicInfo) {
      // Not subscribed - route to rendezvous
      const rendezvousId = await this.getRendezvousNode(topic);
      const route = await this.dht.findNode(rendezvousId);
      if (route.length > 0) {
        messageBus.sendPeer(route[0].wire, {
          type: 'scribe',
          subtype: 'MULTICAST',
          topic,
          message,
          messageId: generateId(),
          origin: this.dht.uint8ArrayToHex(this.nodeId)
        });
      }
      return;
    }
    
    // We're on the tree - disseminate
    const messageId = generateId();
    this.disseminateMessage(topic, message, messageId, null);
  }
  
  // Disseminate message down the tree
  disseminateMessage(topic, message, messageId, fromWire) {
    const topicInfo = this.subscribedTopics.get(topic);
    if (!topicInfo) return;
    
    // Check for duplicate
    let recentMessages = this.topicMessages.get(topic);
    if (!recentMessages) {
      recentMessages = new Set();
      this.topicMessages.set(topic, recentMessages);
    }
    
    if (recentMessages.has(messageId)) return;
    recentMessages.add(messageId);
    
    // Clean old messages
    if (recentMessages.size > 1000) {
      const arr = Array.from(recentMessages);
      arr.slice(0, 500).forEach(id => recentMessages.delete(id));
    }
    
    // Forward to parent (if not from parent)
    if (topicInfo.parent && topicInfo.parent.wire !== fromWire) {
      messageBus.sendPeer(topicInfo.parent.wire, {
        type: 'scribe',
        subtype: 'MULTICAST',
        topic,
        message,
        messageId
      });
    }
    
    // Forward to children (except sender)
    topicInfo.children.forEach(child => {
      if (child.wire !== fromWire && !child.wire.destroyed) {
        messageBus.sendPeer(child.wire, {
          type: 'scribe',
          subtype: 'MULTICAST',
          topic,
          message,
          messageId
        });
      }
    });
    
    // Deliver locally
    this.deliverMessage(topic, message);
  }
  
  // Handle multicast message
  handleMulticast(msg, fromWire) {
    const { topic, message, messageId } = msg;
    this.trackTopicActivity(topic);
    this.disseminateMessage(topic, message, messageId, fromWire);
  }
  
  // Deliver message to local application
deliverMessage(topic, message) {
    // This function is the endpoint for messages received via Scribe multicast.
    // It's responsible for handing off the message to the main application logic.
    if (!message || !message.type) return;

    console.log(`[Scribe] Delivering message of type "${message.type}" on topic ${topic}`);

    try {
        if (message.type === 'new_post' && message.post) {
            // Don't process our own posts that have been echoed back to us
            if (message.post.author === state.myIdentity.handle) return;
            messageBus.handleMessage('scribe:new_post', { topic, message }, null);
        } else if (message.type === 'PROFILE_UPDATE') {
            messageBus.handleMessage('scribe:PROFILE_UPDATE', { topic, message }, null);
        } else if (message.type === 'parent_update') {
            messageBus.handleMessage('scribe:parent_update', { topic, message }, null);
        }
    } catch (e) {
        console.error(`[Scribe] Error delivering message of type ${message.type}:`, e);
    }
}
  
  // Start maintenance tasks
  startMaintenance() {
    this.maintenanceTimer = setInterval(() => {
      this.sendHeartbeats();
      this.checkTreeHealth();
    }, this.heartbeatInterval);
  }
  
  // Send heartbeats to children
  sendHeartbeats() {
    this.subscribedTopics.forEach((info, topic) => {
      info.children.forEach(child => {
        if (!child.wire.destroyed) {
          messageBus.sendPeer(child.wire, {
            type: 'scribe',
            subtype: 'HEARTBEAT',
            topic
          });
        } else {
          // Remove dead child
          info.children.delete(child);
        }
      });
    });
  }
  
  // Check tree health
  checkTreeHealth() {
    const now = Date.now();
    
    this.subscribedTopics.forEach((info, topic) => {
      // Check if parent is still alive
      if (info.parent && now - info.lastRefresh > this.treeRepairTimeout) {
        console.log(`[Scribe] Parent timeout for topic ${topic}, repairing...`);
        this.repairTree(topic);
      }
    });
  }
  
  // Handle heartbeat
  handleHeartbeat(msg, fromWire) {
    const { topic } = msg;
    const topicInfo = this.subscribedTopics.get(topic);
    
    if (topicInfo && topicInfo.parent && topicInfo.parent.wire === fromWire) {
      topicInfo.lastRefresh = Date.now();
    }
  }
  
  // Handle parent failure
  handleParentFailed(msg, fromWire) {
    const { topic } = msg;
    this.repairTree(topic);
  }
  
  // Repair tree after parent failure
  repairTree(topic) {
    const topicInfo = this.subscribedTopics.get(topic);
    if (!topicInfo) return;
    
    topicInfo.parent = null;
    
    // Re-subscribe
    this.subscribe(topic);
  }
  
  // Get statistics
  getStats() {
    const stats = {
      subscribedTopics: this.subscribedTopics.size,
      totalChildren: 0,
      topics: []
    };
    
    this.subscribedTopics.forEach((info, topic) => {
      stats.totalChildren += info.children.size;
      stats.topics.push({
        topic,
        children: info.children.size,
        hasParent: !!info.parent
      });
    });
    
    return stats;
  }
  


      
  // Cleanup on shutdown
  destroy() {
    if (this.maintenanceTimer) {
      clearInterval(this.maintenanceTimer);
    }
    
    // Unsubscribe from all topics
    Array.from(this.subscribedTopics.keys()).forEach(topic => {
      this.unsubscribe(topic);
    });
  }  
  
}


========================================
--- FILE: p2p/traffic-mixer.js
========================================
import { sendPeer } from './network-manager.js';

export class TrafficMixer {
  constructor() {
    this.mixPool = [];
    this.mixInterval = 5000; // 5 seconds
    this.startMixing();
  }
  
  addToMixPool(msg, wire) {
    this.mixPool.push({ msg, wire, timestamp: Date.now() });
    
    // Limit pool size
    if (this.mixPool.length > 50) {
      this.mixPool.shift();
    }
  }
  
  startMixing() {
    //maintenance loop takes care of this
  }
  
  mix() {
    if (this.mixPool.length < 3) return;
    
    // Shuffle and send random messages
    const shuffled = [...this.mixPool].sort(() => Math.random() - 0.5);
    const toSend = shuffled.slice(0, Math.min(3, shuffled.length));
    
    toSend.forEach(({ msg, wire }) => {
      // Remove from pool
      const index = this.mixPool.indexOf(msg);
      if (index > -1) this.mixPool.splice(index, 1);
      
      // Send with random delay
      setTimeout(() => {
        if (!wire.destroyed) sendPeer(wire, msg);
      }, Math.random() * 1000);
    });
  }
}


========================================
--- FILE: services/callbacks.js
========================================
// services/callbacks.js
export const serviceCallbacks = {
  debugPostRemoval: null,
  dropPost: null,
  notify: null,
  renderPost: null,
  broadcastProfileUpdate: null,
  initializeUserProfileSection: null
};

export function setServiceCallbacks(callbacks) {
  Object.assign(serviceCallbacks, callbacks);
}


========================================
--- FILE: services/content-safety-lite.js
========================================
// services/content-safety.js
/**
 * Enterprise-grade Content Safety System
 * * Features:
 * - Multi-layered pattern matching with complexity analysis
 * - Advanced obfuscation detection (leetspeak, unicode, spacing, etc.)
 * - Context-aware analysis with sliding windows
 * - Multilingual harmful content detection
 * - Behavioral pattern recognition
 * - Performance optimized with caching and early exits
 * - Comprehensive logging and metrics
 * - Configurable severity thresholds
 * * @version 2.5.2 (Patched)
 * @license GPL
 */

import { NaiveBayesClassifier } from './naive-bayes-classifier.js';

export class ContentSafetySystem {
  constructor(config = {}) {
    // Configuration
    this.config = {
      maxTextLength: config.maxTextLength || 10000,
      cacheSize: config.cacheSize || 1000,
      enableMetrics: config.enableMetrics !== false,
      enableContextAnalysis: config.enableContextAnalysis !== false,
      customPatterns: config.customPatterns || {},
      severityThresholds: {
        critical: 1.0,
        high: 0.8,
        medium: 0.6,
        low: 0.4,
        ...config.severityThresholds
      },
       // If the model is >90% sure something is not_safe, it can influence the decision.
      nbcBlockThreshold: config.nbcBlockThreshold || 0.90
    };
    
    // Performance cache
    this.cache = new Map();
    this.cacheHits = 0;
    this.cacheMisses = 0;
    
    // Metrics
    this.metrics = {
      totalChecks: 0,
      blockedContent: 0,
      detectionsByCategory: new Map(),
      averageCheckTime: 0,
      obfuscationAttempts: 0
    };
    
    // Initialize pattern database
    this.initializePatterns();
    
    // Pre-compile all regex patterns for performance
    this.compiledPatterns = this.compilePatterns();

   // Initialize and load the pre-trained Naive Bayes Classifier model.
    this.classifier = new NaiveBayesClassifier();
    this.classifier.loadModel();

    // Initialize normalizers
    this.initializeNormalizers();
  }
  
  initializePatterns() {
    // Critical harm patterns - immediate threats to safety
    this.harmPatterns = {
      critical: {
        // Child safety - highest priority
        csam: {
          patterns: [
            /(cp|csam|csa|child[\s_-]*(porn|sex|abuse|exploitation)|child\s*sexual\s*abuse)/i,
            /(pedo|paedo|p3do|ped0|map|nop)|pthc/i,
            /(lo+l+i+|shota|cub|toddlercon|babycon|prete?en|under[-\s]*age|jail\s*bait)/i,
            /(minor|kid|child)[\s\S]{0,25}(sex|nude|porn|pics?|vids?|naked|rape|abuse)/i,
            /\d{1,2}\s*(yo|yrs?|year[-\s]*old)[\s\S]{0,25}(nudes?|sex|porn|pics?|vids?)/i,
            /(toddler|infant|baby)[\s\S]{0,25}(sex|abuse|rape|molest)/i,
            /(she|he|they)\s*(is|are)\s*(a|an)?\s*(underage|minor|child|kid)\s*(girl|boy|child)?/i
          ],
          contextRules: {
            requiresContext: false,
            falsePositiveKeywords: ['report', 'news', 'arrest', 'convicted']
          }
        },
        
        // Imminent violence/terrorism
        terrorism: {
          patterns: [
            /(make|build|assemble|cook|mix|prepare)[\s\S]{0,30}(bomb|ied|pipe[\s_-]*bomb|molotov|napalm|explosive|device|detonator)/i,
            /(terror|terrorist|extremist|jihad)[\s\S]{0,25}(attack|plan|manual|guide|training|recruit|cell)/i,
            /(isis|daesh|al[-\s]*qaeda|taliban|al[-\s]*shabaab|hamas|hezbollah)[\s\S]{0,25}(join|contact|pledge|bayat|support)/i,
            /(suicide|mass|school|car|truck|church|synagogue)[\s\S]{0,20}(bomb|attack|shoot(?:ing)?|massacre)/i,
            /(how\s*to|guide|tutorial|recipe)[\s\S]{0,25}(make|build|synthesize)[\s\S]{0,25}(ricin|sarin|anthrax|chloroform|tnt|black\s*powder|nitro(?:glycerin)?)/i,
            /how\s+to.{0,20}(bomb|poison|kill\s+many)/i,
            /(?:how\s*to\s*)?(?:make|build|create|construct)\s*(?:a\s*)?b[o0]m[b8]/i,
            /(ricin|sarin|anthrax).{0,20}(make|create|obtain)/i,
            /(blueprint|schematic|formula)[\s\S]{0,25}(bomb|weapon|explosive)/i
          ],
          contextRules: {
            requiresContext: true,
            exceptions: ['news', 'history', 'fiction', 'game']
          }
        },
        
        // Doxxing/Privacy violations
        doxxing: {
          patterns: [
            /(dox+x?ing?|swat(?:ting)?|drop(?:pin[g]?|ping)?\s*docs?)/i,
            /(real|home|personal|private|current|exact)\s*(address|add\.?|location|loc|coords?)/i,
            /(leak(?:ed)?|reveal(?:ed)?|expose(?:d)?|publish(?:ed)?)[\s\S]{0,20}(address|phone|number|email|info|docs?)/i,
            /\b\d{3}[-.\s]?\d{2}[-.\s]?\d{4}\b/, // SSN
            /(?:\+?1\s*[-.\s]?)?\(?\d{3}\)?[-.\s]?\d{3}[-.\s]?\d{4}/, // Phone Number
            /\b[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}\b/i, // Email
            /\b\d{1,5}\s+[\w\s]{1,50}\s+(street|st|avenue|ave|road|rd|lane|ln|drive|dr|court|ct|plaza|blvd)\b/i,
            /\b(apt|apartment|unit|suite|#)\s*\d+\b/i,
            /\b\d{5}(?:-\d{4})?\b/, // ZIP code
            /\b(lat|latitude|long|longitude)\s*:?\s*-?\d+\.\d+\b/i
          ],
           contextRules: {
             requiresContext: true,
             mustInclude: ['address', 'street', 'location', 'zip', 'city', 'state', 'phone', 'email', 'ssn', 'coordinates']
           }
        }
      },
      
      high: {
        // Direct threats
        threats: {
          patterns: [
            /(k[i!Œπ1]ll|khyll|murder|slaughter|eliminate|erase|shoot|stab|strangle|decapitate|behead|burn|torch).{0,25}(you|u|ur|ya|your|family|kin|kids)/i,
            /(i['‚Äô]m\s*going\s*to|i\s*will|gonna|about\s*to|fixin(?:g)?\s*to).{0,25}(kill|hurt|beat|break|mess\s*you\s*up|ruin|destroy|shoot)/i,
            /(you['‚Äô]ll|you\s*will|you['‚Äô]re\s*going\s*to).{0,25}(die|bleed|suffer|pay|regret)/i,
            /(find|track|hunt|locate|trace).{0,25}(you|u|ya).{0,25}(down|irl|soon|tonight)/i,
            /watch.{0,20}(your|ur).{0,20}back/i,
            /(burn|firebomb).{0,25}(house|home|car)/i,
            /(fuck|rape|sexual(?:ly)?\sassault).{0,25}(you|ya|ur|your)/i
          ],
          contextRules: {
            intensifiers: ['definitely', 'literally', 'actually', 'really'],
            mitigators: ['game', 'movie', 'book', 'joke', 'meme'],
            neverMitigate: true
          }
        },
        
        // Self-harm
        selfharm: {
          patterns: [
            /(kill|end|take).{0,20}(myself|my\s*life|own\s*life)/i,
            /(cut|harm|hurt).{0,20}(myself|self)/i,
            /suicid(e|al)/i,
            /(want|going|planning).{0,20}die/i,
            /(method|way|how).{0,20}(suicide|kill\s*myself)/i,
            /(bridge|cliff|building).{0,20}(jump|leap)/i,
            /(overdose|od|pills).{0,20}(take|swallow)/i,
            /(kys|kill\s*yourself|end\s*yourself)/i, 
          ],
          contextRules: {
            supportPhrases: ['help', 'hotline', 'support', 'prevention'],
            requiresPersonalContext: true
          }
        },
        
        // Illegal markets
        illegal_trade: {
          patterns: [
            /(sell|buy|deal).{0,20}(meth|cocaine|heroin|fentanyl|mdma|lsd)/i,
            /(drug|narcotics).{0,20}(dealer|supplier|plug)/i,
            /(weapon|gun|firearm).{0,20}(sell|buy|illegal)/i,
            /(fake|forged).{0,20}(passport|id|document)/i,
            /(credit\s*card|cc).{0,20}(dump|fullz|cvv)/i,
            /(hitman|assassin|killer).{0,20}(hire|need|contact)/i,
            /dark\s*web.{0,20}(market|vendor|link)/i
          ],
          contextRules: {
            transactionWords: ['bitcoin', 'crypto', 'payment', 'escrow', 'ship']
          }
        },
        
        financial_scams: {
          patterns: [
            /(wire|send|transfer)\s*(money|funds|bitcoin|crypto)/i,
            /(nigerian?\s*prince|inheritance|lottery\s*win)/i,
            /your\s*(account|card)\s*(has\s*been|was)\s*(compromised|hacked)/i,
            /click\s*here\s*to\s*(verify|confirm|secure)/i,
            /(irs|tax)\s*(fraud|evasion|warrant)/i,
            /gift\s*card\s*(payment|number|code)/i
          ],
          contextRules: {
            requiresContext: true,
            transactionWords: ['payment', 'urgent', 'immediately', 'expire']
          }
        },

        sextortion: {
          patterns: [
            /i\s*have\s*(your|compromising)\s*(video|photos?|pictures?)/i,
            /(pay|send)\s*(me|bitcoin|money)\s*or\s*i['ll\s]*(share|post|send)/i,
            /your\s*(webcam|camera)\s*was\s*(hacked|compromised)/i,
            /i\s*know\s*your\s*password/i,
            /(share|send)\s*this\s*to\s*(your|all)\s*(contacts|friends|family)/i
          ],
          contextRules: {
            requiresContext: true,
            threatIndicators: ['bitcoin', 'payment', 'hours', 'deadline']
          }
        }
        
      },
      
      medium: {
        // Hate speech with context
        hate_speech: {
          patterns: [
            /(nigger|nigga|n\*{4}r|faggot|fag|kike|spic|chink|gook|wetback|towelhead|tranny|slut|whore|bitch|cunt|skag|skank|nigg|niggs|nigs|poof|poofter|poofta)/i,
            /(all|every).{0,20}(blacks|whites|jews|muslims|christians|gays|hindus|indians|africans).{0,20}(should|must|need)/i,
            /(holocaust|slavery).{0,20}(good|deserved|fake|hoax)/i,
            /(hitler|nazi).{0,20}(right|correct|good)/i,
            /(jews|jew|jewish).{0,20}(right|correct|good)/i,
            /(arab|arabs|muslims|islam).{0,20}(right|correct|good)/i,
            /(gas|burn|lynch).{0,20}(whites|browns|arabs|muslims|christians|straights|bisexuals|jews|blacks|gays|hindus)/i
          ],
          contextRules: {
            educationalContext: ['history', 'education', 'documentary', 'quoting'],
          }
        },
        
        // Targeted harassment
        harassment: {
          patterns: [
            /(kys|kill\s*yourself|end\s*yourself)/i,
            /(retard|retarded|autist|autistic).{0,20}(you|u\s*r|dumb)/i,
            /(ugly|fat|disgusting).{0,20}(bitch|whore|slut)/i,
            /(rope|neck|hang).{0,20}yourself/i,
            /no\s*one.{0,20}(likes|loves|wants).{0,20}you/i,
            /(worthless|useless|waste).{0,20}(life|space|person)/i
          ],
          contextRules: {
            targetRequired: true,
            multipleViolations: 2 // Requires 2+ patterns for medium severity
          }
        }
      },
      
      low: {
        // Spam patterns
        spam: {
          patterns: [
            /(click|visit|check\s*out).{0,20}(link|site|here)/i,
            /(earn|make).{0,20}\$\d+.{0,20}(day|hour|week)/i,
            /(viagra|cialis|pills).{0,20}(cheap|discount|sale)/i,
            /(crypto|bitcoin|nft).{0,20}(pump|moon|10x)/i,
            /(.)\1{10,}/, // Character spam
            /[A-Z\s]{20,}/, // CAPS spam
            /(\b\w{4,}\b)(?=.*?\1.*?\1.*?\1)/i, // A word of 4+ chars repeated at least 4 times
          ],
          contextRules: {
            urlDensity: 0.05, // More than 5% URLs
            repetitionThreshold: 5
          }
        }
      }
    };
    
    // Evasion technique patterns
    this.evasionPatterns = {
      leetspeak: {
        advanced: {
          'a': ['@', '4', '–î', 'Œ±', '–∞', 'ƒÖ', '√§', '√¢', '√†', '√°', '¬™'],
          'e': ['3', '‚Ç¨', '—î', 'Œµ', '–µ', '—ë', 'ƒô', '√´', '√™', '√®', '√©'],
          'i': ['1', '!', '|', '—ñ', '√Ø', '√Æ', '√¨', '√≠', 'ƒ±'],
          'o': ['0', '()','[]', '–æ', '√∏', '√∂', '√¥', '√≤', '√≥', '¬∫'],
          's': ['5', '$', 'z', '—ï', '≈ü', '≈õ', '≈°'],
          't': ['7', '+', '‚Ä†', '—Ç', '≈•', '≈£'],
          'u': ['¬µ', '√º', '√ª', '√π', '√∫', '≈´'],
          'c': ['(', '<', '¬©', '√ß', 'ƒç', 'ƒá'],
          'n': ['–ò', 'œÄ', '√±', '≈à', '≈Ñ']
        }
      },
      
      spacing: {
        patterns: [
          /(\w)\s+(\w)/g, // Extra spaces
          /(\w)\.+(\w)/g, // Dot separation
          /(\w)_+(\w)/g,  // Underscore separation
          /(\w)-+(\w)/g,  // Dash separation
        ]
      },
      
      reversal: {
        check: async (text) => {
          const reversed = text.split('').reverse().join('');
          return await this.checkContent(reversed, { skipCache: true, skipReversal: true });
        }
      },
      
      zalgo: {
        pattern: /[\u0300-\u036f\u0483-\u0489\u1dc0-\u1dff\u20d0-\u20ff\ufe20-\ufe2f]/g
      }
    };
    
    if (this.config?.customPatterns) {
     for (const [name, cfg] of Object.entries(this.config.customPatterns)) {
      const sev = (cfg.severity || 'medium').toLowerCase();
        if (!this.harmPatterns[sev]) this.harmPatterns[sev] = {};
       this.harmPatterns[sev][name] = {
         patterns: cfg.patterns || [],
         contextRules: cfg.contextRules || {},
        };
      }
    }
    
    
    // Contextual rules
    this.contextRules = {
      quotation: /["'`"""''‚Äö‚Äû¬´¬ª‚Äπ‚Ä∫„Äå„Äç„Äé„Äè„Äê„Äë„Äî„Äï„Äà„Äâ„Ää„Äã]/,
      educational: /\b(study|research|paper|article|essay|report|teach|learn|history|education)\b/i,
      news: /\b(news|report|journalism|article|breaking|update|according\s*to)\b/i,
      fiction: /\b(story|novel|book|character|fiction|fantasy|movie|film|game)\b/i,
      support: /\b(help|support|hotline|crisis|therapy|counseling|prevention)\b/i
    };
    
    
  }
  
  initializeNormalizers() {
    // Unicode normalizations map
    this.unicodeMap = new Map();
    
    // Build comprehensive unicode normalization map
    const addMapping = (normalized, ...variants) => {
      variants.forEach(v => this.unicodeMap.set(v, normalized));
    };

    
    
    // Latin variants
    addMapping('a', '√†', '√°', '√¢', '√£', '√§', '√•', 'ƒÅ', 'ƒÉ', 'ƒÖ', '«é', '«ü', '«°', '«ª', '»Å', '»É', '»ß', '…ê', '…ë', '…í', 'Œ±', '–∞');
    addMapping('b', '·∏É', '·∏Ö', '·∏á', '∆Ä', '∆É', '…ì', 'Œ≤', '–≤', 'œê', '·µá', '·µù', '·∂Ä');
    addMapping('c', '√ß', 'ƒá', 'ƒâ', 'ƒã', 'ƒç', '∆à', '…î', '‚ÜÑ', '—Å', 'œ≤', '·∂ú');
    addMapping('d', 'ƒè', 'ƒë', '·∏ã', '·∏ç', '·∏è', '·∏ë', '·∏ì', '…ñ', '…ó', '·µà', '·∂Å', '·∂ë', '–¥');
    addMapping('e', '√®', '√©', '√™', '√´', 'ƒì', 'ƒï', 'ƒó', 'ƒô', 'ƒõ', '«ù', '…ò', '…õ', 'Œµ', '–µ', '—ë', '—ç', '—î');
    addMapping('f', '·∏ü', '∆í', '·µÆ', '·∂Ç', '·∂†', 'œÜ', '—Ñ');
    addMapping('g', 'ƒù', 'ƒü', 'ƒ°', 'ƒ£', '«ß', '«µ', '…†', '…°', '·µç', '·∂É', '·∂¢', '–≥', '“ë');
    addMapping('h', 'ƒ•', 'ƒß', '·∏£', '·∏•', '·∏ß', '·∏©', '·∏´', '…¶', '…ß', '·¥¥', ' ∞', '·∂£', '–Ω');
    addMapping('i', '√¨', '√≠', '√Æ', '√Ø', 'ƒ©', 'ƒ´', 'ƒ≠', 'ƒØ', 'ƒ±', '«ê', '…®', '…©', '…™', 'Œπ', '—ñ', '—ó', 'y','Œπ'); 
    addMapping('j', 'ƒµ', '«∞', '…â', ' ù', '‚±º', '·∂°', '·∂®', '–π', '—ò');
    addMapping('k', 'ƒ∑', 'ƒ∏', '«©', '·∏±', '·∏≥', '·∏µ', '∆ô', '‚±™', '·µè', '·∂Ñ', 'Œ∫', '–∫');
    addMapping('l', 'ƒ∫', 'ƒº', 'ƒæ', '≈Ä', '≈Ç', '·∏∑', '·∏π', '·∏ª', '·∏Ω', '‚Ñì', ' ü', 'À°', '·¥∏', '·∂´', '–ª');
    addMapping('m', '·∏ø', '·πÅ', '·πÉ', '…±', '·µê', '·¥π', '·∂¨', '–º', 'Œº');
    addMapping('n', '√±', '≈Ñ', '≈Ü', '≈à', '≈ã', '·πÖ', '·πá', '·πâ', '·πã', '…≤', '…≥', '·¥∫', '‚Åø', '·∂Æ', '·∂Ø', '·∂∞', '–Ω', 'Œ∑', 'ŒΩ');
    addMapping('o', '√≤', '√≥', '√¥', '√µ', '√∂', '√∏', '≈ç', '≈è', '≈ë', '«í', '«´', '«≠', '…µ', 'Œø', '–æ', '”©', '·µí', '·¥º', '·∂±','Œø');
    addMapping('p', '·πï', '·πó', '∆•', '·µñ', '·¥æ', '·µΩ', '·∂à', 'œÄ', '–ø', 'œÅ');
    addMapping('q', '…ã', ' †', '·µ†', '·∂ê', '‘õ');
    addMapping('r', '≈ï', '≈ó', '≈ô', '·πô', '·πõ', '·πù', '·πü', '»ë', '»ì', '…ç', '…π', '…ª', ' ≥', '·¥ø', '·µ£', '·∂â', '–≥', '—è');
    addMapping('s', '≈õ', '≈ù', '≈ü', '≈°', '»ô', '·π°', '·π£', '·π•', '·πß', '·π©', ' Ç', 'À¢', '·îÜ', '·µ¥', '·∂ä', '—ï', '—Å');
    addMapping('t', '≈£', '≈•', '≈ß', '·π´', '·π≠', '·πØ', '·π±', '·∫ó', '∆≠', ' à', '·¥õ', '·µó', '·µÄ', '·∂µ', '—Ç', 'œÑ');
    addMapping('u', '√π', '√∫', '√ª', '√º', '≈©', '≈´', '≈≠', '≈Ø', '≈±', '≈≥', '«î', '«ñ', '«ò', '«ö', '«ú', '»ï', '»ó', ' â', '·µò', '·µ§', '·∂∂', '—É', '—Ü', 'Œº');
    addMapping('v', '·πΩ', '·πø', ' ã', '·µõ', '·µ•', '·∂π', 'ŒΩ', '–≤');
    addMapping('w', '≈µ', '·∫Å', '·∫É', '·∫Ö', '·∫á', '·∫â', '·∫ò', '·¥°', ' ∑', '·µÇ', '·∂≠', 'œâ', '—à', '—â');
    addMapping('x', '·∫ã', '·∫ç', '·µ°', '·∂ç', 'œá', '—Ö', '√ó');
    addMapping('y', '√Ω', '√ø', '≈∑', '»≥', '·∫è', '·∫ô', '·ª≥', '·ªµ', '·ª∑', '·ªπ', ' ∏', '·µû', '·∂å', '—É', '“Ø', '·Éß');
    addMapping('z', '≈∫', '≈º', '≈æ', '·∫ë', '·∫ì', '·∫ï', '∆∂', ' ê', ' ë', '·¥¢', '·µ∂', '·∂ª', '–∑', 'Œ∂');
    
    // Number substitutions
    addMapping('0', '–û', '–æ', 'Œü', 'Œø', 'O', 'o', '‡•¶', '‡ß¶', '‡©¶', '‡´¶', '‡≠¶', '‡Ø¶', '‡∞Ç', '‡±¶', '‡≥¶', '‡¥†', '‡µ¶', '‡πê', '‡ªê', '·ÅÄ', '‡º†');
    addMapping('1', 'I', 'l', '|', 'ƒ±', '…™', '¬π', '‚ÇÅ', '‡•ß', '‡ßß', '‡©ß', '‡´ß', '‡≠ß', '‡Øß', '‡±ß', '‡≥ß', '‡µß', '‡πë', '‡ªë', '·ÅÅ', '‡º°');
    addMapping('2', '∆ª', '¬≤', '‚ÇÇ', '‡•®', '‡ß®', '‡©®', '‡´®', '‡≠®', '‡Ø®', '‡±®', '‡≥®', '‡µ®', '‡πí', '‡ªí', '·ÅÇ', '‡º¢');
    addMapping('3', '∆∑', ' í', '–ó', '–∑', '¬≥', '‚ÇÉ', '‚Ñ®', '‚Ñ§', '‡•©', '‡ß©', '‡©©', '‡´©', '‡≠©', '‡Ø©', '‡±©', '‡≥©', '‡µ©', '‡πì', '‡ªì', '·ÅÉ', '‡º£');
    addMapping('4', '–ß', '—á', '‚Å¥', '‚ÇÑ', '‡•™', '‡ß™', '‡©™', '‡´™', '‡≠™', '‡Ø™', '‡±™', '‡≥™', '‡µ™', '‡πî', '‡ªî', '·ÅÑ', '‡º§');
    addMapping('5', 'S', 's', '‚Åµ', '‚ÇÖ', '‡•´', '‡ß´', '‡©´', '‡´´', '‡≠´', '‡Ø´', '‡±´', '‡≥´', '‡µ´', '‡πï', '‡ªï', '·ÅÖ', '‡º•');
    addMapping('6', '–±', '‚Å∂', '‚ÇÜ', '‡•¨', '‡ß¨', '‡©¨', '‡´¨', '‡≠¨', '‡Ø¨', '‡±¨', '‡≥¨', '‡µ¨', '‡πñ', '‡ªñ', '·ÅÜ', '‡º¶');
    addMapping('7', '‚Å∑', '‚Çá', '‡•≠', '‡ß≠', '‡©≠', '‡´≠', '‡≠≠', '‡Ø≠', '‡±≠', '‡≥≠', '‡µ≠', '‡πó', '‡ªó', '·Åá', '‡ºß');
    addMapping('8', '‚Å∏', '‚Çà', '‡•Æ', '‡ßÆ', '‡©Æ', '‡´Æ', '‡≠Æ', '‡ØÆ', '‡±Æ', '‡≥Æ', '‡µÆ', '‡πò', '‡ªò', '·Åà', '‡º®');
    addMapping('9', '‚Åπ', '‚Çâ', '‡•Ø', '‡ßØ', '‡©Ø', '‡´Ø', '‡≠Ø', '‡ØØ', '‡±Ø', '‡≥Ø', '‡µØ', '‡πô', '‡ªô', '·Åâ', '‡º©');

    //other
    addMapping('k', 'ƒ∑', 'ƒ∏', '«©', '·∏±', '·∏≥', '·∏µ', '∆ô', '‚±™', '·µè', '·∂Ñ', 'Œ∫', '–∫', '“°', '“õ');
    addMapping('l', 'ƒ∫', 'ƒº', 'ƒæ', '≈Ä', '≈Ç', '·∏∑', '·∏π', '·∏ª', '·∏Ω', '‚Ñì', ' ü', 'À°', '·¥∏', '·∂´', '–ª', '”Ü');
    addMapping('u', '√π', '√∫', '√ª', '√º', '≈©', '≈´', '≈≠', '≈Ø', '≈±', '≈≥', '«î', '«ñ', '«ò', '«ö', '«ú', '»ï', '»ó', ' â', '·µò', '·µ§', '·∂∂', '—É', '—Ü', 'Œº', '¬µ');
    addMapping('y', '√Ω', '√ø', '≈∑', '»≥', '·∫è', '·∫ô', '·ª≥', '·ªµ', '·ª∑', '·ªπ', ' ∏', '·µû', '·∂å', '—É', '“Ø', '·Éß', '¬•');
    addMapping('o', '√≤', '√≥', '√¥', '√µ', '√∂', '√∏', '≈ç', '≈è', '≈ë', '«í', '«´', '«≠', '…µ', 'Œø', '–æ', '”©', '·µí', '·¥º', '·∂±', '√∏');

    // Build reverse mapping for efficiency
    this.reverseUnicodeMap = new Map();
    for (const [variant, normalized] of this.unicodeMap) {
      if (!this.reverseUnicodeMap.has(normalized)) {
        this.reverseUnicodeMap.set(normalized, []);
      }
      this.reverseUnicodeMap.get(normalized).push(variant);
    }
  }
  
compilePatterns() {
  console.log('[ContentSafety] Starting pattern compilation...');
  const compiled = new Map();

  // First, verify harmPatterns exists
  if (!this.harmPatterns) {
    console.error('[ContentSafety] ERROR: harmPatterns is undefined!');
    return compiled;
  }

  for (const [severity, categories] of Object.entries(this.harmPatterns)) {
    console.log(`[ContentSafety] Compiling severity: ${severity}`);
    compiled.set(severity, new Map());

    if (!categories || typeof categories !== 'object') {
      console.error(`[ContentSafety] Invalid categories for ${severity}:`, categories);
      continue;
    }

    for (const [category, config] of Object.entries(categories)) {
      console.log(`[ContentSafety]   Compiling category: ${category}`);
      if (!config) {
        console.error(`[ContentSafety] Config is undefined for ${severity}.${category}`);
        continue;
      }

      if (!config.patterns) {
        console.error(`[ContentSafety] No patterns array for ${severity}.${category}`);
        compiled.get(severity).set(category, {
          patterns: [],
          contextRules: config.contextRules || {}
        });
        continue;
      }

      if (!Array.isArray(config.patterns)) {
        console.error(`[ContentSafety] Patterns is not an array for ${severity}.${category}:`, config.patterns);
        continue;
      }

      const compiledPatterns = [];
      for (let i = 0; i < config.patterns.length; i++) {
        const pattern = config.patterns[i];
        if (!pattern) {
          console.error(`[ContentSafety] Pattern ${i} is undefined in ${severity}.${category}`);
          continue;
        }

        try {
          let newPattern;
          // Handle both RegExp objects from code and strings from JSON
          if (pattern instanceof RegExp) {
            // It's a hard-coded RegExp object, use it as-is
            newPattern = pattern;
          } else if (typeof pattern === 'string') {
            // It's a string from JSON, create a new RegExp from it
            // We assume case-insensitivity ('i') is a good default for all rules
            newPattern = new RegExp(pattern, 'i');
          } else {
            console.error(`[ContentSafety] Pattern ${i} is not a RegExp or a string in ${severity}.${category}:`, typeof pattern);
            continue;
          }
          compiledPatterns.push(newPattern);
        } catch (e) {
          console.error(`[ContentSafety] Failed to compile pattern ${i} in ${severity}.${category}:`, e, pattern);
        }
      }

      console.log(`[ContentSafety]   Compiled ${compiledPatterns.length} patterns for ${category}`);
      compiled.get(severity).set(category, {
        patterns: compiledPatterns,
        contextRules: config.contextRules || {}
      });
    }
  }

  console.log('[ContentSafety] Pattern compilation complete');
  console.log('[ContentSafety] Compiled structure:', compiled);

  return compiled;
}
  
  /**
   * Main content checking method
   */
  async checkContent(text, options = {}) {
    const startTime = performance.now();
    
    // Input validation
    if (!text || typeof text !== 'string') {
      return { safe: true, violations: [], checkTime: 0 };
    }
    
    // Length check
    if (text.length > this.config.maxTextLength) {
      return {
        safe: false,
        shouldBlock: true,
        violations: [{
          type: 'length_exceeded',
          severity: 'medium',
          confidence: 1.0
        }],
        checkTime: performance.now() - startTime
      };
    }
    
    if (!options.skipReversal && this.evasionPatterns.reversal.check) {
        const reversedResult = await this.evasionPatterns.reversal.check(text);
        if (reversedResult && reversedResult.shouldBlock) {
            return reversedResult;
        }
    }

    // Cache check
    const cacheKey = this.generateCacheKey(text);
    if (!options.skipCache && this.cache.has(cacheKey)) {
      this.cacheHits++;
      const cached = this.cache.get(cacheKey);
      return { ...cached, fromCache: true, checkTime: performance.now() - startTime };
    }
    this.cacheMisses++;
    
    // Perform the check
    const result = await this.performComprehensiveCheck(text, options);
    
    // Update cache
    this.updateCache(cacheKey, result);
    
    // Update metrics
    this.updateMetrics(result, performance.now() - startTime);
    
    return {
      ...result,
      checkTime: performance.now() - startTime
    };
  }
  evaluateContextLegitimacy(text, factors) {
    let score = 0;
    const lowerText = text.toLowerCase();
    
    // Check for actual news-like structure
    if (factors.includes('news')) {
        const newsIndicators = [
            /breaking\s+news\s*:/i,
            /\b(reuters|ap|cnn|bbc|fox\s*news)\b/i,
            /\b(reporter|journalist|correspondent)\b/i,
            /\b(police|authorities|officials)\s+(said|reported|confirmed)/i,
            /according\s+to\s+(police|officials|sources)/i
        ];
        
        const newsMatches = newsIndicators.filter(pattern => pattern.test(text)).length;
        score += newsMatches * 0.2;
        
        // Penalty for suspicious patterns
        if (/^(news|breaking\s*news):\s*i\s*(will|am\s*going\s*to)/i.test(lowerText)) {
            score -= 0.5; // Likely fake context
        }
    }
    
    // Check for actual educational content
    if (factors.includes('educational')) {
        const eduIndicators = [
            /\b(lesson|chapter|section|unit)\s*\d+/i,
            /\b(teacher|professor|instructor|course)\b/i,
            /\b(students?|classroom|curriculum)\b/i,
            /\b(historical|academic|scholarly)\b/i,
            /\b(exam|test|assignment|homework)\b/i
        ];
        
        const eduMatches = eduIndicators.filter(pattern => pattern.test(text)).length;
        score += eduMatches * 0.15;
        
        // Must have substantial educational context
        if (text.length < 100) {
            score -= 0.3; // Too short to be real educational content
        }
    }
    
    // Fiction check
    if (factors.includes('fiction')) {
        const fictionIndicators = [
            /\b(chapter|scene|act)\s*\d+/i,
            /\b(character|protagonist|antagonist)\b/i,
            /\b(novel|story|book|script|screenplay|plot)\b/i,
            /"[^"]+"\s*(said|asked|replied|shouted)/i,
            /\b(fiction|fantasy|sci-fi|thriller)\b/i
        ];
        
        const fictionMatches = fictionIndicators.filter(pattern => pattern.test(text)).length;
        score += fictionMatches * 0.2;
    }
    
    // Special handling for gaming context
    if (factors.includes('fiction') && lowerText.includes('game')) {
        // Gaming discussions should be more lenient
        const gameIndicators = [
            /\b(game|gaming|player|level|mission|quest|character)\b/i,
            /\b(call\s*of\s*duty|fortnite|minecraft|gta)\b/i,
            /\b(npc|pvp|fps|rpg|mmo)\b/i
        ];
        
        const gameMatches = gameIndicators.filter(pattern => pattern.test(text)).length;
        score += gameMatches * 0.3;
    }

    // For legitimate support context
    if (factors.includes('support') && factors.includes('selfharm')) {
        const supportIndicators = [
            /\b(hotline|crisis|prevention|help)\b/i,
            /\b(988|suicide\s*prevention)\b/i,
            /\b(available|support|counseling)\b/i,
            /\b(you\s*are\s*not\s*alone)\b/i
        ];
        
        const supportMatches = supportIndicators.filter(pattern => pattern.test(text)).length;
        if (supportMatches >= 3) {
            score = 0.9; // Very likely legitimate support content
        }
    }
    
    
    // Length check - real context usually has more content
    if (text.length > 200) {
        score += 0.1;
    }
    
    // Check for quotation marks (might be quoting)
    if ((text.match(/["'"]/g) || []).length >= 2) {
        score += 0.1;
    }
    
    return Math.max(0, Math.min(1, score));
}


async performComprehensiveCheck(text, options) {

  const violations = [];
  let contextAnalysis = null;

  // 1. Quick evasion check FIRST
  const quickEvasions = this.quickEvasionCheck(text);
  violations.push(...quickEvasions);
  
  // 2. Fuzzy matching check
  const fuzzyViolations = this.checkFuzzyHarmfulWords(text);
  violations.push(...fuzzyViolations);
  
  // 3. ADD THIS: N-gram similarity check
  const ngramViolations = this.checkNgramSimilarity(text);
  violations.push(...ngramViolations);
  
  // 4. Detect obfuscation attempts (renumber from 3)
  const obfuscation = this.detectObfuscation(text);
  if (obfuscation.score > 0.3) {
    violations.push({
      type: 'obfuscation_attempt',
      severity: obfuscation.score > 0.5 ? 'high' : 'medium',
      confidence: obfuscation.score,
      techniques: obfuscation.techniques
    });
  }
  
  
  // If obfuscation is high, find the specific underlying threat
if (obfuscation.score > 0.5) {
  
  // Check against all critical patterns
  const threatPatterns = [
    { pattern: /kill\s*you/i, type: 'threats', severity: 'high' },
    { pattern: /murder/i, type: 'threats', severity: 'high' },
    { pattern: /bomb/i, type: 'terrorism', severity: 'critical' },
    { pattern: /suicide/i, type: 'selfharm', severity: 'high' }
  ];
  
  for (const { pattern, type, severity } of threatPatterns) {
    if (pattern.test(text)) {
      violations.push({
        type,
        severity,
        confidence: 0.8,
        method: 'obfuscation_underlying',
        match: text.match(pattern)[0]
      });
      break;
    }
  }

  // If we found a specific threat, remove the generic obfuscation violation
  if (violations.some(v => v.method === 'obfuscation_underlying')) {
    const index = violations.findIndex(v => v.type === 'obfuscation_attempt');
    if (index !== -1) violations.splice(index, 1);
  }
}
  // 5. Normalize text through multiple passes
  const normalizations = this.getNormalizedVariants(text);
  
  // 6. Check each normalization
  for (const normalized of normalizations) {
    // FIXED: Do not check patterns on aggressively normalized text that comes from css-like content
    if (normalized.method === 'aggressive' && text.includes(':') && text.includes(';')) {
        continue;
    }
    const patternViolations = this.checkPatterns(normalized.text, text, normalized.method);
    violations.push(...patternViolations);
  }
  
  // 7. Context analysis (your existing code)
    if (this.config.enableContextAnalysis && violations.length > 0) {
        contextAnalysis = this.analyzeContext(text, violations);
        
        for (const violation of violations) {
            // CRITICAL: Only allow context mitigation for specific types
            const CONTEXT_ALLOWED_TYPES = ['terrorism', 'hate_speech'];
            
            // Direct threats, CSAM, self-harm should NEVER be mitigated
            const NEVER_MITIGATE = ['threats', 'csam', 'doxxing', 'grooming_behavior', 'selfharm'];
            
            if (NEVER_MITIGATE.includes(violation.type)) {
                continue; // Skip context mitigation entirely
            }
            
            if (!CONTEXT_ALLOWED_TYPES.includes(violation.type)) {
                continue; // Only specific types can be mitigated
            }
            
            // Check if context is legitimate
            const contextScore = this.evaluateContextLegitimacy(text, contextAnalysis.mitigatingFactors);
            
            if (contextScore > 0.7) { // High confidence it's legitimate context
                const rules = this.harmPatterns[violation.severity]?.[violation.type]?.contextRules;
                if (rules?.exceptions) {
                    for (const factor of contextAnalysis.mitigatingFactors) {
                        const exceptionMap = {
                            educational: 'history',
                            news: 'news',
                            fiction: 'fiction'
                        };
                        if (exceptionMap[factor] && rules.exceptions.includes(exceptionMap[factor])) {
                            violation.contextMitigation = true;
                            violation.mitigationConfidence = contextScore;
                            break;
                        }
                    }
                }
            }
        }
        
        violations.push(...contextAnalysis.additionalViolations);
    }
  
  // 8. Behavioral analysis
  const behavioral = this.analyzeBehavior(text, violations);
  violations.push(...behavioral);
  
    // --- Machine Learning Check ---
    // The NBC now acts as just another rule in the system.
    const nbcResult = this.classifier.predict(text);
    if (nbcResult.label === 'not_safe' && nbcResult.probability > this.config.nbcBlockThreshold) {
        violations.push({
            type: 'ml_flagged',
            severity: 'medium', // Downgraded to medium to act as a strong signal, not a final verdict.
            confidence: nbcResult.probability,
            method: 'nbc'
        });
    }
  
    const uniqueViolations = this.deduplicateViolations(violations);
    const finalVerdict = this.calculateVerdict(uniqueViolations);

    return {
      safe: finalVerdict.safe,
      violations: uniqueViolations,
      shouldBlock: finalVerdict.shouldBlock,
      confidence: finalVerdict.confidence,
      metadata: {
        nbcScore: nbcResult.label === 'not_safe' ? nbcResult.probability : 1 - nbcResult.probability,
        nbcLabel: nbcResult.label
      }
    };
  }


checkNgramSimilarity(text) {
  const violations = [];
  const processText = text.slice(0, 500);

  if (processText.length < 3) return violations;

  const generateTrigrams = (str) => {
    const trigrams = new Set();
    
    // 1. Sanitize: Replace all non-alphanumeric characters (except spaces) 
    // with a space, then collapse multiple spaces to one.
    const sanitizedStr = str.toLowerCase()
      .replace(/[^a-z0-9\s]/g, ' ')
      .replace(/\s+/g, ' ');

    // 2. Split the sanitized string into words.
    const words = sanitizedStr.split(' ');

    // 3. Iterate over each word to generate its trigrams.
    for (const word of words) {
      if (word.length < 3) continue;

      for (let i = 0; i <= word.length - 3; i++) {
        trigrams.add(word.slice(i, i + 3));
      }
    }
    return trigrams;
  };

  const harmfulSignatures = {
    'bom': { word: 'bomb', type: 'terrorism', severity: 'critical' },
    'omb': { word: 'bomb', type: 'terrorism', severity: 'critical' },
    'exp': { word: 'explosive', type: 'terrorism', severity: 'critical' },
    'plo': { word: 'explosive', type: 'terrorism', severity: 'critical' },
    'det': { word: 'detonate', type: 'terrorism', severity: 'critical' },
    'ton': { word: 'detonate', type: 'terrorism', severity: 'critical' },
    'ric': { word: 'ricin', type: 'terrorism', severity: 'critical' },
    'sar': { word: 'sarin', type: 'terrorism', severity: 'critical' },
    'thr': { word: 'anthrax', type: 'terrorism', severity: 'critical' },
    'kil': { word: 'kill', type: 'threats', severity: 'high', context: ['you', 'them', 'all', 'me'] }, 
    'ill': { word: 'kill', type: 'threats', severity: 'high' },
    'mur': { word: 'murder', type: 'threats', severity: 'high' },
    'urd': { word: 'murder', type: 'threats', severity: 'high' },
    'der': { word: 'murder', type: 'threats', severity: 'high' },
    'sho': { word: 'shoot', type: 'threats', severity: 'high' },
    'oot': { word: 'shoot', type: 'threats', severity: 'high' },
    'sta': { word: 'stab', type: 'threats', severity: 'high' },
    'tab': { word: 'stab', type: 'threats', severity: 'high' },
    'str': { word: 'strangle', type: 'threats', severity: 'high' },
    'ang': { word: 'strangle', type: 'threats', severity: 'high' },
    'rap': { word: 'rape', type: 'threats', severity: 'high' },
    'ape': { word: 'rape', type: 'threats', severity: 'high' },
    'sui': { word: 'suicide', type: 'selfharm', severity: 'high' },
    'uic': { word: 'suicide', type: 'selfharm', severity: 'high' },
    'ici': { word: 'suicide', type: 'selfharm', severity: 'high' },
    'cid': { word: 'suicide', type: 'selfharm', severity: 'high' },
    'ide': { word: 'suicide', type: 'selfharm', severity: 'high' },
    'ove': { word: 'overdose', type: 'selfharm', severity: 'high' },
    'ver': { word: 'overdose', type: 'selfharm', severity: 'high' },
    'dos': { word: 'overdose', type: 'selfharm', severity: 'high' },
    'mol': { word: 'molest', type: 'csam', severity: 'critical' },
    'les': { word: 'molest', type: 'csam', severity: 'critical' },
    'ped': { word: 'pedo', type: 'csam', severity: 'critical' },
    'edo': { word: 'pedo', type: 'csam', severity: 'critical' },
    'lol': { word: 'loli', type: 'csam', severity: 'critical' },
    'oli': { word: 'loli', type: 'csam', severity: 'critical' },
    'csa': { word: 'csam', type: 'csam', severity: 'critical' },
    'sam': { word: 'csam', type: 'csam', severity: 'critical' },
    'coc': { word: 'cocaine', type: 'illegal_trade', severity: 'high' },
    'oca': { word: 'cocaine', type: 'illegal_trade', severity: 'high' },
    'ain': { word: 'cocaine', type: 'illegal_trade', severity: 'high' },
    'her': { word: 'heroin', type: 'illegal_trade', severity: 'high' },
    'ero': { word: 'heroin', type: 'illegal_trade', severity: 'high' },
    'fen': { word: 'fentanyl', type: 'illegal_trade', severity: 'high' },
    'ent': { word: 'fentanyl', type: 'illegal_trade', severity: 'high' },
    'nyl': { word: 'fentanyl', type: 'illegal_trade', severity: 'high' },
    'met': { word: 'meth', type: 'illegal_trade', severity: 'high' },
    'eth': { word: 'meth', type: 'illegal_trade', severity: 'high' },
    'dox': { word: 'doxx', type: 'doxxing', severity: 'high' },
    'oxx': { word: 'doxx', type: 'doxxing', severity: 'high' },
    'swa': { word: 'swat', type: 'doxxing', severity: 'critical' },
    'wat': { word: 'swat', type: 'doxxing', severity: 'critical' },
    'add': { word: 'address', type: 'doxxing', severity: 'high' },
    'ddr': { word: 'address', type: 'doxxing', severity: 'high' },
    'res': { word: 'address', type: 'doxxing', severity: 'high' }
  };
  
  const textTrigrams = generateTrigrams(processText);
  const wordMatches = new Map();
  
  for (const trigram of textTrigrams) {
    if (harmfulSignatures[trigram]) {
      const config = harmfulSignatures[trigram];
      // Context check for sensitive trigrams
      if (config.context) {
          const hasContext = config.context.some(ctx => text.toLowerCase().includes(ctx));
          if (!hasContext) continue; // Skip if required context is missing
      }
      const currentCount = wordMatches.get(config.word) || 0;
      wordMatches.set(config.word, currentCount + 1);
    }
  }
  
  for (const [word, count] of wordMatches) {
    if (count >= 2) {
      const config = Object.values(harmfulSignatures).find(h => h.word === word);
      
        violations.push({
          type: config.type,
          severity: config.severity,
          confidence: Math.min(count * 0.1, 0.8),
          method: 'ngram_analysis',
          match: word
        });
      
    }
  }
  
  return violations;
}

  detectObfuscation(text) {
    const techniques = [];
    let score = 0;
    
    // Character substitution detection
    const substitutionRatio = this.calculateSubstitutionRatio(text);
    if (substitutionRatio > 0.3) {
      techniques.push('character_substitution');
      score += substitutionRatio * 0.5;
    }
    
    // Spacing anomalies
    const spacingScore = this.detectSpacingAnomalies(text);
    if (spacingScore > 0.5) {
      techniques.push('spacing_manipulation');
      score += spacingScore * 0.2;
    }
    
    // Mixed script detection
    const scriptMixing = this.detectMixedScripts(text);
    if (scriptMixing.mixed) {
      techniques.push('mixed_scripts');
      score += 0.3;
    }
    
    // Zalgo text
    if (this.evasionPatterns.zalgo.pattern.test(text)) {
      techniques.push('zalgo_text');
      score += 0.4;
    }
    
    // Repetition patterns
    const repetitionScore = this.detectRepetition(text);
    if (repetitionScore > 0.5) {
      techniques.push('character_repetition');
      score += repetitionScore * 0.2;
    }
    
    // Case manipulation
    const caseScore = this.detectCaseManipulation(text);
    if (caseScore > 0.6) {
      techniques.push('case_manipulation');
      score += caseScore * 0.1;
    }
    
    return {
      score: Math.min(score, 1.0),
      techniques
    };
  }
  
  calculateSubstitutionRatio(text) {
    let substitutions = 0;
    const chars = text.split('');
    
    for (const char of chars) {
      if (this.unicodeMap.has(char)) {
        substitutions++;
      }
      // Check for leetspeak
      for (const [letter, variants] of Object.entries(this.evasionPatterns.leetspeak.advanced)) {
        if (variants.includes(char)) {
          substitutions++;
          break;
        }
      }
    }
    
    return substitutions / chars.length;
  }
  
  detectSpacingAnomalies(text) {
    let anomalies = 0;
    
    // Extra spaces between letters
    const extraSpaces = (text.match(/\w\s{2,}\w/g) || []).length;
    anomalies += extraSpaces * 0.2;
    
    // Dots, underscores, or dashes between letters
    const separators = (text.match(/\w[._-]+\w/g) || []).length;
    anomalies += separators * 0.3;
    
    // Zero-width characters
    const zeroWidth = (text.match(/[\u200b\u200c\u200d\ufeff]/g) || []).length;
    anomalies += zeroWidth * 0.5;
    
    return Math.min(anomalies / text.length * 10, 1.0);
  }
  
  detectMixedScripts(text) {
    const scripts = new Set();
    const scriptRanges = [
      { name: 'latin', regex: /[a-zA-Z]/ },
      { name: 'cyrillic', regex: /[\u0400-\u04FF]/ },
      { name: 'greek', regex: /[\u0370-\u03FF]/ },
      { name: 'arabic', regex: /[\u0600-\u06FF]/ },
      { name: 'hebrew', regex: /[\u0590-\u05FF]/ },
      { name: 'chinese', regex: /[\u4E00-\u9FFF]/ },
      { name: 'japanese', regex: /[\u3040-\u309F\u30A0-\u30FF]/ },
      { name: 'korean', regex: /[\uAC00-\uD7AF]/ }
    ];
    
    for (const char of text) {
      for (const script of scriptRanges) {
        if (script.regex.test(char)) {
          scripts.add(script.name);
        }
      }
    }
    
    return {
      mixed: scripts.size > 1,
      scripts: Array.from(scripts)
    };
  }
  
  detectRepetition(text) {
    // Character repetition
    const charRepeat = Math.max(...(text.match(/(.)\1{2,}/g) || []).map(m => m.length)) || 0;
    
    // Word repetition
    const words = text.toLowerCase().split(/\s+/);
    const wordCounts = {};
    for (const word of words) {
      wordCounts[word] = (wordCounts[word] || 0) + 1;
    }
    const maxWordRepeat = Math.max(...Object.values(wordCounts));
    
    return Math.min((charRepeat / 10 + maxWordRepeat / words.length) / 2, 1.0);
  }
  
  detectCaseManipulation(text) {
    const upperCount = (text.match(/[A-Z]/g) || []).length;
    const lowerCount = (text.match(/[a-z]/g) || []).length;
    const totalLetters = upperCount + lowerCount;
    
    if (totalLetters === 0) return 0;
    
    // Alternating case detection
    const alternating = (text.match(/[a-z][A-Z]|[A-Z][a-z]/g) || []).length;
    const alternatingRatio = alternating / Math.max(totalLetters - 1, 1);
    
    // Random case detection
    const upperRatio = upperCount / totalLetters;
    const randomCase = upperRatio > 0.3 && upperRatio < 0.7;
    
    return Math.max(alternatingRatio, randomCase ? 0.7 : 0);
  }
  
  getNormalizedVariants(text) {
    const variants = [];
    
      // Ensure text is a string
  if (!text || typeof text !== 'string') {
    return [{ text: '', method: 'original' }];
  }
  
    
    // Original text
    variants.push({ text: text, method: 'original' });
    
    // Basic normalization
    variants.push({ 
      text: this.basicNormalize(text), 
      method: 'basic' 
    });
    
    // Unicode normalization
    variants.push({ 
      text: this.unicodeNormalize(text), 
      method: 'unicode' 
    });
    
    // Aggressive normalization
    variants.push({ 
      text: this.aggressiveNormalize(text), 
      method: 'aggressive' 
    });
    
    // Remove all spaces
    variants.push({ 
      text: text.replace(/\s+/g, ''), 
      method: 'no_spaces' 
    });
    
    // Phonetic normalization
    variants.push({ 
      text: this.phoneticNormalize(text), 
      method: 'phonetic' 
    });
    
    return variants;
  }
  
basicNormalize(text) {
  if (!text || typeof text !== 'string') return '';
  return text
    .toLowerCase()
    .replace(/[^a-z0-9]/g, '')
    .trim();
}
  
  
  unicodeNormalize(text) {
    if (!text || typeof text !== 'string') return '';

    // FIXED: If the text looks like CSS, don't strip essential characters.
    if (text.includes(':') && text.includes(';')) {
        return text.toLowerCase().replace(/\s+/g, ' ');
    }

    let normalized = '';

    // 1. Iterate character by character and replace using the map.
    for (const char of text) {
      normalized += this.unicodeMap.get(char.toLowerCase()) || char;
    }

    // 2. Convert to a consistent case.
    normalized = normalized.toLowerCase();

    // 3. Apply basic leetspeak for any remaining numbers/symbols.
    normalized = normalized
      .replace(/0/g, 'o').replace(/1/g, 'i').replace(/3/g, 'e')
      .replace(/4/g, 'a').replace(/5/g, 's').replace(/7/g, 't')
      .replace(/8/g, 'b').replace(/@/g, 'a').replace(/\$/g, 's')
      .replace(/!/g, 'i');

    // 4. Remove Zalgo text.
    normalized = normalized.replace(this.evasionPatterns.zalgo.pattern, '');

    // 5. Perform standard Unicode form normalization.
    normalized = normalized.normalize('NFKD');

    // 6. Clean up any remaining non-word characters and extra spaces.
    normalized = normalized.replace(/[^a-z0-9\s]/g, '').replace(/\s+/g, ' ').trim();

    return normalized;
}
  
  
    
    
  quickEvasionCheck(text) {
      const violations = [];
      
      // Common evasion patterns that should trigger immediate flags
      const evasionPhrases = [
        { pattern: /b[0o]m[b8]/i, type: 'terrorism', severity: 'critical' },
        // FIXED: Make the "kill" check more specific to avoid names
        { pattern: /\bk[i1!]+ll\b/i, type: 'threats', severity: 'high' },
        { pattern: /k[i1!]ll\s*y[o0]u/i, type: 'threats', severity: 'high' },
        { pattern: /su[i1!]c[i1!]d[e3]/i, type: 'selfharm', severity: 'high' },
        { pattern: /[ck]ill[sz]?\s*[ck]ids?/i, type: 'threats', severity: 'critical' },
        { pattern: /\b\d{1,2}\s*y[o0]\b/i, type: 'csam', severity: 'critical' },
        { pattern: /[e3]xpl[o0]s[i1]v[e3]/i, type: 'terrorism', severity: 'critical' },
        { pattern: /d[e3]t[o0]n[a4]t[e3]/i, type: 'terrorism', severity: 'critical' },
        
        // More threat variations
        { pattern: /m[u\|_]rd[e3]r/i, type: 'threats', severity: 'high' },
        { pattern: /sh[o0][o0]t/i, type: 'threats', severity: 'high' },
        { pattern: /st[a4]b/i, type: 'threats', severity: 'high' },
        { pattern: /r[a4]p[e3]/i, type: 'threats', severity: 'high' },
        
        // Drug variations
        { pattern: /c[o0]c[a4][i1]n[e3]/i, type: 'illegal_trade', severity: 'high' },
        { pattern: /h[e3]r[o0][i1]n/i, type: 'illegal_trade', severity: 'high' },
        { pattern: /m[e3]th/i, type: 'illegal_trade', severity: 'high' },
        
        // CSAM variations
        { pattern: /p[e3]d[o0]/i, type: 'csam', severity: 'critical' },
        { pattern: /l[o0]l[i1]/i, type: 'csam', severity: 'critical' },
        { pattern: /ch[i1]ld.{0,10}p[o0]rn/i, type: 'csam', severity: 'critical' },
        
        // Doxxing
        { pattern: /d[o0]xx/i, type: 'doxxing', severity: 'high' },
        { pattern: /sw[a4]t/i, type: 'doxxing', severity: 'critical' }
      ];
      
      for (const { pattern, type, severity } of evasionPhrases) {
        if (pattern.test(text)) {
          violations.push({
            type,
            severity,
            confidence: 0.2,
            method: 'quick_evasion',
            match: text.match(pattern)[0]
          });
        }
      }
      
      return violations;
    }
  aggressiveNormalize(text) {
        if (!text || typeof text !== 'string') return '';

    // FIXED: If the text looks like CSS, don't be aggressive.
    if (text.includes(':') && text.includes(';')) {
        return this.unicodeNormalize(text);
    }

    let normalized = this.unicodeNormalize(text);
    
    // Remove all non-alphanumeric except spaces
    normalized = normalized.replace(/[^a-z0-9\s]/g, '');
    
    // Collapse repeated characters
    normalized = normalized.replace(/(.)\1+/g, '$1');
    
    // Remove single characters between words
    normalized = normalized.replace(/\b\w\b/g, '');
    
    return normalized.trim();
  }
  
  phoneticNormalize(text) {
        if (!text || typeof text !== 'string') return '';

    let normalized = this.basicNormalize(text);
    
    // Common phonetic substitutions
    const phonetic = {
      'kh': 'k',
      'yoo': 'you',
      'ph': 'f',
      'ck': 'k',
      'kn': 'n',
      'wr': 'r',
      'qu': 'kw',
      'x': 'ks',
      'tion': 'shun',
      'sion': 'shun',
      'ough': 'o',
      'augh': 'af',
      'eigh': 'ay'
    };
    
    for (const [find, replace] of Object.entries(phonetic)) {
      normalized = normalized.replace(new RegExp(find, 'g'), replace);
    }
    
    return normalized;
  }
  
checkPatterns(normalizedText, originalText, normalizationMethod) {
  const violations = [];
  
  if (!normalizedText || typeof normalizedText !== 'string') {
    return violations;
  }
  
  if (!this.compiledPatterns || this.compiledPatterns.size === 0) {
    return violations;
  }
  
  const paddedText = ` ${normalizedText} `;
  
  if (originalText && typeof originalText === 'string') {
    const asciiText = this.unicodeNormalize(originalText);
    if (asciiText !== originalText) {
      const threatConfig = this.compiledPatterns.get('high')?.get('threats');
      if (threatConfig && threatConfig.patterns) {
        for (const pattern of threatConfig.patterns) {
          if (pattern && pattern.test && pattern.test(asciiText)) {
            return [{
              type: 'threats',
              severity: 'high',
              pattern: pattern.source,
              normalizationMethod: 'unicode',
              confidence: 0.9
            }];
          }
        }
      }
    }
  }

  const legitimateContext = this.checkLegitimateContext(originalText);
  
  for (const [severity, categories] of this.compiledPatterns) {
    
    if (!categories || !(categories instanceof Map)) {
      continue;
    }
    
    for (const [category, config] of categories) {
      
      if (!config || !config.patterns || !Array.isArray(config.patterns)) {
        continue;
      }
      
      for (let i = 0; i < config.patterns.length; i++) {
        const pattern = config.patterns[i];
        
        if (!pattern || typeof pattern.test !== 'function') {
          continue;
        }
        
        let patternToTest = pattern;
        
        if (normalizationMethod !== 'original') {
          if (pattern.source === undefined) {
            continue;
          }
          
          try {
            const newSource = pattern.source.replace(/\\b/g, '');
            if (newSource !== pattern.source) {
              patternToTest = new RegExp(newSource, pattern.flags || '');
            }
          } catch (e) {
            continue;
          }
        }

        const matches = normalizedText.match(patternToTest) || paddedText.match(patternToTest);
        
        if (matches) {
          if (config.contextRules) {
            if (config.contextRules.requiresContext) {
              const hasCtx = this.checkRequiredContext(originalText, config.contextRules);
              if (!hasCtx) continue;
            }
            if (config.contextRules.exceptions &&
                config.contextRules.exceptions.includes(legitimateContext.type)) {
              continue;
            }
            if (config.contextRules.exceptions) {
              const hasException = config.contextRules.exceptions.some(
                ex => originalText.toLowerCase().includes(ex)
              );
              if (hasException) continue;
            }
          }
          
          violations.push({
            type: category,
            severity: severity,
            confidence: this.calculateConfidence(matches, normalizedText, normalizationMethod),
            pattern: pattern.source, 
            match: matches[0],
            normalizationMethod: normalizationMethod
          });
          
          break; 
        }
      }
    }
  }
  
  return violations;
}

// Add new method to check legitimate contexts more thoroughly
checkLegitimateContext(text) {
  const context = {
    isLegitimate: false,
    type: null,
    confidence: 0
  };
  
  if (!text) return context;

  // News context - check for real news structure
  if (this.isLegitimateNewsContext(text)) {
    context.isLegitimate = true;
    context.type = 'news';
    context.confidence = 0.9;
  }
  // Educational context - check for real educational content
  else if (this.isLegitimateEducationalContext(text)) {
    context.isLegitimate = true;
    context.type = 'educational';
    context.confidence = 0.9;
  }
  // Fiction/gaming context
  else if (this.isLegitimateCreativeContext(text)) {
    context.isLegitimate = true;
    context.type = 'creative';
    context.confidence = 0.9;
  }
  // Support/crisis context
  else if (this.isLegitimateSupportContext(text)) {
    context.isLegitimate = true;
    context.type = 'support';
    context.confidence = 0.95;
  }
  
  return context;
}

// Add specific context validators
isLegitimateNewsContext(text) {
  const indicators = 0;
  
  // Must have substantial content (not just "news: threat")
  if (text.length < 100) return false;
  
  // Check for multiple news indicators
  const newsPatterns = [
    /\b(reuters|ap|cnn|bbc|fox\s*news|npr|guardian|times|post)\b/i,
    /\b(reporter|journalist|correspondent|editor)\b/i,
    /\b(police|authorities|officials|spokesperson)\s+(said|reported|confirmed|announced)/i,
    /according\s+to\s+(police|officials|sources|reports)/i,
    /\b(arrested|detained|charged|convicted|sentenced)\b/i,
    /\b(investigation|incident|event)\s+(occurred|happened|took\s+place)/i
  ];
  
  let matches = 0;
  for (const pattern of newsPatterns) {
    if (pattern.test(text)) matches++;
  }
  
  return matches >= 2;
}

isLegitimateEducationalContext(text) {
  if (text.length < 100) return false;
  
  const eduPatterns = [
    /\b(chapter|lesson|section|unit|module)\s*\d+/i,
    /\b(textbook|curriculum|syllabus|course\s*material)/i,
    /\b(professor|teacher|instructor|educator)\b/i,
    /\b(students?|classroom|lecture|academic)/i,
    /\b(exam|test|quiz|assignment|homework)/i,
    /\b(learn(?:ing)?|teach(?:ing)?|educat(?:e|ion)|study(?:ing)?)\b/i
  ];
  
  let matches = 0;
  for (const pattern of eduPatterns) {
    if (pattern.test(text)) matches++;
  }
  
  return matches >= 2;
}

isLegitimateCreativeContext(text) {
  const creativePatterns = [
    /\b(chapter|scene|act|episode)\s*\d+/i,
    /\b(character|protagonist|antagonist|hero|villain)\b/i,
    /\b(novel|story|book|script|screenplay|plot)\b/i,
    /\b(game|gaming|player|npc|quest|mission|level)\b/i,
    /"[^"]+"\s*(said|asked|replied|shouted|whispered)/i,
    /\b(fiction|fantasy|sci-fi|thriller|drama)\b/i
  ];
  
  let matches = 0;
  for (const pattern of creativePatterns) {
    if (pattern.test(text)) matches++;
  }
  
  // For gaming, be more lenient
  if (/\b(call\s*of\s*duty|fortnite|minecraft|gta|game)\b/i.test(text)) {
    matches += 2;
  }
  
  return matches >= 2 && text.length > 50;
}

isLegitimateSupportContext(text) {
  const supportPatterns = [
    /\b(suicide\s*prevention|crisis\s*intervention)\b/i,
    /\b(hotline|helpline|support\s*line)\b/i,
    /\b(988|1-?800-?273-?8255)\b/, // Suicide prevention numbers
    /\b(help\s*is\s*available|support\s*is\s*here|you\s*are\s*not\s*alone)\b/i,
    /\b(counseling|therapy|mental\s*health\s*support)\b/i,
    /\b(please\s*call|reach\s*out|get\s*help|seek\s*support)\b/i,
    /\b(thoughts\s*of\s*suicide)\b/i 
  ];
  
  let matches = 0;
  for (const pattern of supportPatterns) {
    if (pattern.test(text)) matches++;
  }
  
  return matches >= 2;
}

shouldSkipInContext(category, context, text) {
  // NEVER skip critical threats even in fiction
  if (this.harmPatterns.critical[category] || this.harmPatterns.high[category]) {
      // For threats in fiction, check if it's a direct threat
      if (category === 'threats' && context.type === 'creative') {
          // Look for first-person threats even in fiction
          const firstPersonThreat = /\b(i\s*(will|am\s*going\s*to)|gonna)\s*\w*\s*(kill|murder|hurt|shoot)\b/i;
          if (firstPersonThreat.test(text)) {
              return false; // Don't skip - this is still a threat
          }
      }
      return false;
  }


  const contextExemptions = {
    news: ['terrorism', 'hate_speech', 'threats', 'illegal_trade'],
    educational: ['terrorism', 'hate_speech', 'illegal_trade'],
    creative: ['threats', 'illegal_trade'],
    support: ['selfharm'] 
  };
  
  if (context.type === 'creative' && category === 'threats') {
    const gameViolencePattern = /\b(game|gaming|player|character|enemy|mission)\b/i;
    if (gameViolencePattern.test(text)) {
      return true;
    }
  }
  
  return contextExemptions[context.type]?.includes(category) && context.confidence > 0.6;
}
  
  checkRequiredContext(text, contextRules) {
    if (contextRules.mustInclude) {
      return contextRules.mustInclude.some(word => 
        text.toLowerCase().includes(word)
      );
    }
    return true;
  }
  
  calculateConfidence(matches, text, normalizationMethod) {
    let confidence = 0.8;
    
    // Exact match in original text gets higher confidence
    if (normalizationMethod === 'original') {
      confidence = 1.0;
    }
    
    // Adjust based on match quality
    const matchLength = matches[0].length;
    const textLength = text.length;
    const coverage = matchLength / textLength;
    
    confidence *= (0.5 + coverage * 0.5);
    
    return Math.min(confidence, 1.0);
  }
  
analyzeContext(text, violations) {
    const analysis = {
        mitigatingFactors: [],
        additionalViolations: []
    };
    
    if (!text) return analysis;

    // Require substantial context, not just a keyword
    const words = text.split(/\s+/).length;
    
    // Check for quotations with minimum content
    if (this.contextRules.quotation.test(text) && words > 10) {
        analysis.mitigatingFactors.push('quotation');
    }
    if (this.contextRules.quotation.test(text)) {
  // Check if it's a properly attributed quote
  const attributedQuote = /\b(said|wrote|stated|according to|quoted)\b[^"]*"[^"]+"/i;
  const movieGameQuote = /\b(movie|film|book|game|show|character)\b[^"]*"[^"]+"/i;
  
  if (attributedQuote.test(text) || movieGameQuote.test(text)) {
    analysis.mitigatingFactors.push('attributed_quote');
    
    // Downgrade severity for quoted content
    for (const violation of violations) {
      if (violation.severity !== 'critical') { // Never downgrade critical
        violation.contextMitigation = true;
        violation.mitigationConfidence = 0.8;
      }
    }
  }
}
    // Educational context needs more than just the word "education"
    if (this.contextRules.educational.test(text) && words > 20) {
        const eduWords = text.match(/\b(study|research|paper|article|essay|report|teach|learn|history|education)\b/gi) || [];
        if (eduWords.length >= 2) { // Require multiple educational words
            analysis.mitigatingFactors.push('educational');
        }
    }
    
    // Check for quotations
    if (this.contextRules.quotation.test(text)) {
      analysis.mitigatingFactors.push('quotation');
    }
    
    // Check for educational context
    if (this.contextRules.educational.test(text)) {
      analysis.mitigatingFactors.push('educational');
    }
    
    // Check for news/reporting context
    if (this.contextRules.news.test(text)) {
      analysis.mitigatingFactors.push('news');
    }
    
    // Check for fictional context
    if (this.contextRules.fiction.test(text)) {
      analysis.mitigatingFactors.push('fiction');
    }
    
    // Check for support context
    if (this.contextRules.support.test(text)) {
      analysis.mitigatingFactors.push('support');
      
      // Self-harm with support context is allowed
      const selfharmIndex = violations.findIndex(v => v.type === 'selfharm');
      if (selfharmIndex !== -1) {
        analysis.mitigatingFactors.push('selfharm');
      }
    }
    
    // Check for sarcasm or negation
    const sarcasmIndicators = /\b(not|never|don't|won't|shouldn't|sarcasm|joking|kidding|lol|haha|üòÇ|üôÑ)\b/i;
    if (sarcasmIndicators.test(text)) {
      // But check if it's being used to bypass
      const bypassPhrases = /just\s*(kidding|joking)|lol\s*jk|not\s*really/i;
      if (bypassPhrases.test(text) && violations.some(v => v.severity === 'high')) {
        analysis.additionalViolations.push({
          type: 'bypass_attempt',
          severity: 'critical',
          confidence: 0.8
        });
      }
    }
    
    return analysis;
  }
  
  levenshteinDistance(str1, str2) {
      const m = str1.length;
      const n = str2.length;
      const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));
      
      for (let i = 0; i <= m; i++) dp[i][0] = i;
      for (let j = 0; j <= n; j++) dp[0][j] = j;
      
      for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
          if (str1[i - 1] === str2[j - 1]) {
            dp[i][j] = dp[i - 1][j - 1];
          } else {
            dp[i][j] = 1 + Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]);
          }
        }
      }
      
      return dp[m][n];
    }

    // Add fuzzy matching for critical terms
    checkFuzzyHarmfulWords(text) {
      const violations = [];

      // Critical harmful words to check
    const criticalWords = {
      // Terrorism/Violence
      'bomb': { severity: 'critical', type: 'terrorism' },
      'explosive': { severity: 'critical', type: 'terrorism' },
      'detonate': { severity: 'critical', type: 'terrorism' },
      'ricin': { severity: 'critical', type: 'terrorism' },
      'sarin': { severity: 'critical', type: 'terrorism' },
      'anthrax': { severity: 'critical', type: 'terrorism' },
      
      // Threats
      'kill': { severity: 'high', type: 'threats' },
      'murder': { severity: 'high', type: 'threats' },
      'shoot': { severity: 'high', type: 'threats' },
      'stab': { severity: 'high', type: 'threats' },
      'strangle': { severity: 'high', type: 'threats' },
      'rape': { severity: 'high', type: 'threats' },
      'assault': { severity: 'high', type: 'threats' },
      
      // Self-harm
      'suicide': { severity: 'high', type: 'selfharm' },
      'overdose': { severity: 'high', type: 'selfharm' },
      
      // CSAM
      'molest': { severity: 'critical', type: 'csam' },
      'pedo': { severity: 'critical', type: 'csam' },
      'loli': { severity: 'critical', type: 'csam' },
      'csam': { severity: 'critical', type: 'csam' },
      
      // Illegal trade
      'cocaine': { severity: 'high', type: 'illegal_trade' },
      'heroin': { severity: 'high', type: 'illegal_trade' },
      'fentanyl': { severity: 'high', type: 'illegal_trade' },
      'meth': { severity: 'high', type: 'illegal_trade' },
      'ice' :  { severity: 'high', type: 'illegal_trade' },
      
      // Doxxing
      'address': { severity: 'high', type: 'doxxing' },
      'doxx': { severity: 'high', type: 'doxxing' },
      'swat': { severity: 'critical', type: 'doxxing' }
    };
    //slur words
      const slurWords = {
        'nigger': { severity: 'medium', type: 'hate_speech' },
        'faggot': { severity: 'medium', type: 'hate_speech' },
        'kike': { severity: 'medium', type: 'hate_speech' },
        'tranny': { severity: 'medium', type: 'hate_speech' },
        'dyke' : { severity: 'medium', type: 'hate_speech' },
        'poofter': { severity: 'medium', type: 'hate_speech' },
        'coon':  { severity: 'medium', type: 'hate_speech' },
        'chink':  { severity: 'medium', type: 'hate_speech' },
        'slut':  { severity: 'medium', type: 'hate_speech' },
        'whore':  { severity: 'medium', type: 'hate_speech' },
        'skag' :  { severity: 'medium', type: 'hate_speech' },
      };
    
        const normalized = this.unicodeNormalize(text);

  // Check if we're in a context where fuzzy matching should be more lenient
  const context = this.checkLegitimateContext(text);
  const threshold = context.isLegitimate ? 0.85 : 0.80;
  
  // Add more stop words
  const STOP_WORDS = new Set([
    'will', 'wall', 'well', 'fill', 'mill', 'bill', 'till',
    'shoot', 'shot', 'shoe', 'shop', 'show', // Common false positives for "shoot"
    'boot', 'foot', 'root', 'hoot'
  ]);
  
  const words = normalized.toLowerCase()
    .split(/[\s\W]+/)
    .filter(w => w.length > 2 && !STOP_WORDS.has(w))
      
      for (const word of words) {
        const dedupedWord = word.replace(/(.)\1+/g, '$1');

        for (const [harmfulWord, config] of Object.entries(criticalWords)) {
          const distance = this.levenshteinDistance(dedupedWord, harmfulWord);
          const similarity = 1 - (distance / Math.max(dedupedWord.length, harmfulWord.length));
          
          if (similarity >= threshold) {
            violations.push({
              type: config.type,
              severity: config.severity,
              confidence: similarity,
              match: word,
              similarTo: harmfulWord,
              method: 'fuzzy_match'
            });
          }
        }
      }
      
      return violations;
    }
  
  
  
  analyzeBehavior(text, existingViolations) {
    const behavioral = [];
    
    // Grooming patterns
    const groomingPhrases = [
      /\b(don['‚Äô]t|dont)\s*tell\s*(?:\w+\s*)?(?:anyone|parents?|mom|dad)/i,
      /\b(our|my)\s*little\s*secret/i,
      /\b(special|mature)\s*for\s*your\s*age/i,
      /\bsend\s*(me|pics|photos|pictures)/i,
      /\b(meet|see)\s*you\s*(irl|in\s*real\s*life|in\s*person)/i,
      /\b(between|just)\s*(you\s*and\s*me|us)/i,
      /\byou['re\s]*(so\s*)?mature/i,
      /\b(no\s*one|nobody)\s*(understands|gets)\s*you\s*like\s*i\s*do/i,
      /\bi\s*can\s*(teach|show)\s*you/i,
      /\b(trust\s*me|you\s*can\s*trust)/i,
      /\bkeep\s*(this|it)\s*secret/i,
      /\bdelete\s*(this|these|the)\s*(message|chat|conversation)/i,
      /\byour\s*parents\s*(wouldn't|won't)\s*understand/i,
      /\bare\s*you\s*alone/i,
      /\bwhat\s*are\s*you\s*wearing/i,
      /\bsend\s*(me\s*)?(more|nude|naked)/i
    ];
    
    let groomingScore = 0;
    for (const pattern of groomingPhrases) {
      if (pattern.test(text)) groomingScore++;
    }
    
    if (groomingScore >= 2) {
      behavioral.push({
        type: 'grooming_behavior',
        severity: 'high',
        confidence: Math.min(groomingScore * 0.3, 1.0)
      });
    }
    
    // Manipulation patterns
    const manipulationPhrases = [
      /\b(kill|hurt)\s*myself\s*if\s*you/i,
      /\byou\s*made\s*me\s*do\s*this/i,
      /\b(everyone|nobody)\s*(hates|likes)\s*you/i,
      /\byou\s*(deserve|caused)\s*this/i,
      /\bit['s\s]*your\s*fault/i,
      /\byou\s*made\s*me/i,
      /\bif\s*you\s*(really\s*)?loved\s*me/i,
      /\byou\s*owe\s*me/i,
      /\bafter\s*(all|everything)\s*i['ve\s]*done/i,
      /\byou['re\s]*nothing\s*without\s*me/i,
      /\bnobody\s*else\s*would\s*(want|love|date)\s*you/i,
      /\byou['re\s]*(crazy|insane|mental|psycho)/i,
      /\bi['m\s]*the\s*only\s*one\s*who/i,
      /\byou\s*deserve\s*(this|it|what)/i
    ];
    
    for (const pattern of manipulationPhrases) {
      if (pattern.test(text)) {
        behavioral.push({
          type: 'emotional_manipulation',
          severity: 'medium',
          confidence: 0.8
        });
        break;
      }
    }
    
    return behavioral;
  }
  
  downgradeSeverity(severity) {
    const levels = ['low', 'medium', 'high', 'critical'];
    const index = levels.indexOf(severity);
    return index > 0 ? levels[index - 1] : severity;
  }
  
deduplicateViolations(violations) {
  const obfuscationAttempt = violations.find(v => v.type === 'obfuscation_attempt');
  const specificThreat = violations.find(v => ['threats', 'terrorism', 'csam', 'selfharm'].includes(v.type));

  // If we found both an obfuscation attempt AND a specific underlying threat...
  if (obfuscationAttempt && specificThreat) {
    // And the obfuscation confidence is VERY high (>= 0.7), it means the
    // underlying threat is clear despite the obfuscation. Prioritize the threat.
    if (obfuscationAttempt.confidence >= 0.7) {
      return violations.filter(v => v.type !== 'obfuscation_attempt');
    }
    // Otherwise, the heavy obfuscation itself is the most important finding.
    // Prioritize the obfuscation attempt.
    else {
      return violations.filter(v => v.type !== specificThreat.type);
    }
  }

  // If the special cases above don't apply, fall back to the original simple deduplication.
  const seen = new Map();
  for (const violation of violations) {
    const key = `${violation.type}-${violation.severity}`;
    if (!seen.has(key) || violation.confidence > seen.get(key).confidence) {
      seen.set(key, violation);
    }
  }
  return Array.from(seen.values());
}
  
 calculateVerdict(violations) {
    if (violations.length === 0) {
        return { safe: true, shouldBlock: false, confidence: 1.0 };
    }
    
    // Filter out violations that have been mitigated
    const activeSeverityViolations = violations.filter(v => !v.contextMitigation);
    
    if (activeSeverityViolations.length === 0) {
        return { safe: true, shouldBlock: false, confidence: 0.5 };
    }
      const onlyLowSeverity = violations.every(v => v.severity === 'low');
      if (onlyLowSeverity) {
        return { safe: false, shouldBlock: false, confidence: 0.5 };
      }
    // Check for critical violations
    const critical = activeSeverityViolations.filter(v => v.severity === 'critical');
    if (critical.length >= 1) {
        return {
            safe: false,
            shouldBlock: true,
            confidence: Math.max(...critical.map(v => v.confidence))
        };
    }
    
    // Check for high severity - USE activeSeverityViolations NOT violations!
    const high = activeSeverityViolations.filter(v => v.severity === 'high');
    if (high.length >= 1) {
        return {
            safe: false,
            shouldBlock: true,
            confidence: Math.max(...high.map(v => v.confidence))
        };
    }
    
    // Check for medium severity - USE activeSeverityViolations NOT violations!
    const medium = activeSeverityViolations.filter(v => v.severity === 'medium');
    if (medium.length > 1) {
        return {
            safe: false,
            shouldBlock: false,
            confidence: Math.max(...medium.map(v => v.confidence))
        };
    }
    
    // Otherwise, flag but don't block
    return {
        safe: false,
        shouldBlock: false,
        confidence: Math.max(...violations.map(v => v.confidence))
    };
}
  
  generateCacheKey(text) {
    // Simple hash for cache key
    let hash = 0;
    for (let i = 0; i < text.length; i++) {
      const char = text.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash;
    }
    return hash.toString(36);
  }
  
  updateCache(key, result) {
    // LRU cache implementation
    if (this.cache.size >= this.config.cacheSize) {
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }
    
    this.cache.set(key, {
      safe: result.safe,
      violations: result.violations,
      shouldBlock: result.shouldBlock,
      timestamp: Date.now()
    });
  }
  
  updateMetrics(result, checkTime) {
    if (!this.config.enableMetrics) return;
    
    this.metrics.totalChecks++;
    
    if (result.shouldBlock) {
      this.metrics.blockedContent++;
    }
    
    for (const violation of result.violations) {
      const count = this.metrics.detectionsByCategory.get(violation.type) || 0;
      this.metrics.detectionsByCategory.set(violation.type, count + 1);
    }
    
    // Update average check time
    this.metrics.averageCheckTime = 
      (this.metrics.averageCheckTime * (this.metrics.totalChecks - 1) + checkTime) / 
      this.metrics.totalChecks;
    
    if (result.metadata?.obfuscationScore > 0.5) {
      this.metrics.obfuscationAttempts++;
    }
  }
  
  /**
   * Get current metrics
   */
  getMetrics() {
    return {
      ...this.metrics,
      cacheHitRate: this.cacheHits / (this.cacheHits + this.cacheMisses),
      topViolations: Array.from(this.metrics.detectionsByCategory.entries())
        .sort((a, b) => b[1] - a[1])
        .slice(0, 10)
    };
  }
  
  /**
   * Quick check method for performance-critical paths
   */
  quickCheck(text) {
    // Only check critical patterns without normalization
    const violations = [];
    
    for (const [category, config] of this.compiledPatterns.get('critical')) {
      for (const pattern of config.patterns) {
        if (pattern.test(text)) {
          violations.push({
            type: category,
            severity: 'critical',
            confidence: 1.0
          });
          break;
        }
      }
    }
    
  const verdict = this.calculateVerdict(violations);
  return {
    safe: verdict.safe,
    shouldBlock: verdict.shouldBlock,
    violations,
  };
  }
  
  /**
   * Export configuration for persistence
   */
  exportConfig() {
    return {
      version: '2.0.0',
      config: this.config,
      metrics: this.getMetrics(),
      customPatterns: this.config.customPatterns
    };
  }
  
  /**
   * Import configuration
   */
  importConfig(exported) {
    if (exported.version !== '2.0.0') {
      throw new Error('Incompatible configuration version');
    }
    
    this.config = { ...this.config, ...exported.config };
    this.initializePatterns();
    this.compiledPatterns = this.compilePatterns();
  }
}

// Export singleton instance
export const contentSafety = new ContentSafetySystem();


========================================
--- FILE: services/content-safety-wrapper.js
========================================
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Content-safety singleton with hot-loaded rule-packs (Vite edition)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

import { ContentSafetySystem } from './content-safety-lite.js';
 // Tiny baked-in fallback so the bundle builds even if the fetch fails.
const bundledDefaultPack = {
   profanity_basic: {
     severity: 'medium',
     patterns: ['\\b(fuck|shit|damn|uguslavia)\\b'],
     requiresContext: false
   },
   hate_slurs_core: {
     severity: 'high',
     patterns: ['\\b(kike|gook|wetback|tranny|hibeeka)\\b'],
     requiresContext: false
   },
   spam_links: {
     severity: 'low',
     patterns: [
       'https?:\\/\\/(?:[^\\s]+\\.)?(?:free-gift|win-big|click-here)[^\\s]*'
     ],
     requiresContext: false
   }
 };
const DEFAULT_RULE_PATH = '/rulepacks/default.json'; // looks in /public
let   instance   = null;   // the singleton
let   activePath = null;   // where the current rules came from

// -- 1. Load JSON  ------------------------------------------
async function loadJson(path) {
  // Browser / Vite dev server / production
  if (typeof fetch === 'function') {
    // Add ?t=TIMESTAMP so CTRL+S triggers a fresh request even with the same path
    const url = `${path}${path.includes('?') ? '&' : '?'}t=${Date.now()}`;
    const res = await fetch(url, { cache: 'no-store' }).catch(() => null);
    if (res && res.ok) return res.json();
    console.warn(`[ContentSafety] Fetch failed for ${path}, falling back to bundle`);
    return null;
  }


}

// -- 2. Build (or return) the singleton --------------------------------------
export async function getContentSafety(opts = {}) {
  if (instance) return instance;

  const path =
    opts.rulePackPath ||
    (typeof localStorage !== 'undefined' && localStorage.getItem('rulePackPath')) ||
    DEFAULT_RULE_PATH;

  const json = await loadJson(path);
  const customPatterns = json ?? bundledDefaultPack;

  instance   = new ContentSafetySystem({ customPatterns });
  activePath = json ? path : '(embedded default)';

  console.info(`[ContentSafety] Initialised with rules from ${activePath}`);
  return instance;
}

// -- 3. Helpers for pointing to a different local pack -----------------------
export async function setRulePackPath(path) {
  if (typeof localStorage !== 'undefined') {
    localStorage.setItem('rulePackPath', path);
  }
  await reloadRulePack(path);
}

export function getCurrentRulePackPath() {
  return activePath;
}

/** Re-reads the file from disk/server and swaps the patterns in-place. */
export async function reloadRulePack(path = activePath || DEFAULT_RULE_PATH) {
  if (!instance) throw new Error('ContentSafetySystem not initialised yet');

  const json = await loadJson(path);
  if (!json) throw new Error(`Could not load rule pack at ${path}`);

  instance.importConfig({
    version: '2.0.0',
    config : { customPatterns: json }
  });

  activePath = path;
  console.info(`[ContentSafety] Rule pack reloaded from ${path}`);
}


========================================
--- FILE: services/image-store.js
========================================
import { sendPeer } from '../p2p/network-manager.js'; 
import { generateId } from '../utils.js';
import { state } from '../state.js';


export class ContentAddressedImageStore {
    constructor() {
        this.chunks = new Map();
        this.images = new Map();
        this.maxChunkSize = 16 * 1024; // 16KB chunks
        this.maxTotalSize = 10 * 1024 * 1024; // 10MB total
        this.pendingRequests = new Map(); // Track pending requests
    }

    async sha256(data) {
        const encoder = new TextEncoder();
        const dataBuffer = encoder.encode(data);
        const hashBuffer = await crypto.subtle.digest('SHA-256', dataBuffer);
        const hashArray = Array.from(new Uint8Array(hashBuffer));
        return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    }

    async storeImage(base64Data) {
        // Remove data URL prefix if present
        const imageData = base64Data.replace(/^data:image\/\w+;base64,/, '');
        
        // ADDED: Validate image size before processing
        const estimatedSize = (imageData.length * 3) / 4; // Base64 to bytes estimation
        const MAX_IMAGE_SIZE = 5 * 1024 * 1024; // 5MB max per image
        
        if (estimatedSize > MAX_IMAGE_SIZE) {
            throw new Error(`Image too large: ${(estimatedSize / 1024 / 1024).toFixed(2)}MB (max 5MB)`);
        }
        
        // ADDED: Check total storage before adding
        let currentUsage = 0;
        for (const chunk of this.chunks.values()) {
            currentUsage += chunk.length;
        }
        
        if (currentUsage + estimatedSize > this.maxTotalSize) {
            // Force cleanup before rejecting
            this.cleanup();
            
            // Re-check after cleanup
            currentUsage = 0;
            for (const chunk of this.chunks.values()) {
                currentUsage += chunk.length;
            }
            
            if (currentUsage + estimatedSize > this.maxTotalSize) {
                throw new Error('Storage full - cannot store new images');
            }
        }

        // Check if we already have this image
        const imageHash = await this.sha256(imageData);
        if (this.images.has(imageHash)) {
            console.log(`[ImageStore] Image ${imageHash.substring(0, 8)}... already in store (cached).`);
            return { hash: imageHash, type: 'cached' };
        }

        // Rest of the method remains the same...
        // Chunk the image
        const chunks = [];
        const chunkHashes = [];
        for (let i = 0; i < imageData.length; i += this.maxChunkSize) {
            const chunk = imageData.slice(i, i + this.maxChunkSize);
            const chunkHash = await this.sha256(chunk);
            chunks.push({ hash: chunkHash, data: chunk, index: i / this.maxChunkSize });
            chunkHashes.push(chunkHash);

            if (!this.chunks.has(chunkHash)) {
                this.chunks.set(chunkHash, chunk);
                console.log(`[ImageStore] Stored new chunk ${chunkHash.substring(0, 8)}...`);
            } else {
                console.log(`[ImageStore] Chunk ${chunkHash.substring(0, 8)}... already exists.`);
            }
        }

        const merkleRoot = await this.buildMerkleTree(chunkHashes);
        console.log(`[ImageStore] Built Merkle Root for image ${imageHash.substring(0, 8)}...: ${merkleRoot?.substring(0, 8)}...`);

        this.images.set(imageHash, {
            merkleRoot,
            chunks: chunks.map(c => ({ hash: c.hash, index: c.index })),
            size: imageData.length,
            created: Date.now()
        });

        this.cleanup();

        return {
            hash: imageHash,
            merkleRoot,
            chunkCount: chunks.length,
            type: 'stored'
        };
    }

    async buildMerkleTree(hashes) {
        if (hashes.length === 0) return null;
        if (hashes.length === 1) return hashes[0];

        const pairs = [];
        for (let i = 0; i < hashes.length; i += 2) {
            const left = hashes[i];
            const right = hashes[i + 1] || hashes[i]; // Handle odd number of hashes by duplicating last one
            const combined = await this.sha256(left + right);
            pairs.push(combined);
        }
        return this.buildMerkleTree(pairs);
    }
    

    
    async retrieveImage(imageHash) {
        console.log(`[ImageStore] retrieveImage called for ${imageHash.substring(0, 8)}...`);

        if (this.pendingRequests.has(imageHash)) {
            console.log(`[ImageStore] Request already pending for ${imageHash.substring(0, 8)}...`);
            return this.pendingRequests.get(imageHash);
        }

        const requestPromise = this._retrieveImageInternal(imageHash)
            .finally(() => {
                this.pendingRequests.delete(imageHash);
            });

        this.pendingRequests.set(imageHash, requestPromise);
        return requestPromise;
    }

    async _retrieveImageInternal(imageHash) {
        const metadata = this.images.get(imageHash);
        if (!metadata) {
            console.warn(`[ImageStore] Cannot retrieve image ${imageHash.substring(0, 8)}...: Metadata not found.`);
            return null;
        }

        // Rest of the original retrieveImage logic...
        const missingChunks = [];
        const assembledChunks = new Array(metadata.chunks.length);
        const receivedChunkHashes = new Array(metadata.chunks.length);
        
        for (const chunkMeta of metadata.chunks) {
            const chunkData = this.chunks.get(chunkMeta.hash);
            if (chunkData) {
                assembledChunks[chunkMeta.index] = chunkData;
                receivedChunkHashes[chunkMeta.index] = chunkMeta.hash;
            } else {
                missingChunks.push(chunkMeta);
            }
        }

        if (missingChunks.length > 0) {
            console.log(`[ImageStore] Missing ${missingChunks.length} chunks for ${imageHash.substring(0, 8)}..., requesting from peers...`);
            
            const success = await this.requestChunksFromPeers(imageHash, missingChunks);
            if (!success) {
                console.error(`[ImageStore] Failed to retrieve chunks for ${imageHash.substring(0, 8)}...`);
                return null;
            }
            
            for (const chunkMeta of metadata.chunks) {
                const chunkData = this.chunks.get(chunkMeta.hash);
                if (!chunkData) {
                    console.error(`[ImageStore] Still missing chunk ${chunkMeta.hash.substring(0, 8)}... after peer request`);
                    return null;
                }
                assembledChunks[chunkMeta.index] = chunkData;
                receivedChunkHashes[chunkMeta.index] = chunkMeta.hash;
            }
        }

        const reconstructedMerkleRoot = await this.buildMerkleTree(receivedChunkHashes);
        if (reconstructedMerkleRoot !== metadata.merkleRoot) {
            console.error(`[ImageStore] Merkle Root mismatch for image ${imageHash.substring(0, 8)}...!`);
            return null;
        }

        const fullImageData = assembledChunks.join('');
        console.log(`[ImageStore] Successfully retrieved and verified image ${imageHash.substring(0, 8)}...`);
        return 'data:image/jpeg;base64,' + fullImageData;
    }

    // method to handle peer requests
    async requestChunksFromPeers(imageHash, missingChunks) {
        return new Promise((resolve) => {
            const peers = Array.from(state.peers.values());
            if (peers.length === 0) {
                console.error(`[ImageStore] No peers available to request chunks from`);
                return resolve(false);
            }

            const requestId = generateId(); // Unique ID for this request
            let receivedChunks = new Set();
            const neededCount = missingChunks.length;

            const timeout = setTimeout(() => {
                window.removeEventListener(`chunk_received_${requestId}`, listener);
                console.log(`[ImageStore] Timeout requesting chunks for ${imageHash.substring(0, 8)}...`);
                resolve(receivedChunks.size === neededCount);
            }, 10000);

            const listener = (event) => {
                const { detail } = event;
                if (detail.imageHash === imageHash && !receivedChunks.has(detail.chunkHash)) {
                    receivedChunks.add(detail.chunkHash);
                    if (receivedChunks.size >= neededCount) {
                        clearTimeout(timeout);
                        window.removeEventListener(`chunk_received_${requestId}`, listener);
                        resolve(true);
                    }
                }
            };
            window.addEventListener(`chunk_received_${requestId}`, listener);

            const requestMessage = {
                type: 'request_image_chunks',
                imageHash: imageHash,
                chunkHashes: missingChunks.map(c => c.hash),
                requestId: requestId // Include the unique ID in the request
            };

            peers.forEach((peerData) => {
                const { wire } = peerData;
                if (wire && !wire.destroyed && wire.ephemeral_msg?._ready) {
                    sendPeer(wire, requestMessage);
                }
            });
        });
    }
    
    async retryChunkRequests(imageHash, maxRetries = 3) {
        const metadata = this.images.get(imageHash);
        if (!metadata) return false;
        
        let attempt = 0;
        while (attempt < maxRetries) {
            const missingChunks = metadata.chunks.filter(
                chunkMeta => !this.chunks.has(chunkMeta.hash)
            );
            
            if (missingChunks.length === 0) {
                return true; // All chunks available
            }
            
            console.log(`[ImageStore] Retry attempt ${attempt + 1}/${maxRetries} for ${missingChunks.length} chunks`);
            
            const success = await this.requestChunksFromPeers(imageHash, missingChunks);
            if (success) {
                return true;
            }
            
            attempt++;
            // Wait before retrying (exponential backoff)
            await new Promise(resolve => setTimeout(resolve, 1000 * Math.pow(2, attempt)));
        }
        
        return false;
    }
    // method to handle incoming chunk responses
    handleChunkResponse(chunkHash, chunkData, imageHash) {
        console.log(`[ImageStore] Received chunk ${chunkHash.substring(0, 8)}... for image ${imageHash.substring(0, 8)}...`);
        
        // Store the chunk
        this.chunks.set(chunkHash, chunkData);
        
        // Notify the request handler
        if (this.onChunkReceived) {
            this.onChunkReceived(chunkHash, chunkData, imageHash);
        }
    }

    cleanup() {
        let totalSize = 0;
        for (const chunk of this.chunks.values()) {
            totalSize += chunk.length;
        }

        console.log(`[ImageStore] Current total storage usage: ${(totalSize / 1024).toFixed(2)} KB (Max: ${(this.maxTotalSize / 1024 / 1024).toFixed(2)} MB)`);

        if (totalSize > this.maxTotalSize) {
            console.log(`[ImageStore] Initiating cleanup due to high memory usage.`);
            const sortedImages = Array.from(this.images.entries())
                .sort((a, b) => a[1].created - b[1].created);

            let cleanedUpSize = 0;
            while (totalSize > this.maxTotalSize * 0.7 && sortedImages.length > 0) {
                const [hash, metadata] = sortedImages.shift();
                console.log(`[ImageStore] Cleaning up image ${hash.substring(0, 8)}... (oldest)`);

                this.images.delete(hash);

                const chunksToDelete = new Set(metadata.chunks.map(c => c.hash));

                for (const [otherHash, otherMeta] of this.images) {
                    otherMeta.chunks.forEach(c => chunksToDelete.delete(c.hash));
                }

                for (const chunkHash of chunksToDelete) {
                    const chunkData = this.chunks.get(chunkHash);
                    if (chunkData) {
                        totalSize -= chunkData.length;
                        cleanedUpSize += chunkData.length;
                        this.chunks.delete(chunkHash);
                        console.log(`[ImageStore] Deleted unreferenced chunk ${chunkHash.substring(0, 8)}...`);
                    }
                }
            }
            console.log(`[ImageStore] Cleanup complete. Removed ${(cleanedUpSize / 1024).toFixed(2)} KB.`);
        }
    }
}


========================================
--- FILE: services/instances.js
========================================
// services/instances.js
let stateManager, verificationQueue, imageStore, peerManager, memoryManager;
let progressiveVDF, noiseGenerator, trafficMixer, epidemicGossip;

export function getServices() {
  return {
    stateManager,
    verificationQueue,
    imageStore,
    peerManager,
    memoryManager,
    progressiveVDF,
    noiseGenerator,
    trafficMixer,
    epidemicGossip
  };
}

export function setServices(services) {
  ({
    stateManager,
    verificationQueue,
    imageStore,
    peerManager,
    memoryManager,
    progressiveVDF,
    noiseGenerator,
    trafficMixer,
    epidemicGossip
  } = services);
}

export const getStateManager = () => stateManager;
export const getImageStore = () => imageStore;
export const getPeerManager = () => peerManager;


========================================
--- FILE: services/memory-manager.js
========================================
// --- IMPORTS ---
import { state } from '../state.js';
import { serviceCallbacks } from './callbacks.js';
import { HierarchicalBloomFilter, BloomFilter, isReply } from '../utils.js';


export class MemoryManager {
  constructor() {
    this.checkInterval = 30000;
    this.targetMemoryUsage = 0.7;
    this.criticalMemoryUsage = 0.85;
    this.postScores = new Map();
    this.startMonitoring();
  }
  
  calculatePostPriority(post) {
    const now = Date.now();
    const age = (now - post.timestamp) / (1000 * 60 * 60); // hours
    const isExplicitlyCarried = state.explicitlyCarrying.has(post.id);
    const carrierCount = post.carriers.size;
    const replyCount = post.replies.size;
    
    // Calculate heat score
    const heat = carrierCount + (replyCount * 2);
    
    // Priority formula
    let priority = heat / Math.pow(age + 1, 1.5); // Decay over time
    
    // Boost for explicit carries
    if (isExplicitlyCarried) priority *= 100;
    
    // Boost for posts we authored
    if (post.author === state.myIdentity.handle) priority *= 10;
    
  // Boost for replies in active threads
  if (post.parentId) {
    const parent = state.posts.get(post.parentId);
    if (parent && parent.carriers.size > 0) {
      priority *= 5; // Keep replies to carried posts
    }
  }
  
  return priority;
}

  
  async getMemoryUsage() {
    if (performance.memory) {
      return {
        used: performance.memory.usedJSHeapSize,
        total: performance.memory.jsHeapSizeLimit,
        ratio: performance.memory.usedJSHeapSize / performance.memory.jsHeapSizeLimit
      };
    }
    
    // Fallback: estimate based on post count
    const avgPostSize = 2048; // 2KB average
    const estimatedUsage = state.posts.size * avgPostSize;
    return {
      used: estimatedUsage,
      total: 100 * 1024 * 1024, // 100MB assumed limit
      ratio: estimatedUsage / (100 * 1024 * 1024)
    };
  }
  
  async checkMemory() {
    const memory = await this.getMemoryUsage();
    
    // Update post scores periodically
    if (Math.random() < 0.1 || memory.ratio > this.targetMemoryUsage) {
      this.updatePostScores();
    }
    
    if (memory.ratio > this.criticalMemoryUsage) {
      console.warn(`Critical memory usage: ${Math.round(memory.ratio * 100)}%`);
      await this.emergencyCleanup();
    } else if (memory.ratio > this.targetMemoryUsage) {
      console.log(`High memory usage: ${Math.round(memory.ratio * 100)}%`);
      await this.adaptiveCleanup(memory.ratio);
    }
  }
  
  updatePostScores() {
    this.postScores.clear();
    for (const [id, post] of state.posts) {
      this.postScores.set(id, this.calculatePostPriority(post));
    }
  }
  
      async adaptiveCleanup(memoryRatio) {
        const targetRatio = 0.5;
        const reductionFactor = targetRatio / memoryRatio;
        const targetPostCount = Math.floor(state.posts.size * reductionFactor);
        
        // Sort posts by priority
        const sortedPosts = Array.from(state.posts.entries())
            .map(([id, post]) => ({
                id,
                post,
                priority: this.postScores.get(id) || this.calculatePostPriority(post)
            }))
            .sort((a, b) => b.priority - a.priority);
        
        // Keep only the highest priority posts, but NEVER remove replies
        const toKeep = new Set();
        let keptCount = 0;
        
        for (const { id, post } of sortedPosts) {
            if (keptCount < targetPostCount || isReply(post) || state.explicitlyCarrying.has(id)) {
                toKeep.add(id);
                if (!isReply(post)) {  // Only count non-replies against target
                    keptCount++;
                }
            }
        }
        
        // Remove low priority posts (but never replies)
        for (const [id, post] of state.posts) {
            if (!toKeep.has(id) && !isReply(post) && !state.explicitlyCarrying.has(id)) {
                // Only drop if no one else is carrying AND it's not a reply
                if (post.carriers.size === 0) {
                    if (!serviceCallbacks.debugPostRemoval(id, 'adaptive cleanup')) {
                        state.posts.delete(id);
                        serviceCallbacks.dropPost(id);
                    }
                }
            }
        }
        
    }
    
    async emergencyCleanup() {
        // Keep only explicitly carried posts, very recent posts, AND ALL REPLIES
        const oneHourAgo = Date.now() - (60 * 60 * 1000);
        const toKeep = new Set();
        
        for (const [id, post] of state.posts) {
            if (state.explicitlyCarrying.has(id) || 
                post.timestamp > oneHourAgo ||
                post.author === state.myIdentity.handle ||
                isReply(post)) { // NEW: Always keep replies
                toKeep.add(id);
            }
        }
            
        // Remove everything else (except replies)
        for (const id of state.posts.keys()) {
            if (!toKeep.has(id)) {
                const post = state.posts.get(id);
                // Only drop if no one is carrying AND it's not a reply
                if (post && post.carriers.size === 0 && !isReply(post)) {
                    if (!serviceCallbacks.debugPostRemoval(id, 'emergency cleanup')) {
                        state.posts.delete(id);
                        serviceCallbacks.dropPost(id);
                    }
                }
            }
        }
        
        // Force garbage collection if available
        if (window.gc) {
            window.gc();
        }
        
        console.log(`Emergency cleanup: kept ${toKeep.size} posts`);
    }
  
  startMonitoring() {
    
    // More frequent checks during high activity
    document.addEventListener('visibilitychange', () => {
      if (!document.hidden) {
        this.checkMemory();
      }
    });
  }
}


========================================
--- FILE: services/naive-bayes-classifier.js
========================================
/**
 * naive-bayes-classifier.js
 * * A simple Naive Bayes Classifier for text classification.
 * * Includes methods to save and load the trained model from a file.
 * * @version 1.2.0-browser
 */
import PRE_TRAINED_MODEL from './model_weights.json' assert { type: 'json' };


export class NaiveBayesClassifier {
    constructor() {
        this.wordCounts = { safe: {}, not_safe: {} };
        this.docCounts = { safe: 0, not_safe: 0 };
        this.vocab = new Set();
        this.smoothing = 1; // Laplace smoothing
    }

    /**
     * A simple tokenizer to split text into words, lowercase, and remove punctuation.
     * @param {string} text - The input string.
     * @returns {string[]} An array of tokenized words.
     */
    tokenize(text) {
        if (typeof text !== 'string') return [];
        const cleanedText = text.replace(/[^\w\s]/g, '').toLowerCase();
        return cleanedText.split(/\s+/).filter(word => word.length > 0);
    }



    /**
     * Predicts the label for a given text.
     * @param {string} text - The text to classify.
     * @returns {{label: string, probability: number}} The predicted label and its probability score.
     */
    predict(text) {
        console.log("predict called on " + text);
        const tokens = this.tokenize(text);
        const totalDocs = this.docCounts.safe + this.docCounts.not_safe;
        if (totalDocs === 0) return { label: 'safe', probability: 1.0 };

        const priorSafe = Math.log(this.docCounts.safe / totalDocs);
        const priorNotSafe = Math.log(this.docCounts.not_safe / totalDocs);

        let scoreSafe = priorSafe;
        let scoreNotSafe = priorNotSafe;

        const totalWordsSafe = Object.values(this.wordCounts.safe).reduce((a, b) => a + b, 0);
        const totalWordsNotSafe = Object.values(this.wordCounts.not_safe).reduce((a, b) => a + b, 0);
        const vocabSize = this.vocab.size;

        for (const token of tokens) {
            const wordCountSafe = this.wordCounts.safe[token] || 0;
            const probWordSafe = Math.log((wordCountSafe + this.smoothing) / (totalWordsSafe + vocabSize * this.smoothing));
            scoreSafe += probWordSafe;

            const wordCountNotSafe = this.wordCounts.not_safe[token] || 0;
            const probWordNotSafe = Math.log((wordCountNotSafe + this.smoothing) / (totalWordsNotSafe + vocabSize * this.smoothing));
            scoreNotSafe += probWordNotSafe;
        }

        const expScoreSafe = Math.exp(scoreSafe);
        const expScoreNotSafe = Math.exp(scoreNotSafe);
        const totalExpScore = expScoreSafe + expScoreNotSafe;

        const probSafe = expScoreSafe / totalExpScore;
        const probNotSafe = expScoreNotSafe / totalExpScore;

        if (probNotSafe > probSafe) {
            return { label: 'not_safe', probability: probNotSafe };
        } else {
            return { label: 'safe', probability: probSafe };
        }
    }


    /**
     * Loads a pre-trained model from a URL on your server.
     * @param {string} filePath - The path to the model file (e.g., '/services/nbc_model.json').
     */
    loadModel() {
        try {
            this.wordCounts = PRE_TRAINED_MODEL.wordCounts;
            this.docCounts = PRE_TRAINED_MODEL.docCounts;
            this.vocab = new Set(PRE_TRAINED_MODEL.vocab);
            console.log("Embedded model successfully loaded.");
        } catch (err) {
            console.error("Error loading embedded model. Check the PRE_TRAINED_MODEL object.", err);
        }
    }
}


========================================
--- FILE: services/peer-manager.js
========================================
import { state } from '../state.js';

export class PeerManager {
  constructor() {
    this.scores = new Map();
    
    // Reputation thresholds
    this.REPUTATION_LEVELS = {
      UNTRUSTED: 0,
      NEW: 10,
      BASIC: 50,
      TRUSTED: 100,
      HIGHLY_TRUSTED: 500
    };
    
    // Action weights for reputation calculation
    this.ACTION_WEIGHTS = {
      CONNECTION: 1,
      MESSAGE: 0.1,
      POST: 5,
      VALID_POST: 10,
      INVALID_POST: -50,
      ATTESTATION: 2,
      CORRECT_ATTESTATION: 20,
      FALSE_ATTESTATION: -100,
      UPTIME_HOUR: 1
    };
  }
  
  // Initialize or get peer data
  getPeerData(peerId) {
    if (!this.scores.has(peerId)) {
      this.scores.set(peerId, {
        // Basic metrics
        messages: 0,
        posts: 0,
        validPosts: 0,
        invalidPosts: 0,
        
        // Attestation metrics
        attestations: 0,
        correctAttestations: 0,
        falseAttestations: 0,
        
        // Connection metrics
        firstSeen: Date.now(),
        uptime: Date.now(),
        disconnections: 0,
        
        // Quality metrics
        quality: 1.0,
        reputationScore: 0,
        lastCalculated: 0
      });
    }
    return this.scores.get(peerId);
  }
  
  updateScore(peerId, action, value = 1) {
    const data = this.getPeerData(peerId);
    
    switch(action) {
      case 'connection':
        data.uptime = Date.now();
        data.reputationScore += this.ACTION_WEIGHTS.CONNECTION * value;
        break;
        
      case 'disconnection':
        data.disconnections += 1;
        data.quality *= 0.95; // Small quality penalty for disconnections
        break;
        
      case 'message':
        data.messages += value;
        break;
        
      case 'post':
        data.posts += value;
        data.reputationScore += this.ACTION_WEIGHTS.POST * value;
        break;
        
      case 'valid_post':
        data.validPosts += value;
        data.reputationScore += this.ACTION_WEIGHTS.VALID_POST * value;
        break;
        
      case 'invalid_post':
        data.invalidPosts += value;
        data.reputationScore += this.ACTION_WEIGHTS.INVALID_POST * value;
        data.quality *= 0.8; // Significant quality penalty
        break;
        
      case 'attestation':
        data.attestations += value;
        data.reputationScore += this.ACTION_WEIGHTS.ATTESTATION * value;
        break;
        
      case 'correct_attestation':
        data.correctAttestations += value;
        data.reputationScore += this.ACTION_WEIGHTS.CORRECT_ATTESTATION * value;
        data.quality = Math.min(1.5, data.quality * 1.02); // Slight quality boost
        break;
        
      case 'false_attestation':
        data.falseAttestations += value;
        data.reputationScore += this.ACTION_WEIGHTS.FALSE_ATTESTATION * value;
        data.quality *= 0.5; // Major quality penalty
        break;
        
      case 'data':
        // Legacy support for data transfer tracking
        break;
        
      case 'error':
        data.quality *= 0.9;
        break;
    }
    
    // Ensure reputation doesn't go below 0
    data.reputationScore = Math.max(0, data.reputationScore);
    
    // Mark as needing recalculation
    data.lastCalculated = 0;
  }
  
  // Calculate comprehensive reputation score
  getScore(peerId) {
    const data = this.getPeerData(peerId);
    
    // Recalculate if needed (cached for 1 minute)
    if (Date.now() - data.lastCalculated > 60000) {
      // Calculate uptime bonus
      const ageHours = (Date.now() - data.firstSeen) / (1000 * 60 * 60);
      const uptimeBonus = ageHours * this.ACTION_WEIGHTS.UPTIME_HOUR;
      
      // Calculate attestation accuracy
      const totalAttestationAttempts = data.correctAttestations + data.falseAttestations;
      const attestationAccuracy = totalAttestationAttempts > 0 
        ? data.correctAttestations / totalAttestationAttempts 
        : 0.5; // Default to neutral if no attestations
      
      // Calculate post validity rate
      const totalPostAttempts = data.validPosts + data.invalidPosts;
      const postValidityRate = totalPostAttempts > 0
        ? data.validPosts / totalPostAttempts
        : 0.5; // Default to neutral
      
      // Combine all factors
      const baseScore = data.reputationScore + uptimeBonus;
      const accuracyMultiplier = (attestationAccuracy * 0.5) + (postValidityRate * 0.5);
      const finalScore = baseScore * data.quality * accuracyMultiplier;
      
      // Cache the calculated score
      data.calculatedScore = Math.max(0, finalScore);
      data.lastCalculated = Date.now();
      
      console.log(`[PeerManager] Calculated reputation for ${peerId}:`, {
        baseScore: baseScore.toFixed(2),
        quality: data.quality.toFixed(2),
        attestationAccuracy: (attestationAccuracy * 100).toFixed(1) + '%',
        postValidityRate: (postValidityRate * 100).toFixed(1) + '%',
        finalScore: data.calculatedScore.toFixed(2)
      });
    }
    
    return data.calculatedScore || 0;
  }
  
  // Get reputation level for a peer
  getReputationLevel(peerId) {
    const score = this.getScore(peerId);
    
    if (score >= this.REPUTATION_LEVELS.HIGHLY_TRUSTED) return 'HIGHLY_TRUSTED';
    if (score >= this.REPUTATION_LEVELS.TRUSTED) return 'TRUSTED';
    if (score >= this.REPUTATION_LEVELS.BASIC) return 'BASIC';
    if (score >= this.REPUTATION_LEVELS.NEW) return 'NEW';
    return 'UNTRUSTED';
  }
  
  // Check if peer is trusted enough to accept attestations
  canTrustAttestations(peerId) {
    const level = this.getReputationLevel(peerId);
    return level === 'TRUSTED' || level === 'HIGHLY_TRUSTED';
  }
  
  // Get best peers by reputation
  getBestPeers(count = 10) {
    return Array.from(state.peers.entries())
      .map(([id, peer]) => ({ 
        id, 
        peer, 
        score: this.getScore(id),
        level: this.getReputationLevel(id)
      }))
      .sort((a, b) => b.score - a.score)
      .slice(0, count)
      .map(item => item.peer);
  }
  
  // Get reputation statistics
  getReputationStats() {
    const stats = {
      totalPeers: 0,
      untrusted: 0,
      new: 0,
      basic: 0,
      trusted: 0,
      highlyTrusted: 0
    };
    
    for (const [peerId] of state.peers) {
      stats.totalPeers++;
      const level = this.getReputationLevel(peerId).toLowerCase().replace('_', '');
      stats[level]++;
    }
    
    return stats;
  }
  
  // Debug method to see all peer reputations
  debugReputations() {
    const peers = [];
    
    for (const [peerId] of state.peers) {
      const data = this.getPeerData(peerId);
      const score = this.getScore(peerId);
      
      peers.push({
        id: peerId.substring(0, 8) + '...',
        score: score.toFixed(2),
        level: this.getReputationLevel(peerId),
        posts: data.posts,
        validPosts: data.validPosts,
        attestations: data.attestations,
        accuracy: data.attestations > 0 
          ? ((data.correctAttestations / (data.correctAttestations + data.falseAttestations)) * 100).toFixed(1) + '%'
          : 'N/A'
      });
    }
    
    return peers.sort((a, b) => parseFloat(b.score) - parseFloat(a.score));
  }
}


========================================
--- FILE: services/routing-manager.js
========================================
import { state } from '../state.js';
import { arrayBufferToBase64 } from '../utils.js';
import { sendPeer } from '../p2p/network-manager.js';

export class RoutingManager {
  constructor() {
    this.routingInterval = 120000; // 2 minutes
    this.heartbeatInterval = 30000; // 30 seconds
    this.lastKnownPeerId = null;
    this.routingUpdateTimer = null;
    this.heartbeatTimer = null;
    this.routingFailures = 0;
    this.maxFailures = 3;
  }
  
  async start() {
    console.log('[RoutingManager] Starting routing management');
    
    // Initial routing announcement
    await this.updateRouting();
    
    // Start periodic updates
    this.routingUpdateTimer = setInterval(() => {
      this.updateRouting().catch(e => {
        console.error('[RoutingManager] Routing update failed:', e);
        this.handleRoutingFailure();
      });
    }, this.routingInterval);
    
    // Start heartbeat
    this.heartbeatTimer = setInterval(() => {
      this.sendHeartbeat().catch(e => 
        console.error('[RoutingManager] Heartbeat failed:', e)
      );
    }, this.heartbeatInterval);
    
    // Monitor peer ID changes
    this.monitorPeerIdChanges();
  }
  
  stop() {
    if (this.routingUpdateTimer) {
      clearInterval(this.routingUpdateTimer);
      this.routingUpdateTimer = null;
    }
    if (this.heartbeatTimer) {
      clearInterval(this.heartbeatTimer);
      this.heartbeatTimer = null;
    }
  }
  
  async updateRouting(force = false) {
    if (!state.myIdentity || !state.identityRegistry) {
      console.log('[RoutingManager] No identity, skipping routing update');
      return;
    }
    
    const currentPeerId = this.getCurrentPeerId();
    if (!currentPeerId) {
      console.log('[RoutingManager] No active connections, skipping routing update');
      return;
    }
    
    // Check if peer ID changed
    const peerIdChanged = this.lastKnownPeerId && this.lastKnownPeerId !== currentPeerId;
    if (peerIdChanged) {
      console.log(`[RoutingManager] Peer ID changed from ${this.lastKnownPeerId} to ${currentPeerId}`);
      force = true;
    }

    
    try {
      // Update routing in DHT
      await state.identityRegistry.updatePeerLocation(
        state.myIdentity.handle,
        state.myIdentity.nodeId,
        currentPeerId
      );
      
      // Broadcast routing announcement to all peers
      await this.broadcastRoutingUpdate(currentPeerId);
      
      this.lastKnownPeerId = currentPeerId;
      this.routingFailures = 0;
      
      console.log(`[RoutingManager] Routing updated successfully with peer ID: ${currentPeerId}`);
      
    } catch (error) {
      console.error('[RoutingManager] Failed to update routing:', error);
      throw error;
    }
  }
  
  getCurrentPeerId() {
    // Try to get our peer ID from WebTorrent client
    if (state.client && state.client.peerId) {
      return state.client.peerId;
    }
    
    // Fallback: get from any active wire connection
    for (const [peerId, peerData] of state.peers) {
      if (peerData.wire && !peerData.wire.destroyed && peerData.wire._client) {
        const clientPeerId = peerData.wire._client.peerId;
        if (clientPeerId) {
          return clientPeerId;
        }
      }
    }
    
    return null;
  }
  
  async broadcastRoutingUpdate(peerId) {
    const announcement = {
      type: 'routing_update',
      handle: state.myIdentity.handle,
      nodeId: arrayBufferToBase64(state.myIdentity.nodeId),
      peerId: peerId,
      timestamp: Date.now(),
      publicKey: state.myIdentity.publicKey
    };
    
    // Send to all connected peers
    let sentCount = 0;
    for (const [_, peerData] of state.peers) {
      if (peerData.wire && !peerData.wire.destroyed) {
        try {
          sendPeer(peerData.wire, announcement);
          sentCount++;
        } catch (e) {
          console.error('[RoutingManager] Failed to send routing update to peer:', e);
        }
      }
    }
    
    console.log(`[RoutingManager] Broadcasted routing update to ${sentCount} peers`);
  }
  
  async sendHeartbeat() {
    if (!state.myIdentity || state.peers.size === 0) {
      return;
    }
    
    const heartbeat = {
      type: 'routing_heartbeat',
      handle: state.myIdentity.handle,
      timestamp: Date.now()
    };
    
    // Send to a subset of peers
    const peers = Array.from(state.peers.values());
    const maxHeartbeatPeers = Math.min(3, peers.length);
    
    for (let i = 0; i < maxHeartbeatPeers; i++) {
      const peer = peers[Math.floor(Math.random() * peers.length)];
      if (peer.wire && !peer.wire.destroyed) {
        sendPeer(peer.wire, heartbeat);
      }
    }
  }
  
  monitorPeerIdChanges() {
    // Set up a WebTorrent client event listener if possible
    if (state.client) {
      // Listen for reconnection events
      state.client.on('error', (err) => {
        if (err.message.includes('connection')) {
          console.log('[RoutingManager] Connection error detected, will update routing on reconnect');
          this.routingFailures++;
        }
      });
    }
    
    // Also monitor peer count changes
    let lastPeerCount = state.peers.size;
    setInterval(() => {
      const currentPeerCount = state.peers.size;
      
      // If we lost all peers and regained some, force routing update
      if (lastPeerCount === 0 && currentPeerCount > 0) {
        console.log('[RoutingManager] Regained connectivity, forcing routing update');
        this.updateRouting(true).catch(e => 
          console.error('[RoutingManager] Failed to update after reconnection:', e)
        );
      }
      
      lastPeerCount = currentPeerCount;
    }, 5000);
  }
  
  handleRoutingFailure() {
    this.routingFailures++;
    
    if (this.routingFailures >= this.maxFailures) {
      console.error('[RoutingManager] Max routing failures reached, resetting');
      this.routingFailures = 0;
      
      // Try to rejoin the network
      if (state.dht) {
        state.dht.bootstrap().then(() => {
          console.log('[RoutingManager] DHT re-bootstrapped after routing failures');
          this.updateRouting(true);
        });
      }
    }
  }
  
  // Get stats for debugging
  getStats() {
    return {
      currentPeerId: this.getCurrentPeerId(),
      lastKnownPeerId: this.lastKnownPeerId,
      routingFailures: this.routingFailures,
      isRunning: !!this.routingUpdateTimer
    };
  }
}

// Create singleton instance
export const routingManager = new RoutingManager();


========================================
--- FILE: vdf-wasm/Cargo.toml
========================================
[package]
name = "vdf-wasm"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib"]

[dependencies]
wasm-bindgen = { version = "0.2", features = ["serde-serialize"] }
num-bigint = { version = "0.4", features = ["rand"] }  # Add rand feature

num-traits = "0.2"
num-integer = "0.1"  # Add this
sha2 = "0.10"
base64 = "0.21"
serde = { version = "1.0", features = ["derive"] }  # Add this
serde_json = "1.0"
rand = { version = "0.8.5", features = ["getrandom"] }

getrandom = { version = "0.2", features = ["js"] }
js-sys = "0.3.77"

[profile.release]
opt-level = 3
lto = true
[package.metadata.wasm-pack.profile.release]
wasm-opt = false        # <-- skip wasm-opt for --release builds

[package.metadata.wasm-pack.profile.dev]
wasm-opt = false        # <-- skip it for --dev too, just in case


========================================
--- FILE: vdf-wasm/src/lib.rs
========================================
//! Wesolowski's Verifiable Delay Function (VDF) Implementation for WASM
//! 
//! This implementation provides cryptographically secure time-lock puzzles
//! with efficient verification. Based on the paper "Efficient Verifiable Delay Functions"
//! by Krzysztof Pietrzak (2018) and Benjamin Wesolowski (2019).

use wasm_bindgen::prelude::*;
use num_bigint::{BigUint, RandBigInt};
use num_traits::{Zero, One};
use num_integer::Integer;
use sha2::{Sha256, Digest};
use rand::thread_rng;
use base64::{Engine as _, engine::general_purpose};
use js_sys::Function;
use serde::{Serialize, Deserialize};

/// RSA-2048 modulus from the RSA Factoring Challenge
/// This modulus has unknown factorization, making it suitable for VDF
const RSA_2048_MODULUS: &str = "C7970CEEDCC3B0754490201A7AA613CD73911081C790F5F1A8726F463550BB5B7FF0DB8E1EA1189EC72F93D1650011BD721AEEACC2ACDE32A04107F0648C2813A31F5B0B7765FF8B44B4B6FFC93384B646EB09C7CF5E8592D40EA33C80039F35B4F14A04B51F7BFD781BE4D1673164BA8EB991C2C4D730BBBE35F592BDEF524AF7E8DAEFD26C66FC02C479AF89D64D373F442709439DE66CEB955F3EA37D5159F6135809F85334B5CB1813ADDC80CD05609F10AC6A95AD65872C909525BDAD32BC729592642920F24C61DC5B3C3B7923E56B16A4D9D373D8721F24A3FC0F1B3131F55615172866BCCC30F95054C824E733A5EB6817F7BC16399D48C6361CC7E5";

/// Security parameter for prime generation (bits)
const SECURITY_BITS: usize = 128;

/// Maximum allowed iterations to prevent DoS
const MAX_ITERATIONS: u64 = 100_000_000;

/// Minimum iterations for meaningful delay
const MIN_ITERATIONS: u64 = 1000;

/// Progress reporting interval
const PROGRESS_INTERVAL: u64 = 10000;

// Enable console logging for debugging
#[wasm_bindgen]
extern "C" {
    #[wasm_bindgen(js_namespace = console)]
    fn log(s: &str);
    
    #[wasm_bindgen(js_namespace = console)]
    fn error(s: &str);
    
    #[wasm_bindgen(js_namespace = console)]
    fn warn(s: &str);
}

/// Macro for debug logging
macro_rules! debug_log {
    ($($t:tt)*) => (log(&format_args!($($t)*).to_string()))
}

/// Macro for error logging
macro_rules! error_log {
    ($($t:tt)*) => (error(&format_args!($($t)*).to_string()))
}

/// VDF Proof structure containing all verification parameters
#[wasm_bindgen]
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct VDFProof {
    /// Output: y = x^(2^t) mod N
    y: String,
    
    /// Proof value: œÄ such that y = œÄ^l * x^r mod N
    pi: String,
    
    /// Challenge prime (deterministically generated via Fiat-Shamir)
    l: String,
    
    /// Remainder: r = 2^t mod l
    r: String,
    
    /// Number of iterations (time parameter)
    iterations: u64,
    
    /// Proof generation timestamp (for audit trail)
    #[serde(skip)]
    timestamp: u64,
}

#[wasm_bindgen]
impl VDFProof {
    #[wasm_bindgen(constructor)]
    pub fn new(y: String, pi: String, l: String, r: String, iterations: u64) -> Self {
        VDFProof {
            y,
            pi,
            l,
            r,
            iterations,
            timestamp: js_sys::Date::now() as u64,
        }
    }
    
    #[wasm_bindgen(getter)]
    pub fn y(&self) -> String {
        self.y.clone()
    }
    
    #[wasm_bindgen(getter)]
    pub fn pi(&self) -> String {
        self.pi.clone()
    }
    
    #[wasm_bindgen(getter)]
    pub fn l(&self) -> String {
        self.l.clone()
    }
    
    #[wasm_bindgen(getter)]
    pub fn r(&self) -> String {
        self.r.clone()
    }
    
    #[wasm_bindgen(getter)]
    pub fn iterations(&self) -> u64 {
        self.iterations
    }
    
    /// Serialize proof to JSON
    #[wasm_bindgen]
    pub fn to_json(&self) -> Result<String, JsValue> {
        serde_json::to_string(self)
            .map_err(|e| JsValue::from_str(&format!("Serialization error: {}", e)))
    }
    
    /// Deserialize proof from JSON
    #[wasm_bindgen]
    pub fn from_json(json: &str) -> Result<VDFProof, JsValue> {
        serde_json::from_str(json)
            .map_err(|e| JsValue::from_str(&format!("Deserialization error: {}", e)))
    }
}

/// Main VDF computer with optimized algorithms
#[wasm_bindgen]
pub struct VDFComputer {
    modulus: BigUint,
    /// Precomputed Montgomery parameters for faster modular arithmetic
    montgomery_r: BigUint,
    montgomery_r_inv: BigUint,
}

#[wasm_bindgen]
impl VDFComputer {
    /// Create a new VDF computer with the RSA-2048 modulus
    #[wasm_bindgen(constructor)]
    pub fn new() -> VDFComputer {
        let modulus = BigUint::parse_bytes(RSA_2048_MODULUS.as_bytes(), 16)
            .expect("Failed to parse modulus");
        
        let montgomery_r = BigUint::one() << modulus.bits();
        let montgomery_r_inv = montgomery_r.clone();
        
        VDFComputer {
            modulus,
            montgomery_r,
            montgomery_r_inv,
        }
    }
    
    /// Create a VDF computer with a custom modulus (hex string)
    #[wasm_bindgen]
    pub fn with_modulus(modulus_hex: &str) -> Result<VDFComputer, JsValue> {
        let modulus = BigUint::parse_bytes(modulus_hex.as_bytes(), 16)
            .ok_or_else(|| JsValue::from_str("Invalid modulus format"))?;
        
        // Validate modulus is odd and large enough
        if modulus.is_even() || modulus.bits() < 1024 {
            return Err(JsValue::from_str("Modulus must be odd and at least 1024 bits"));
        }
        
        // Precompute Montgomery parameters (simplified for this example)
        let montgomery_r = BigUint::one() << modulus.bits();
        let montgomery_r_inv = montgomery_r.clone();
        
        Ok(VDFComputer {
            modulus,
            montgomery_r,
            montgomery_r_inv,
        })
    }
    
    /// Compute a VDF proof with progress callback
    #[wasm_bindgen]
    pub fn compute_proof(
        &self,
        input: &str,
        iterations: u64,  // wasm-bindgen handles BigInt -> u64 conversion
        on_progress: Option<Function>,  
    ) -> Result<VDFProof, JsValue> {
        self.compute_proof_internal(input, iterations, on_progress)
            .map_err(|e| JsValue::from_str(&e))
    }
    
    /// Verify a VDF proof
    #[wasm_bindgen]
    pub fn verify_proof(&self, input: &str, proof: &VDFProof) -> Result<bool, JsValue> {
        self.verify_proof_internal(input, proof)
            .map_err(|e| JsValue::from_str(&e))
    }
    
    /// Estimate iterations needed for a given time in seconds
    #[wasm_bindgen]
    pub fn estimate_iterations_for_seconds(&self, seconds: f64) -> u64 {
        // Benchmark-based estimation (should be calibrated per device)
        // Modern CPU: ~5-20M iterations/second depending on implementation
        let base_rate = 10_000_000.0;
        let iterations = (seconds * base_rate) as u64;
        iterations.clamp(MIN_ITERATIONS, MAX_ITERATIONS)
    }
    
    /// Internal proof generation with full error handling
    fn compute_proof_internal(
        &self,
        input: &str,
        iterations: u64,
        on_progress: Option<Function>,
    ) -> Result<VDFProof, String> {
        // Validate parameters
        if iterations < MIN_ITERATIONS || iterations > MAX_ITERATIONS {
            return Err(format!(
                "Iterations must be between {} and {}",
                MIN_ITERATIONS, MAX_ITERATIONS
            ));
        }
        
        if input.is_empty() {
            return Err("Input cannot be empty".to_string());
        }
        
        debug_log!("Starting VDF computation with {} iterations", iterations);
        
        // Hash input to get starting value x
        let x = self.hash_to_group(input)?;
        
        // Compute y = x^(2^t) mod N using repeated squaring
        let start_time = js_sys::Date::now();
        let y = self.compute_vdf_output(&x, iterations, &on_progress)?;
        let compute_time = js_sys::Date::now() - start_time;
        
        debug_log!("VDF computation completed in {}ms", compute_time);
        
        // Generate challenge prime l using Fiat-Shamir
        let l = self.generate_fiat_shamir_prime(&x, &y, iterations)?;
        
        // Compute remainder r = 2^t mod l
        let r = self.compute_remainder(iterations, &l)?;
        
        // Compute proof œÄ using Wesolowski's algorithm
        let pi = self.compute_wesolowski_proof(&x, iterations, &l)?;
        
            // ADD THE DEBUGGING CODE HERE!
        debug_log!("=== VDF Proof Generation Debug ===");
        debug_log!("iterations: {}", iterations);
        debug_log!("x (first 32 chars): {}...", x.to_str_radix(16).chars().take(32).collect::<String>());
        debug_log!("y (first 32 chars): {}...", y.to_str_radix(16).chars().take(32).collect::<String>());
        debug_log!("l: {}", l);
        debug_log!("r: {}", r);
        debug_log!("pi (first 32 chars): {}...", pi.to_str_radix(16).chars().take(32).collect::<String>());
        // Verify the equation holds before encoding
        let pi_l = pi.modpow(&l, &self.modulus);
        let x_r = x.modpow(&r, &self.modulus);
        let check = (pi_l * x_r) % &self.modulus;
        debug_log!("Self-check: y == pi^l * x^r? {}", y == check);
        
        
        // Encode all values to base64
        let proof = VDFProof {
            y: general_purpose::STANDARD.encode(y.to_bytes_be()),
            pi: general_purpose::STANDARD.encode(pi.to_bytes_be()),
            l: general_purpose::STANDARD.encode(l.to_bytes_be()),
            r: general_purpose::STANDARD.encode(r.to_bytes_be()),
            iterations,
            timestamp: js_sys::Date::now() as u64,
        };
        
        // Self-verify as sanity check
        if !self.verify_proof_internal(input, &proof)? {
            return Err("Self-verification failed".to_string());
        }
        
        Ok(proof)
    }
    
    /// Hash input to a group element
    fn hash_to_group(&self, input: &str) -> Result<BigUint, String> {
        let mut hasher = Sha256::new();
        hasher.update(b"VDF_HASH_TO_GROUP_v1");
        hasher.update(input.as_bytes());
        hasher.update(&self.modulus.to_bytes_be());
        
        let mut counter = 0u32;
        loop {
            let mut h = hasher.clone();
            h.update(&counter.to_be_bytes());
            let hash = h.finalize();
            let candidate = BigUint::from_bytes_be(&hash);
            
            // Ensure we get a valid element in Z*_N
            if candidate < self.modulus && candidate > BigUint::zero() {
                // Check gcd(candidate, N) = 1 (simplified - assumes N is product of two primes)
                if candidate.gcd(&self.modulus).is_one() {
                    return Ok(candidate);
                }
            }
            
            counter += 1;
            if counter > 1000 {
                return Err("Failed to hash to group".to_string());
            }
        }
    }
    
    /// Compute VDF output y = x^(2^t) mod N
    fn compute_vdf_output(
        &self,
        x: &BigUint,
        iterations: u64,
        on_progress: &Option<Function>,
    ) -> Result<BigUint, String> {
        let mut y = x.clone();
        let mut last_progress = 0u64;
        
        for i in 0..iterations {
            // Optimized squaring: y = y^2 mod N
            y = self.mod_square(&y);
            
            // Progress reporting
            if let Some(callback) = on_progress {
                if i % PROGRESS_INTERVAL == 0 || i == iterations - 1 {
                    let progress = ((i + 1) * 100) / iterations;
                    if progress != last_progress {
                        last_progress = progress;
                        let this = JsValue::null();
                        let progress_val = JsValue::from_f64(progress as f64);
                        if let Err(e) = callback.call1(&this, &progress_val) {
                            warn(&format!("Progress callback error: {:?}", e));
                        }
                    }
                }
            }
        }
        
        Ok(y)
    }
    
    /// Optimized modular squaring
    fn mod_square(&self, x: &BigUint) -> BigUint {
        // For production, implement Montgomery multiplication
        (x * x) % &self.modulus
    }
    
    /// Generate deterministic challenge prime using Fiat-Shamir
    fn generate_fiat_shamir_prime(
        &self,
        x: &BigUint,
        y: &BigUint,
        iterations: u64,
    ) -> Result<BigUint, String> {
        let mut hasher = Sha256::new();
        hasher.update(b"VDF_FIAT_SHAMIR_v1");
        hasher.update(&x.to_bytes_be());
        hasher.update(&y.to_bytes_be());
        hasher.update(&iterations.to_be_bytes());
        hasher.update(&self.modulus.to_bytes_be());
        
       
        // Use the hash directly for deterministic generation
        for attempt in 0..1000 {
            let mut h = hasher.clone();  // Clone the original hasher
            h.update(&(attempt as u32).to_be_bytes());
            // Don't finalize h here either - we need it for the inner loop
            
            // Build a SECURITY_BITS sized number from repeated hashing
            let mut bytes = Vec::new();
            let mut counter = 0u32;
            while bytes.len() * 8 < SECURITY_BITS {
                let mut h2 = h.clone();  // Clone h each time
                h2.update(&counter.to_be_bytes());
                bytes.extend_from_slice(&h2.finalize());  // Only finalize h2
                counter += 1;
            }
            
            // Truncate to exact bit length
            let bytes_needed = (SECURITY_BITS + 7) / 8;
            bytes.truncate(bytes_needed);
            
            let mut candidate = BigUint::from_bytes_be(&bytes);
            
            // Ensure exactly SECURITY_BITS
            if SECURITY_BITS % 8 != 0 {
                candidate >>= 8 - (SECURITY_BITS % 8);
            }
            
            candidate |= BigUint::one(); // Make odd
            candidate |= BigUint::one() << (SECURITY_BITS - 1); // Set high bit
            
            if self.is_probable_prime(&candidate, 40) {
                debug_log!("Generated challenge prime in {} attempts", attempt + 1);
                return Ok(candidate);
            }
        }
        
        Err("Failed to generate challenge prime".to_string())
    }
    
    /// Compute r = 2^t mod l efficiently
    fn compute_remainder(&self, iterations: u64, l: &BigUint) -> Result<BigUint, String> {
        // Use binary exponentiation
        let base = BigUint::from(2u32);
        Ok(base.modpow(&BigUint::from(iterations), l))
    }
    
/// Compute Wesolowski proof using a correct long division algorithm
fn compute_wesolowski_proof(
    &self,
    x: &BigUint,
    iterations: u64,
    l: &BigUint,
) -> Result<BigUint, String> {
    // We compute pi = x^q, where q is the quotient of 2^t / l.
    // The bits of q are determined by a long division process.
    
    let mut pi = BigUint::one();
    let mut remainder = BigUint::zero();
    
    // We need to process t+1 bits for the number 2^t (a 1 followed by t zeros).
    // We iterate from the most significant bit downwards.
    for i in (0..=iterations).rev() { // CORRECT: from t down to 0
        // Every step in the long division corresponds to a squaring in the exponentiation.
        // This is the "square" part of the square-and-multiply algorithm.
        pi = self.mod_square(&pi);
        
        // Bring down the next bit of the dividend (2^t).
        remainder <<= 1;
        
        // The most significant bit (at position t) is 1; all others are 0.
        if i == iterations {
            remainder |= BigUint::one();
        }
        
        // Check if the divisor 'l' goes into the current remainder.
        if remainder >= *l {
            remainder -= l;
            // If it does, the quotient bit is 1. This corresponds to the "multiply"
            // part of the square-and-multiply algorithm.
            pi = (pi * x) % &self.modulus;
        }
    }
    
    Ok(pi)
}
    
    
    /// Verify a VDF proof
fn verify_proof_internal(&self, input: &str, proof: &VDFProof) -> Result<bool, String> {
    // Validate parameters
    if proof.iterations < MIN_ITERATIONS || proof.iterations > MAX_ITERATIONS {
        return Ok(false);
    }
    
    // Decode base64 values
    let y = base64_to_biguint(&proof.y)?;
    let pi = base64_to_biguint(&proof.pi)?;
    let l = base64_to_biguint(&proof.l)?;
    let r = base64_to_biguint(&proof.r)?;
    
    // Verify l is a valid prime
    if l.bits() < (SECURITY_BITS as u64 - 8) || !self.is_probable_prime(&l, 20) {
        debug_log!("Invalid challenge prime");
        return Ok(false);
    }
    
    // Hash input to get x
    let x = self.hash_to_group(input)?;
    
    // Recompute challenge to verify Fiat-Shamir
    let expected_l = self.generate_fiat_shamir_prime(&x, &y, proof.iterations)?;
    if l != expected_l {
        debug_log!("Challenge prime mismatch");
        return Ok(false);
    }
    
    // Add debugging here
    debug_log!("=== VDF Verification Debug ===");
    debug_log!("iterations: {}", proof.iterations);
    debug_log!("x (first 32 chars): {}...", x.to_str_radix(16).chars().take(32).collect::<String>());
    debug_log!("y (first 32 chars): {}...", y.to_str_radix(16).chars().take(32).collect::<String>());
    debug_log!("l: {}", l);
    debug_log!("r: {}", r);
    debug_log!("pi (first 32 chars): {}...", pi.to_str_radix(16).chars().take(32).collect::<String>());
    
    // Verify: y ‚â° œÄ^l * x^r (mod N)
    let pi_l = pi.modpow(&l, &self.modulus);
    let x_r = x.modpow(&r, &self.modulus);
    let right_side = (pi_l.clone() * x_r.clone()) % &self.modulus;
    
    debug_log!("pi^l mod N (first 32 chars): {}...", pi_l.to_str_radix(16).chars().take(32).collect::<String>());
    debug_log!("x^r mod N (first 32 chars): {}...", x_r.to_str_radix(16).chars().take(32).collect::<String>());
    debug_log!("right_side (first 32 chars): {}...", right_side.to_str_radix(16).chars().take(32).collect::<String>());
    debug_log!("y == right_side? {}", y == right_side);
    
    // Let's also verify the remainder calculation
    let two = BigUint::from(2u32);
    let computed_r = two.modpow(&BigUint::from(proof.iterations), &l);
    debug_log!("Recomputed r: {}", computed_r);
    debug_log!("r matches? {}", r == computed_r);
    
    Ok(y == right_side)
}
    
    /// Miller-Rabin primality test
     fn is_probable_prime(&self, n: &BigUint, k: usize) -> bool {
        if n <= &BigUint::one() {
            return false;
        }
        
        if n == &BigUint::from(2u32) || n == &BigUint::from(3u32) {
            return true;
        }
        
        if n.is_even() {
            return false;
        }
        
        // Write n-1 as 2^r * d
        let one = BigUint::one();
        let two = BigUint::from(2u32);
        let n_minus_1 = n - &one;
        
        let mut r = 0;
        let mut d = n_minus_1.clone();
        
        while d.is_even() {
            d >>= 1;
            r += 1;
        }
        
        // Witness loop with deterministic witnesses for small n
        let witnesses: Vec<BigUint> = if n < &BigUint::from(3317044064679887385961981u128) {
            vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]
                .into_iter()
                .map(|w| BigUint::from(w as u32))
                .collect()
        } else {
            // Random witnesses for large n
            let mut rng = thread_rng();
            (0..k)
                .map(|_| rng.gen_biguint_range(&two, &(n - &two)))
                .collect()
        };
        
        'witness: for a in witnesses {
            if a >= *n {
                continue;
            }
            
            let mut x = a.modpow(&d, n);  // n is already &BigUint
            
            if x == one || x == n_minus_1 {
                continue 'witness;
            }
            
            for _ in 0..r - 1 {
                x = x.modpow(&two, n);
                if x == n_minus_1 {
                    continue 'witness;
                }
            }
            
            return false;
        }
        
        true
    }
}

/// Helper function to decode base64 to BigUint
fn base64_to_biguint(b64: &str) -> Result<BigUint, String> {
    let bytes = general_purpose::STANDARD
        .decode(b64)
        .map_err(|e| format!("Base64 decode error: {}", e))?;
    
    if bytes.is_empty() {
        return Err("Empty bytes".to_string());
    }
    
    Ok(BigUint::from_bytes_be(&bytes))
}

/// Benchmark function to calibrate iterations per second
#[wasm_bindgen]
pub fn benchmark_vdf(duration_ms: u32) -> Result<f64, JsValue> {
    let computer = VDFComputer::new();
    let test_input = "benchmark_test";
    
    let start = js_sys::Date::now();
    let mut iterations = 0u64;
    
    while js_sys::Date::now() - start < duration_ms as f64 {
        iterations += 1000;
        let _ = computer.compute_proof(test_input, iterations, None)?;
        
        if iterations > 1_000_000 {
            break;
        }
    }
    
    let elapsed_seconds = (js_sys::Date::now() - start) / 1000.0;
    Ok(iterations as f64 / elapsed_seconds)
}

/// Export version information
#[wasm_bindgen]
pub fn get_version() -> String {
    env!("CARGO_PKG_VERSION").to_string()
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_vdf_correctness() {
        let computer = VDFComputer::new().unwrap();
        let input = "test_input";
        let iterations = 10000;
        
        let proof = computer.compute_proof(input, iterations, None).unwrap();
        assert!(computer.verify_proof(input, &proof).unwrap());
        
        // Test invalid proof
        let mut invalid_proof = proof.clone();
        invalid_proof.iterations = 9999;
        assert!(!computer.verify_proof(input, &invalid_proof).unwrap());
    }
    
    #[test]
    fn test_deterministic_proofs() {
        let computer = VDFComputer::new().unwrap();
        let input = "deterministic_test";
        let iterations = 5000;
        
        let proof1 = computer.compute_proof(input, iterations, None).unwrap();
        let proof2 = computer.compute_proof(input, iterations, None).unwrap();
        
        assert_eq!(proof1.y(), proof2.y());
        assert_eq!(proof1.l(), proof2.l());
    }
}


