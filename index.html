<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>üî•Ember - The Ephemeral Social Network ‚Äì Where Posts Live and Die</title>

  <script type="module">
    import WebTorrent from "https://cdn.jsdelivr.net/npm/webtorrent@2.6.8/dist/webtorrent.min.js";
    window.WebTorrent = WebTorrent;
  </script>
<script src="https://cdn.jsdelivr.net/npm/tweetnacl@1.0.3/nacl.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.11.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/toxicity@1.2.2/dist/toxicity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/nsfwjs@4.2.1/dist/browser/nsfwjs.min.js"></script>
<script
  src="https://cdn.jsdelivr.net/npm/dompurify@3.2.6/dist/purify.min.js"
  integrity="sha384-JEyTNhjM6R1ElGoJns4U2Ln4ofPcqzSsynQkmEc/KGy6336qAZl70tDLufbkla+3"
  crossorigin="anonymous"></script>

        
  <link rel="stylesheet" href="style.css">

</head>
<body>
    
  <div id="identity-creation-overlay" class="loading-overlay" style="display: none;">
    <div id="identity-modal-content">
    <h2>Securing Your Identity</h2>
    <p>To protect the network, we need to perform a quick, one-time setup.</p>
    
    <div id="identity-step-0-disclaimer">
        <div class="risk-disclaimer">
            <h3>Welcome to a Public P2P Network</h3>
            <p><strong>This is not a private messenger.</strong> Please acknowledge the following to continue:</p>
            <ul>
                <li>Your IP address may be visible to other users.</li>
                <li>Messages are not end-to-end encrypted and can be read by peers who relay your posts.</li>
                <li>Your activity is traceable.</li>
            </ul>
        </div>
        <button id="acknowledge-button" class="primary-button">I Understand, Continue</button>
    </div>
    
    <div id="identity-step-1-calibrate" style="display: none;">
        <div class="spinner"></div>
        <div id="identity-status-text"><strong>Step 1/2:</strong> Calibrating network difficulty...</div>
    </div>

    <div id="identity-step-2-pow" style="display: none;">
        </div>
    <div id="identity-step-3-prompt" style="display: none;">
        </div>
</div>
  </div>
  <div id="loading" class="loading-overlay">
    <div class="loading-content">
      <div class="spinner"></div>
      <div>üî• Igniting the Ember Network...</div>
      <div style="font-size:12px;margin-top:10px;color:#ff8c42">No servers, just flames</div>
    </div>
  </div>

  <div id="app-container">

    <div class="app-column" id="column-controls">
     
        <h1>üî• Ember</h1>
        <p class="tagline">Fan the flames or watch them die</p>
              <div id="controls-footer">
        <button id="theme-toggle-button" class="secondary-button">‚òÄÔ∏è Light Mode</button>
      </div>
      
              <div id="compose">
          <textarea id="post-input" placeholder="Write something ephemeral‚Ä¶" maxlength="500"></textarea>
          <div class="image-preview" id="image-preview" style="display:none;">
            <img id="preview-img" />
            <button onclick="removeImage()">‚úï</button>
          </div>
          <div class="compose-footer">
            <input type="file" id="image-input" accept="image/*" style="display:none;" onchange="handleImageSelect(this)" />
            <button onclick="document.getElementById('image-input').click()" class="image-button">üì∑</button>
            <span class="char-count"><span id="char-current">0</span>/500</span>
            <button id="send-button" class="primary-button" onclick="createPostWithTopics()">üî• Light it up</button>
          </div>
        </div>
      <div id="status">
        <span><span class="status-indicator" id="status-dot"></span>Connected to <span id="peer-count">0</span> peers</span>
        <span><span id="post-count">0</span> posts alive</span>
      </div>
      <div class="network-info" id="network-info" style="display:none">
        <strong>Your Network ID:</strong> <code id="network-id"></code><br />
        <small>Share this with friends to connect directly</small>
      </div>

        <button id="clear-data-button" class="secondary-button" onclick="clearLocalData()">
  üóëÔ∏è Clear Local Data
</button>

        
        <footer>
    <p class="network-notice">
        ‚ö†Ô∏è Public Network: Do not share sensitive information.
    </p>
</footer>
        
    </div>

    <div class="app-column" id="column-feed">
      <div class="column-header">
        <h2>The Void</h2>
      </div>
      <div class="topics-section">
  <h3>üì° Topics</h3>
  <div class="subscribed-topics" id="subscribed-topics">
    <div class="topic-tag active" data-topic="#general">#general</div>
    <div class="topic-tag active" data-topic="#ember">#ember</div>
  </div>
  <div class="topic-input-wrapper">
    <input type="text" id="topic-input" placeholder="Subscribe to #topic" />
    <button onclick="subscribeToTopic()" class="subscribe-button">+</button>
  </div>
  <div class="topic-stats" id="topic-stats"></div>
</div>

<div class="feed-controls">
  <div class="topic-filter">
    <label>Filter by topic:</label>
    <select id="topic-filter" onchange="filterByTopic()">
      <option value="">All Topics</option>
      <option value="#general">#general</option>
      <option value="#ember">#ember</option>
    </select>
  </div>
  <div class="feed-mode">
    <button class="mode-button active" onclick="setFeedMode('all')">All Posts</button>
    <button class="mode-button" onclick="setFeedMode('topics')">My Topics</button>
  </div>
</div>
      
      
      <div id="posts">
        </div>
    </div>

    <div class="app-column" id="column-bonfire">
      <div class="column-header">
        <h2>The Bonfire</h2>
      </div>
      <div id="bonfire-content">
        </div>
    </div>

  </div>

  <script>
      // Add memory monitoring
class MemoryManager {
  constructor() {
    this.checkInterval = 30000;
    this.targetMemoryUsage = 0.7;
    this.criticalMemoryUsage = 0.85;
    this.postScores = new Map();
    this.startMonitoring();
  }
  
  calculatePostPriority(post) {
    const now = Date.now();
    const age = (now - post.timestamp) / (1000 * 60 * 60); // hours
    const isExplicitlyCarried = state.explicitlyCarrying.has(post.id);
    const carrierCount = post.carriers.size;
    const replyCount = post.replies.size;
    
    // Calculate heat score
    const heat = carrierCount + (replyCount * 2);
    
    // Priority formula
    let priority = heat / Math.pow(age + 1, 1.5); // Decay over time
    
    // Boost for explicit carries
    if (isExplicitlyCarried) priority *= 100;
    
    // Boost for posts we authored
    if (post.author === state.myIdentity.handle) priority *= 10;
    

    
    return priority;
  }
  
  async getMemoryUsage() {
    if (performance.memory) {
      return {
        used: performance.memory.usedJSHeapSize,
        total: performance.memory.jsHeapSizeLimit,
        ratio: performance.memory.usedJSHeapSize / performance.memory.jsHeapSizeLimit
      };
    }
    
    // Fallback: estimate based on post count
    const avgPostSize = 2048; // 2KB average
    const estimatedUsage = state.posts.size * avgPostSize;
    return {
      used: estimatedUsage,
      total: 100 * 1024 * 1024, // 100MB assumed limit
      ratio: estimatedUsage / (100 * 1024 * 1024)
    };
  }
  
  async checkMemory() {
    const memory = await this.getMemoryUsage();
    
    // Update post scores periodically
    if (Math.random() < 0.1 || memory.ratio > this.targetMemoryUsage) {
      this.updatePostScores();
    }
    
    if (memory.ratio > this.criticalMemoryUsage) {
      console.warn(`Critical memory usage: ${Math.round(memory.ratio * 100)}%`);
      await this.emergencyCleanup();
    } else if (memory.ratio > this.targetMemoryUsage) {
      console.log(`High memory usage: ${Math.round(memory.ratio * 100)}%`);
      await this.adaptiveCleanup(memory.ratio);
    }
  }
  
  updatePostScores() {
    this.postScores.clear();
    for (const [id, post] of state.posts) {
      this.postScores.set(id, this.calculatePostPriority(post));
    }
  }
  
  async adaptiveCleanup(memoryRatio) {
    const targetRatio = 0.5;
    const reductionFactor = targetRatio / memoryRatio;
    const targetPostCount = Math.floor(state.posts.size * reductionFactor);
    
    // Sort posts by priority
    const sortedPosts = Array.from(state.posts.entries())
      .map(([id, post]) => ({
        id,
        post,
        priority: this.postScores.get(id) || this.calculatePostPriority(post)
      }))
      .sort((a, b) => b.priority - a.priority);
    
    // Keep only the highest priority posts
    const toKeep = new Set(sortedPosts.slice(0, targetPostCount).map(p => p.id));
    
    // Remove low priority posts
    for (const [id, post] of state.posts) {
      if (!toKeep.has(id) && !state.explicitlyCarrying.has(id)) {
        state.posts.delete(id);
        dropPost(id);
      }
    }
    
    // Clean up bloom filters if they're too large
    if (state.seenMessages.bits.length > 50000) {
      state.seenMessages = new BloomFilter(100000, 4);
      console.log("Reset message bloom filter");
    }
    
    if (state.seenPosts.bits.length > 50000) {
      state.seenPosts = new BloomFilter(100000, 4);
      console.log("Reset post bloom filter");
    }
  }
  
  async emergencyCleanup() {
    // Keep only explicitly carried posts and very recent posts
    const oneHourAgo = Date.now() - (60 * 60 * 1000);
    const toKeep = new Set();
    
    for (const [id, post] of state.posts) {
      if (state.explicitlyCarrying.has(id) || 
          post.timestamp > oneHourAgo ||
          post.author === state.myIdentity.handle) {
        toKeep.add(id);
      }
    }
    
    // Remove everything else
    for (const id of state.posts.keys()) {
      if (!toKeep.has(id)) {
        state.posts.delete(id);
        dropPost(id);
      }
    }
    
    // Force garbage collection if available
    if (window.gc) {
      window.gc();
    }
    
    console.log(`Emergency cleanup: kept ${toKeep.size} posts`);
  }
  
  startMonitoring() {
    
    // More frequent checks during high activity
    document.addEventListener('visibilitychange', () => {
      if (!document.hidden) {
        this.checkMemory();
      }
    });
  }
}

class ContentAddressedImageStore {
    constructor() {
        this.chunks = new Map();
        this.images = new Map();
        this.maxChunkSize = 16 * 1024; // 16KB chunks
        this.maxTotalSize = 10 * 1024 * 1024; // 10MB total
    }

    async sha256(data) {
        const encoder = new TextEncoder();
        const dataBuffer = encoder.encode(data);
        const hashBuffer = await crypto.subtle.digest('SHA-256', dataBuffer);
        const hashArray = Array.from(new Uint8Array(hashBuffer));
        return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    }

    async storeImage(base64Data) {
        // Remove data URL prefix if present
        const imageData = base64Data.replace(/^data:image\/\w+;base64,/, '');

        // Check if we already have this image
        const imageHash = await this.sha256(imageData);
        if (this.images.has(imageHash)) {
            console.log(`[ImageStore] Image ${imageHash.substring(0, 8)}... already in store (cached).`);
            return { hash: imageHash, type: 'cached' };
        }

        // Chunk the image
        const chunks = [];
        const chunkHashes = []; // To build Merkle tree
        for (let i = 0; i < imageData.length; i += this.maxChunkSize) {
            const chunk = imageData.slice(i, i + this.maxChunkSize);
            const chunkHash = await this.sha256(chunk);
            chunks.push({ hash: chunkHash, data: chunk, index: i / this.maxChunkSize });
            chunkHashes.push(chunkHash); // Add hash to list for Merkle tree

            // Store chunk if we don't have it
            if (!this.chunks.has(chunkHash)) {
                this.chunks.set(chunkHash, chunk);
                console.log(`[ImageStore] Stored new chunk ${chunkHash.substring(0, 8)}...`);
            } else {
                console.log(`[ImageStore] Chunk ${chunkHash.substring(0, 8)}... already exists.`);
            }
        }

        // Build merkle tree
        const merkleRoot = await this.buildMerkleTree(chunkHashes);
        console.log(`[ImageStore] Built Merkle Root for image ${imageHash.substring(0, 8)}...: ${merkleRoot?.substring(0, 8)}...`);

        // Store image metadata
        this.images.set(imageHash, {
            merkleRoot,
            chunks: chunks.map(c => ({ hash: c.hash, index: c.index })),
            size: imageData.length,
            created: Date.now()
        });
        console.log(`[ImageStore] Stored image metadata for ${imageHash.substring(0, 8)}... (chunks: ${chunks.length}, Merkle Root: ${merkleRoot?.substring(0, 8)}...)`);

        // Clean up old data if needed
        this.cleanup();

        return {
            hash: imageHash,
            merkleRoot,
            chunkCount: chunks.length,
            type: 'stored'
        };
    }

    async buildMerkleTree(hashes) {
        if (hashes.length === 0) return null;
        if (hashes.length === 1) return hashes[0];

        const pairs = [];
        for (let i = 0; i < hashes.length; i += 2) {
            const left = hashes[i];
            const right = hashes[i + 1] || hashes[i]; // Handle odd number of hashes by duplicating last one
            const combined = await this.sha256(left + right);
            pairs.push(combined);
        }
        return this.buildMerkleTree(pairs);
    }

    async retrieveImage(imageHash) {
        const metadata = this.images.get(imageHash);
        if (!metadata) {
            console.warn(`[ImageStore] Cannot retrieve image ${imageHash.substring(0, 8)}...: Metadata not found.`);
            return null;
        }

        const assembledChunks = new Array(metadata.chunks.length);
        const receivedChunkHashes = []; // To reconstruct Merkle tree for verification

        for (const chunkMeta of metadata.chunks) {
            const chunkData = this.chunks.get(chunkMeta.hash);
            if (!chunkData) {
                console.warn(`[ImageStore] Missing chunk ${chunkMeta.hash.substring(0, 8)}... for image ${imageHash.substring(0, 8)}...`);
                // If any chunk is missing, we cannot reconstruct the image
                return null;
            }
            assembledChunks[chunkMeta.index] = chunkData;
            receivedChunkHashes[chunkMeta.index] = chunkMeta.hash; // Store original chunk hash for tree rebuild
        }

        // Verify Merkle Root
        const reconstructedMerkleRoot = await this.buildMerkleTree(receivedChunkHashes);
        if (reconstructedMerkleRoot !== metadata.merkleRoot) {
            console.error(`[ImageStore] Merkle Root mismatch for image ${imageHash.substring(0, 8)}...! Expected ${metadata.merkleRoot?.substring(0, 8)}..., got ${reconstructedMerkleRoot?.substring(0, 8)}...`);
            // This indicates data corruption or tampering
            return null;
        }
        console.log(`[ImageStore] Merkle Root verified for image ${imageHash.substring(0, 8)}...: ${reconstructedMerkleRoot?.substring(0, 8)}...`);

        // Reassemble chunks
        const fullImageData = assembledChunks.join('');
        console.log(`[ImageStore] Successfully retrieved and verified image ${imageHash.substring(0, 8)}...`);
        return 'data:image/jpeg;base64,' + fullImageData;
    }

    cleanup() {
        let totalSize = 0;
        for (const chunk of this.chunks.values()) {
            totalSize += chunk.length;
        }

        console.log(`[ImageStore] Current total storage usage: ${(totalSize / 1024).toFixed(2)} KB (Max: ${(this.maxTotalSize / 1024 / 1024).toFixed(2)} MB)`);

        if (totalSize > this.maxTotalSize) {
            console.log(`[ImageStore] Initiating cleanup due to high memory usage.`);
            const sortedImages = Array.from(this.images.entries())
                .sort((a, b) => a[1].created - b[1].created);

            let cleanedUpSize = 0;
            while (totalSize > this.maxTotalSize * 0.7 && sortedImages.length > 0) {
                const [hash, metadata] = sortedImages.shift();
                console.log(`[ImageStore] Cleaning up image ${hash.substring(0, 8)}... (oldest)`);

                this.images.delete(hash);

                const chunksToDelete = new Set(metadata.chunks.map(c => c.hash));

                for (const [otherHash, otherMeta] of this.images) {
                    otherMeta.chunks.forEach(c => chunksToDelete.delete(c.hash));
                }

                for (const chunkHash of chunksToDelete) {
                    const chunkData = this.chunks.get(chunkHash);
                    if (chunkData) {
                        totalSize -= chunkData.length;
                        cleanedUpSize += chunkData.length;
                        this.chunks.delete(chunkHash);
                        console.log(`[ImageStore] Deleted unreferenced chunk ${chunkHash.substring(0, 8)}...`);
                    }
                }
            }
            console.log(`[ImageStore] Cleanup complete. Removed ${(cleanedUpSize / 1024).toFixed(2)} KB.`);
        }
    }
}


    /*************************************/
/****VDF******************************/
/*************************************/
 class BitQuillVDF {
          constructor() {
            // Standard RSA-2048 modulus (same as in the Rust code)
            this.modulus = this.hexToBigInt("C7970CEEDCC3B0754490201A7AA613CD73911081C790F5F1A8726F463550BB5B7FF0DB8E1EA1189EC72F93D1650011BD721AEEACC2ACDE32A04107F0648C2813A31F5B0B7765FF8B44B4B6FFC93384B646EB09C7CF5E8592D40EA33C80039F35B4F14A04B51F7BFD781BE4D1673164BA8EB991C2C4D730BBBE35F592BDEF524AF7E8DAEFD26C66FC02C479AF89D64D373F442709439DE66CEB955F3EA37D5159F6135809F85334B5CB1813ADDC80CD05609F10AC6A95AD65872C909525BDAD32BC729592642920F24C61DC5B3C3B7923E56B16A4D9D373D8721F24A3FC0F1B3131F55615172866BCCC30F95054C824E733A5EB6817F7BC16399D48C6361CC7E5");
            
            // Constants
            this.MIN_ITERATIONS = 1000;   // Minimum VDF iterations
            this.MAX_ITERATIONS = 100000; // Maximum VDF iterations for browser
            this.INITIAL_ITERATIONS = 2000; // Default iterations
            
            // Use the primes you generated
            this.predefinedPrimes = [
              "FC966D631E31FC8444EA1269FF2E5343",
              "E39428325AE41A5BA418BD0DD14B8C85",
              "BFC70C36037B3E6848765C5C366334CF",
              "B1E0A97790B08A73BAD75AAEB069DE4F",
              "93D20B1CDC12D49F400B9F786DEF907D",
              "FCC36BD354131F50F5E98287F0B19571",
              "F68E4B6B2375FE123838AAC57F2AACFF",
              "B2280F8B5E86A84C904D79B0CB0CB195",
              "C08933E9B9961FAD599144A945EFB8CB",
              "BFD96D59FFB6274B546C2C0050951C2F"
            ];
          }

        calculateReputationScore(upvotes, downvotes) {
          if (upvotes + downvotes === 0) return 0.5;
          return upvotes / (upvotes + downvotes);
        }


          // Convert hex string to BigInt
          hexToBigInt(hex) {
            return BigInt("0x" + hex);
          }

          // Convert string to bytes array
          stringToBytes(str) {
            return new TextEncoder().encode(str);
          }

          // Hash input using SHA-256
          async hashInput(input) {
            const encoder = new TextEncoder();
            const data = encoder.encode(input);
            const hashBuffer = await crypto.subtle.digest('SHA-256', data);
            return new Uint8Array(hashBuffer);
          }

            // Convert bytes to BigInt
         bytesToBigInt(bytes) {
            // Check for empty or null bytes array
            if (!bytes || bytes.length === 0) {
                console.warn("bytesToBigInt: Empty bytes array, returning 0");
                return BigInt(0);
            }
            
            // Convert Uint8Array to hex string
            let hex = '';
            for (let i = 0; i < bytes.length; i++) {
                hex += bytes[i].toString(16).padStart(2, '0');
            }
            
            // Additional check for empty hex string
            if (hex === '') {
                console.warn("bytesToBigInt: Empty hex string, returning 0");
                return BigInt(0);
            }
            
            try {
                return BigInt("0x" + hex);
            } catch (error) {
                console.error("bytesToBigInt: Error converting hex to BigInt:", error);
                return BigInt(0);
            }
        }

          // Convert BigInt to bytes
          bigIntToBytes(bigint) {
            let hex = bigint.toString(16);
            // Ensure even length
            if (hex.length % 2) hex = "0" + hex;
            
            let bytes = new Uint8Array(hex.length / 2);
            for (let i = 0; i < hex.length; i += 2) {
              bytes[i/2] = parseInt(hex.substr(i, 2), 16);
            }
            return bytes;
          }


        // **New Helper Method: Convert Uint8Array to base64 string**
          arrayBufferToBase64(buffer) {
            const binary = String.fromCharCode(...buffer);
            return btoa(binary);
          }

          // **New Helper Method: Convert base64 string to Uint8Array**
          base64ToArrayBuffer(base64) {
            const binary = atob(base64);
            const bytes = new Uint8Array(binary.length);
            for (let i = 0; i < binary.length; i++) {
              bytes[i] = binary.charCodeAt(i);
            }
            return bytes;
          }

          // Get a random prime from our predefined list
          getRandomPrime() {
            const index = Math.floor(Math.random() * this.predefinedPrimes.length);
            return this.hexToBigInt(this.predefinedPrimes[index]);
          }

        modInverse(a, m) {
          // Implementation of extended Euclidean algorithm for modular inverse
          let [old_r, r] = [BigInt(a), BigInt(m)];
          let [old_s, s] = [BigInt(1), BigInt(0)];
          
          while (r !== BigInt(0)) {
            const quotient = old_r / r;
            [old_r, r] = [r, old_r - quotient * r];
            [old_s, s] = [s, old_s - quotient * s];
          }
          
          if (old_r > BigInt(1)) return null; // Not invertible
          return (old_s % m + m) % m; // Ensure positive result
        }
        
          // Compute VDF proof (browser-friendly Wesolowski)
            async computeVDFProof(input, iterations) {
              // Clamp iteration count to safe bounds
              iterations = Math.min(
                Math.max(iterations, this.MIN_ITERATIONS),
                this.MAX_ITERATIONS
              );

              /* ---------- 1. Derive x from the input ---------- */
              const hashBytes = await this.hashInput(input);
              let x = this.bytesToBigInt(hashBytes);

              console.log(
                "Computing VDF proof, hashed x:",
                x.toString(16).substring(0, 20) + "‚Ä¶"
              );

              /* ---------- 2. Pick random prime ‚Ñì and compute r ---------- */
              const l = this.getRandomPrime();                          // random 128-bit prime
              const r = this.modPow(2n, BigInt(iterations), l);         // r = 2·µó mod ‚Ñì

              /* ---------- 3. Sequentially square to get y = x^(2·µó) mod N ---------- */
              let y = x;
              const update = this.onProgressUpdate;
              const chunk  = 100;                                       // UI-smooth chunk size

              for (let i = 0; i < iterations; i++) {
                y = (y * y) % this.modulus;                             // single squaring
                if (update && i % chunk === 0) {                        // send progress to UI
                  const pct = (i / iterations) * 100;
                  await new Promise(res => {
                    update(pct);
                    setTimeout(res, 0);                                 // yield to render thread
                  });
                }
              }

              /* ---------- 4. Compute q = (2·µó ‚àí r) / ‚Ñì  (exact integer division) ---------- */
              const twoToT = 1n << BigInt(iterations);                  // 2·µó  without mod N

              // Ensure (2·µó ‚àí r) is divisible by ‚Ñì; if not, retry with a new ‚Ñì
              if ((twoToT - r) % l !== 0n) {
                return this.computeVDFProof(input, iterations);         // extremely unlikely
              }
              const q = (twoToT - r) / l;

              /* ---------- 5. œÄ = x^q mod N  ---------- */
              const pi = this.modPow(x, q, this.modulus);

              /* ---------- 6. Pack proof components ---------- */
              const proof = {
                y : this.arrayBufferToBase64(this.bigIntToBytes(y)),
                pi: this.arrayBufferToBase64(this.bigIntToBytes(pi)),
                l : this.arrayBufferToBase64(this.bigIntToBytes(l)),
                r : this.arrayBufferToBase64(this.bigIntToBytes(r)),
                iterations,
                originalInput: input 
              };

              console.log("Generated proof:", {
                y : proof.y.length  ? "base64 string" : "EMPTY",
                pi: proof.pi.length ? "base64 string" : "EMPTY",
                l : proof.l.length  ? "base64 string" : "EMPTY",
                r : proof.r.length  ? "base64 string" : "EMPTY"
              });

              return proof;
            }





            async verifyVDFProof(input, proof) {
                // Check for missing or invalid proof components
                if (!proof || !proof.y || !proof.pi || !proof.l || !proof.r) {
                    console.warn("Invalid or incomplete VDF proof");
                    return false;
                }
                    if (proof.y.length === 0) console.error("Proof y is empty");
                    if (proof.pi.length === 0) console.error("Proof pi is empty");
                    if (proof.l.length === 0) console.error("Proof l is empty");
                    if (proof.r.length === 0) console.error("Proof r is empty");
                    
                // Always hash the input for verification
                const hashBytes = await this.hashInput(input);
                const x = this.bytesToBigInt(hashBytes);
                
                console.log("Hashed input for verification, x:", x.toString(16).substring(0, 20) + "...");
                
                // Parse y, œÄ, l, r from the proof
                const y = this.bytesToBigInt(this.base64ToArrayBuffer(proof.y));
                const pi = this.bytesToBigInt(this.base64ToArrayBuffer(proof.pi));
                const l = this.bytesToBigInt(this.base64ToArrayBuffer(proof.l));
                const r = this.bytesToBigInt(this.base64ToArrayBuffer(proof.r));
                
                // Verify: y == pi^l * x^r mod N
                const pi_l = this.modPow(pi, l, this.modulus);
                const x_r = this.modPow(x, r, this.modulus);
                const right_side = (pi_l * x_r) % this.modulus;
                
                return y === right_side;
            }
            
            
            
         




          // Efficient modular exponentiation (x^e mod m)
          modPow(x, e, m) {
            if (m === BigInt(1)) return BigInt(0);
            
            let result = BigInt(1);
            x = x % m;
            
            while (e > BigInt(0)) {
              if (e % BigInt(2) === BigInt(1)) {
                result = (result * x) % m;
              }
              e = e >> BigInt(1);
              x = (x * x) % m;
            }
            
            return result;
          }

          // Set callback function for progress updates
          setProgressCallback(callback) {
            this.onProgressUpdate = callback;
          }
          
          // Verify integrity of the key VDF constants
          verifySystemIntegrity() {
            // Check if the class has been tampered with
            if (typeof this.computeVDFProof !== 'function' || 
                typeof this.verifyVDFProof !== 'function' ||
                typeof this.modPow !== 'function') {
              console.error("BitQuillVDF system integrity compromised: core functions missing");
              return false;
            }
                // Verify modulus hasn't been tampered with
            const modulusStr = this.modulus.toString(16).toUpperCase(); // Convert to base 16 (hex) and make uppercase

            // Check if modulus starts with expected prefix (first 20 chars)
            const expectedModulusPrefix = "C7970CEEDCC3B0754490";
            if (!modulusStr.startsWith(expectedModulusPrefix)) {
              console.error("BitQuillVDF system integrity compromised: modulus has been modified");
              return false;
            }
            
            // Verify prime list integrity
            const expectedPrimeCount = 10;
            if (!Array.isArray(this.predefinedPrimes) || 
                this.predefinedPrimes.length !== expectedPrimeCount) {
              console.error("BitQuillVDF system integrity compromised: prime list has been modified");
              return false;
            }
            
            // Check minimum/maximum iteration values
            if (this.MIN_ITERATIONS < 100 || this.MAX_ITERATIONS < 1000 || 
                this.MIN_ITERATIONS > this.MAX_ITERATIONS) {
              console.error("BitQuillVDF system integrity compromised: iteration bounds modified");
              return false;
            }
            
            return true;
          }
          
          // Simple hash function for integrity checks
          simpleHash(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
              const char = str.charCodeAt(i);
              hash = ((hash << 5) - hash) + char;
              hash = hash & hash;
            }
            return hash.toString(16).substring(0, 12);
          }
          
          // Verify a proof with additional integrity checks
        async verifyVDFProofWithIntegrity(input, proof, expectedIterations) {
          // Check system integrity first
          if (!this.verifySystemIntegrity()) {
            return false;
          }
          
          // First check that proof has all expected components
          if (!proof || !proof.y || !proof.pi || !proof.l || !proof.r || !proof.iterations) {
            console.error("Invalid VDF proof structure");
            return false;
          }
          
          // Verify iterations match what we expect
          if (proof.iterations < this.MIN_ITERATIONS || 
              proof.iterations > this.MAX_ITERATIONS ||
              (expectedIterations && proof.iterations !== expectedIterations)) {
            console.error("VDF proof iterations mismatch");
            return false;
          }
          
          try {
            // CRITICAL FIX: Use stored original input if available
            const verificationInput = proof.originalInput || input;
            
            // Add debugging logs to help diagnose verification issues
            console.log("VDF Integrity Verification:");
            console.log("- Input provided:", input ? input.substring(0, 30) + "..." : "MISSING");
            console.log("- Using input:", verificationInput.substring(0, 30) + "...");
            console.log("- Has originalInput:", proof.originalInput ? "YES" : "NO");
            
            // Now perform the cryptographic verification
            const result = await this.verifyVDFProof(verificationInput, proof);
            console.log("VDF verification result:", result);
            return result;
          } catch (error) {
            console.error("Error during VDF proof verification:", error);
            return false;
          }
        }
        

          // Calculate appropriate difficulty based on reputation
          getDifficultyForReputation(reputation) {
            const upvotes = reputation?.upvotes || 0;
            const downvotes = reputation?.downvotes || 0;
            
            // Calculate a reputation score using the forum's existing function
            const repScore = this.calculateReputationScore(upvotes, downvotes);
            
            // Adjust difficulty based on reputation
            if (repScore > 0.8) return this.MIN_ITERATIONS;
            if (repScore > 0.6) return Math.floor(this.MIN_ITERATIONS * 1.5);
            if (repScore > 0.4) return Math.floor(this.MIN_ITERATIONS * 2);
            return Math.floor(this.MIN_ITERATIONS * 3); // New or problematic users
          }
          
            // Safer computation with timeout protection
          async computeVDFProofWithTimeout(input, iterations, timeoutMs = 30000) {
            // Check system integrity before starting computation
            if (!this.verifySystemIntegrity()) {
              throw new Error("VDF system integrity check failed");
            }
            
            // Verify input
            if (typeof input !== 'string' || input.length === 0) {
              throw new Error("Invalid input for VDF computation");
            }
            
            // Normalize iterations to safe bounds
            iterations = Math.min(Math.max(iterations, this.MIN_ITERATIONS), this.MAX_ITERATIONS);
            
            return new Promise(async (resolve, reject) => {
              // Set a timeout to prevent hanging
              const timeout = setTimeout(() => {
                reject(new Error("VDF computation timed out"));
              }, timeoutMs);
              
              try {
                // Perform the actual computation
                const proof = await this.computeVDFProof(input, iterations);
                clearTimeout(timeout);
                
                // Verify the proof after generation as a double-check
                const isValid = await this.verifyVDFProof(input, proof);
                if (!isValid) {
                  reject(new Error("Generated proof failed verification"));
                  return;
                }
                
                resolve(proof);
              } catch (error) {
                clearTimeout(timeout);
                reject(error);
              }
            });
          }                  
        }
    class PeerManager {
  constructor() {
    this.scores = new Map();
  }
  
  updateScore(peerId, action, value = 1) {
    const current = this.scores.get(peerId) || { 
      messages: 0, 
      posts: 0, 
      uptime: Date.now(),
      quality: 1.0 
    };
    
    switch(action) {
      case 'message': current.messages += value; break;
      case 'post': current.posts += value; break;
      case 'error': current.quality *= 0.9; break;
    }
    
    this.scores.set(peerId, current);
  }
  
  getScore(peerId) {
    const data = this.scores.get(peerId);
    if (!data) return 0;
    
    const uptime = (Date.now() - data.uptime) / 1000 / 60; // minutes
    return (data.posts * 10 + data.messages + uptime) * data.quality;
  }
  
  getBestPeers(count = 10) {
    return Array.from(state.peers.entries())
      .map(([id, peer]) => ({ id, peer, score: this.getScore(id) }))
      .sort((a, b) => b.score - a.score)
      .slice(0, count)
      .map(item => item.peer);
  }
}
    
      /* ---------- DANDELION ROUTING ---------- */
    
      
      
class DandelionRouter {
  constructor() {
    this.stemProbability = 0.9;
    this.maxStemLength = 10;
    this.onionLayers = 3; // New: multi-hop routing
  }
  
  // Create onion-wrapped message
  createOnionMessage(msg, hops) {
    let wrapped = msg;
    
    // Wrap message in layers
    for (let i = 0; i < hops.length; i++) {
      wrapped = {
        type: "onion_relay",
        nextHop: i < hops.length - 1 ? hops[i + 1].id : null,
        payload: wrapped,
        padding: this.generatePadding()
      };
    }
    
    return wrapped;
  }
  
  generatePadding() {
    // Random padding to obscure message size
    const size = Math.floor(Math.random() * 512);
    return Array(size).fill('x').join('');
  }
  
  
routePost(post, fromWire = null) {
  const postData = post.toJSON();
  
  // Include VDF proof if present
  if (post.vdfProof) {
    postData.vdfProof = post.vdfProof;
    postData.vdfInput = post.vdfInput;
  }
  
  // Use Plumtree if available and network is large enough
  if (state.plumtree && state.peers.size > 5) {
    state.plumtree.broadcast({
      type: 'post',
      data: postData
    });
    return;
  }
  
  // Fall back to existing Dandelion routing
  const msg = {
    type: "new_post",
    post: postData,
    phase: "stem",
    hopCount: 0
  };
  
  this.propagate(msg, fromWire);
}
  
  // Route through multiple hops
  routePostSecure(post, fromWire = null) {
    const availablePeers = Array.from(state.peers.values())
      .filter(p => p.wire !== fromWire && !p.wire.destroyed);
    
    if (availablePeers.length < this.onionLayers) {
      // Fall back to regular routing if not enough peers
      return this.routePost(post, fromWire);
    }
    
    // Select random path
    const hops = [];
    const shuffled = [...availablePeers].sort(() => Math.random() - 0.5);
    for (let i = 0; i < this.onionLayers; i++) {
      hops.push(shuffled[i]);
    }
    
    const onionMsg = this.createOnionMessage({
      type: "new_post",
      post: post.toJSON(),
      phase: "stem",
      hopCount: 0
    }, hops);
    
    // Send to first hop with delay
    setTimeout(() => {
      sendPeer(hops[0].wire, onionMsg);
    }, Math.random() * 2000);
  }
  
  handleOnionRelay(msg, fromWire) {
    // Peel one layer
    const inner = msg.payload;
    
    if (msg.nextHop) {
      // Forward to next hop
      const nextPeer = Array.from(state.peers.values())
        .find(p => p.id === msg.nextHop);
      
      if (nextPeer) {
        setTimeout(() => {
          sendPeer(nextPeer.wire, inner);
        }, Math.random() * 1000);
      }
    } else {
      // We're the final hop, process the message
      handlePeerMessage(inner, fromWire);
    }
  }
  
      propagate(msg, fromWire = null) {
      // Find all potential peers to forward to (excluding the sender)
      const peers = Array.from(state.peers.values())
        .filter(p => p.wire !== fromWire);
      
      if (peers.length > 0) {
        // Select one random peer to continue the stem
        const randomPeer = peers[Math.floor(Math.random() * peers.length)];
        
        // Send the message to the chosen peer
        sendPeer(randomPeer.wire, msg);
      }
    }

    // Handle incoming posts based on phase
    async handleRoutedPost(msg, fromWire) {
      if (msg.phase === "stem") {
        await this.handleStemPhase(msg, fromWire);
      } else {
        await this.handleFluffPhase(msg, fromWire);
      }
    }

    async handleStemPhase(msg, fromWire) {
      msg.hopCount++;
      
      // Decide whether to continue stem or start fluff
      const continuesStem = Math.random() < this.stemProbability && 
                           msg.hopCount < this.maxStemLength;
      
      if (continuesStem && state.peers.size > 1) {
        // Forward to exactly one random peer (not sender)
        const peers = Array.from(state.peers.values())
          .filter(p => p.wire !== fromWire);
        
        if (peers.length > 0) {
          const randomPeer = peers[Math.floor(Math.random() * peers.length)];
          
          // Add small random delay to prevent timing analysis
          setTimeout(() => {
            sendPeer(randomPeer.wire, msg);
          }, Math.random() * 1000); // 0-1 second delay
        }
      } else {
        // Switch to fluff phase
        msg.phase = "fluff";
        msg.hopCount = 0;
        await this.handleFluffPhase(msg, fromWire);
      }
    }

    async handleFluffPhase(msg, fromWire) {
      // First time seeing this post in fluff phase
      if (!state.posts.has(msg.post.id) && !state.seenPosts.has(msg.post.id)) {
        // Process the post normally
        await handleNewPost(msg.post, fromWire);
        
        // Broadcast to all peers except sender
        for (const { wire } of state.peers.values()) {
          if (wire !== fromWire && !wire.destroyed && wire.ephemeral_msg?._ready) {
            sendPeer(wire, {
              type: "new_post",
              post: msg.post,
              phase: "fluff"
            });
          }
        }
      }
    }
     
  
}

class TrafficMixer {
  constructor() {
    this.mixPool = [];
    this.mixInterval = 5000; // 5 seconds
    this.startMixing();
  }
  
  addToMixPool(msg, wire) {
    this.mixPool.push({ msg, wire, timestamp: Date.now() });
    
    // Limit pool size
    if (this.mixPool.length > 50) {
      this.mixPool.shift();
    }
  }
  
  startMixing() {
    //maintenance loop takes care of this
  }
  
  mix() {
    if (this.mixPool.length < 3) return;
    
    // Shuffle and send random messages
    const shuffled = [...this.mixPool].sort(() => Math.random() - 0.5);
    const toSend = shuffled.slice(0, Math.min(3, shuffled.length));
    
    toSend.forEach(({ msg, wire }) => {
      // Remove from pool
      const index = this.mixPool.indexOf(msg);
      if (index > -1) this.mixPool.splice(index, 1);
      
      // Send with random delay
      setTimeout(() => {
        if (!wire.destroyed) sendPeer(wire, msg);
      }, Math.random() * 1000);
    });
  }
}
class NoiseGenerator {
  constructor() {
    this.noiseInterval = 10000; // 10 seconds
    this.startNoise();
  }
  
  startNoise() {
   //maintenance loop takes care of this
  }
  
  generateNoise() {
    if (state.peers.size < 2) return;
    
    // Random chance to send noise
    if (Math.random() > 0.3) return;
    
    const peers = Array.from(state.peers.values());
    const randomPeer = peers[Math.floor(Math.random() * peers.length)];
    
    const noiseMsg = {
      type: "noise",
      data: Array(Math.floor(Math.random() * 1024))
        .fill(0)
        .map(() => Math.random().toString(36))
        .join(''),
      timestamp: Date.now()
    };
    
    sendPeer(randomPeer.wire, noiseMsg);
  }
}



class StateManager {
  constructor() {
    this.dbName = 'EmberNetwork';
    this.version = 1;
    this.db = null;
  }
  
  async init() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, this.version);
      
      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        this.db = request.result;
        resolve();
      };
      
      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        
        // Posts store
        if (!db.objectStoreNames.contains('posts')) {
          const postsStore = db.createObjectStore('posts', { keyPath: 'id' });
          postsStore.createIndex('timestamp', 'timestamp', { unique: false });
          postsStore.createIndex('parentId', 'parentId', { unique: false });
        }
        
        // User state store (identity, preferences)
        if (!db.objectStoreNames.contains('userState')) {
          db.createObjectStore('userState', { keyPath: 'key' });
        }
        
        // Peer reputation store
        if (!db.objectStoreNames.contains('peerScores')) {
          db.createObjectStore('peerScores', { keyPath: 'peerId' });
        }
      };
    });
  }
  
  

  
  
  
  async savePosts() {
    if (!this.db) return;
    
    const transaction = this.db.transaction(['posts'], 'readwrite');
    const store = transaction.objectStore('posts');
    
    // Clear existing posts first
    await new Promise((resolve) => {
      const clearReq = store.clear();
      clearReq.onsuccess = resolve;
    });
    
    // Save all current posts
    for (const [id, post] of state.posts) {
      const postData = post.toJSON();
      // Include metadata about our explicit carries
      postData.wasExplicitlyCarried = state.explicitlyCarrying.has(id);
      postData.lastSeen = Date.now();
      store.add(postData);
    }
  }
  
  async loadPosts() {
    if (!this.db) return;
    
    const transaction = this.db.transaction(['posts'], 'readonly');
    const store = transaction.objectStore('posts');
    const request = store.getAll();
    
    return new Promise((resolve) => {
      request.onsuccess = () => {
        const posts = request.result;
        const now = Date.now();
        let loadedCount = 0;
        
        posts.forEach(postData => {
          // Check if post is too old (24 hours)
          const age = now - postData.timestamp;
          if (age > 24 * 60 * 60 * 1000) return;
          
          // Check if post should still exist based on carriers
          if (postData.carriers.length === 0) return;
          
          // Recreate the post
          const post = Post.fromJSON(postData);
          
          // Decay carriers based on time away
          const hoursAway = Math.floor((now - postData.lastSeen) / (60 * 60 * 1000));
          const decayFactor = Math.max(0.5, 1 - (hoursAway * 0.1)); // Lose 10% per hour away
          
          // Randomly remove some carriers based on decay
          const carriersArray = [...post.carriers];
          const keepCount = Math.max(1, Math.floor(carriersArray.length * decayFactor));
          
          // Keep our own carry if we explicitly carried it
          const mustKeep = postData.wasExplicitlyCarried ? [state.myIdentity.handle] : [];
          const others = carriersArray.filter(c => c !== state.myIdentity.handle);
          
          // Randomly select carriers to keep
          const shuffled = others.sort(() => Math.random() - 0.5);
          const kept = mustKeep.concat(shuffled.slice(0, keepCount - mustKeep.length));
          
          post.carriers = new Set(kept);
          
          // Only load if post still has carriers
          if (post.carriers.size > 0) {
            state.posts.set(post.id, post);
            if (postData.wasExplicitlyCarried) {
              state.explicitlyCarrying.add(post.id);
            }
            loadedCount++;
          }
        });
        
        console.log(`Loaded ${loadedCount} posts from storage`);
        resolve(loadedCount);
      };
    });
  }
  
  async saveUserState() {
    if (!this.db) return;
    
    const transaction = this.db.transaction(['userState'], 'readwrite');
    const store = transaction.objectStore('userState');
    
    // Save identity
    store.put({ 
      key: 'identity', 
      value: state.myIdentity 
    });
    
    // Save theme preference
    store.put({ 
      key: 'theme', 
      value: localStorage.getItem('ephemeral-theme') || 'dark' 
    });
    
    // Save explicitly carried posts
    store.put({ 
      key: 'explicitlyCarrying', 
      value: Array.from(state.explicitlyCarrying) 
    });
  }
  
  async loadUserState() {
    if (!this.db) return;
    
    const transaction = this.db.transaction(['userState'], 'readonly');
    const store = transaction.objectStore('userState');
    
    // Load identity
    const identityReq = store.get('identity');
    identityReq.onsuccess = () => {
      if (identityReq.result) {
        state.myIdentity = identityReq.result.value;
        console.log('Loaded identity from storage');
      }
    };
    
    // Load explicitly carried posts
    const carryReq = store.get('explicitlyCarrying');
    carryReq.onsuccess = () => {
      if (carryReq.result) {
        state.explicitlyCarrying = new Set(carryReq.result.value);
      }
    };
  }
  
  async savePeerScores() {
    if (!this.db || !peerManager) return;
    
    const transaction = this.db.transaction(['peerScores'], 'readwrite');
    const store = transaction.objectStore('peerScores');
    
    peerManager.scores.forEach((score, peerId) => {
      store.put({ peerId, ...score });
    });
  }
  
  async loadPeerScores() {
    if (!this.db || !peerManager) return;
    
    const transaction = this.db.transaction(['peerScores'], 'readonly');
    const store = transaction.objectStore('peerScores');
    const request = store.getAll();
    
    return new Promise((resolve) => {
      request.onsuccess = () => {
        const scores = request.result;
        scores.forEach(score => {
          const { peerId, ...data } = score;
          peerManager.scores.set(peerId, data);
        });
        console.log(`Loaded ${scores.length} peer scores`);
        resolve();
      };
    });
  }
  
  // Clean up old data
  async cleanup() {
    if (!this.db) return;
    
    const transaction = this.db.transaction(['posts'], 'readwrite');
    const store = transaction.objectStore('posts');
    const index = store.index('timestamp');
    
    // Delete posts older than 7 days
    const cutoff = Date.now() - (7 * 24 * 60 * 60 * 1000);
    const range = IDBKeyRange.upperBound(cutoff);
    
    index.openCursor(range).onsuccess = (event) => {
      const cursor = event.target.result;
      if (cursor) {
        cursor.delete();
        cursor.continue();
      }
    };
  }
}


// --- KADEMLIA DHT IMPLEMENTATION ---
class KademliaDHT {
  constructor(nodeId) {
    this.nodeId = nodeId; // 20-byte ID as Uint8Array
    this.k = 20; // Bucket size
    this.alpha = 3; // Concurrency parameter
    this.buckets = new Array(160).fill(null).map(() => []); // 160 k-buckets
    this.storage = new Map(); // Local storage for key-value pairs
    this.rpcHandlers = new Map();
    this.pendingRPCs = new Map();
    this.rpcTimeout = 5000;
    
    // Initialize RPC handlers
    this.setupRPCHandlers();
  }
  
  // XOR distance between two node IDs
  distance(id1, id2) {
    const dist = new Uint8Array(20);
    for (let i = 0; i < 20; i++) {
      dist[i] = id1[i] ^ id2[i];
    }
    return dist;
  }
  
  // Find the bucket index for a given node ID
  getBucketIndex(nodeId) {
    const dist = this.distance(this.nodeId, nodeId);
    
    // Find the highest bit position
    for (let i = 0; i < 160; i++) {
      const byteIndex = Math.floor(i / 8);
      const bitIndex = 7 - (i % 8);
      
      if ((dist[byteIndex] >> bitIndex) & 1) {
        return 159 - i;
      }
    }
    return 0; // Same node
  }
  
  // Add a peer to the appropriate k-bucket
  addPeer(peerId, peerInfo) {
    if (this.uint8ArrayEquals(peerId, this.nodeId)) return; // Don't add self
    
    const bucketIndex = this.getBucketIndex(peerId);
    const bucket = this.buckets[bucketIndex];
    
    // Check if peer already exists in bucket
    const existingIndex = bucket.findIndex(p => this.uint8ArrayEquals(p.id, peerId));
    
    if (existingIndex !== -1) {
      // Move to end (most recently seen)
      const peer = bucket.splice(existingIndex, 1)[0];
      bucket.push(peer);
      return;
    }
    
    // Add new peer
    if (bucket.length < this.k) {
      bucket.push({
        id: peerId,
        wire: peerInfo.wire,
        lastSeen: Date.now(),
        rtt: 0,
        failures: 0
      });
      console.log(`Added peer to k-bucket ${bucketIndex}, bucket size: ${bucket.length}`);
    } else {
      // Bucket full - ping oldest peer
      const oldest = bucket[0];
      this.ping(oldest).then(isAlive => {
        if (!isAlive) {
          // Replace with new peer
          bucket.shift();
          bucket.push({
            id: peerId,
            wire: peerInfo.wire,
            lastSeen: Date.now(),
            rtt: 0,
            failures: 0
          });
          console.log(`Replaced stale peer in k-bucket ${bucketIndex}`);
        }
      });
    }
  }
  
  // Remove a peer from k-buckets
  removePeer(peerId) {
    const bucketIndex = this.getBucketIndex(peerId);
    const bucket = this.buckets[bucketIndex];
    
    const index = bucket.findIndex(p => this.uint8ArrayEquals(p.id, peerId));
    if (index !== -1) {
      bucket.splice(index, 1);
      console.log(`[DHT] Removed peer from k-bucket ${bucketIndex}, bucket size: ${bucket.length}`);
    }
  }
  
  // Helper to compare Uint8Arrays
  uint8ArrayEquals(a, b) {
    if (a.length !== b.length) return false;
    for (let i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) return false;
    }
    return true;
  }
  
  // Convert string/hex to Uint8Array
  hexToUint8Array(hex) {
    if (hex.startsWith('0x')) {
      hex = hex.slice(2);
    }
    
    if (hex.length % 2) {
      hex = '0' + hex;
    }
    
    const bytes = new Uint8Array(hex.length / 2);
    for (let i = 0; i < bytes.length; i++) {
      bytes[i] = parseInt(hex.substr(i * 2, 2), 16);
    }
    return bytes;
  }
  
  // Convert Uint8Array to hex string
  uint8ArrayToHex(bytes) {
    return Array.from(bytes)
      .map(b => b.toString(16).padStart(2, '0'))
      .join('');
  }
  
  // Hash to node ID using Web Crypto API
  async hashToNodeId(data) {
    const encoder = new TextEncoder();
    const dataBuffer = encoder.encode(data);
    const hashBuffer = await crypto.subtle.digest('SHA-1', dataBuffer);
    return new Uint8Array(hashBuffer);
  }
  
  // Find the k closest peers to a target ID
  findClosestPeers(targetId, count = this.k, excludePeerId = null) {
    const allPeers = [];
    
    for (const bucket of this.buckets) {
      for (const peer of bucket) {
        if (excludePeerId && this.uint8ArrayEquals(peer.id, excludePeerId)) continue;
        if (!peer.wire || peer.wire.destroyed) continue;
        
        const distance = this.distance(targetId, peer.id);
        allPeers.push({ peer, distance });
      }
    }
    
    // Sort by distance
    allPeers.sort((a, b) => {
      for (let i = 0; i < 20; i++) {
        if (a.distance[i] !== b.distance[i]) {
          return a.distance[i] - b.distance[i];
        }
      }
      return 0;
    });
    
    return allPeers.slice(0, count).map(item => item.peer);
  }
  
  // Setup RPC handlers
  setupRPCHandlers() {
    this.rpcHandlers.set('PING', this.handlePing.bind(this));
    this.rpcHandlers.set('FIND_NODE', this.handleFindNode.bind(this));
    this.rpcHandlers.set('FIND_VALUE', this.handleFindValue.bind(this));
    this.rpcHandlers.set('STORE', this.handleStore.bind(this));
  }
  
  // Generate RPC ID
  generateRPCId() {
    return Math.random().toString(36).substr(2, 20);
  }
  
  // Send RPC to a peer
  async sendRPC(peer, method, params) {
    const rpcId = this.generateRPCId();
    
    return new Promise((resolve, reject) => {
      const timeout = setTimeout(() => {
        this.pendingRPCs.delete(rpcId);
        peer.failures++;
        reject(new Error('RPC timeout'));
      }, this.rpcTimeout);
      
      this.pendingRPCs.set(rpcId, { resolve, reject, timeout });
      
      sendPeer(peer.wire, {
        type: 'dht_rpc',
        method,
        params,
        rpcId,
        senderId: this.uint8ArrayToHex(this.nodeId)
      });
    });
  }
  
  // Handle incoming RPC
  handleRPC(msg, fromWire) {
    const { method, params, rpcId, senderId } = msg;
    
    if (msg.isResponse) {
      // Handle RPC response
      const pending = this.pendingRPCs.get(rpcId);
      if (pending) {
        clearTimeout(pending.timeout);
        pending.resolve(msg.result);
        this.pendingRPCs.delete(rpcId);
      }
      return;
    }
    
    // Handle RPC request
    const handler = this.rpcHandlers.get(method);
    if (handler) {
      const result = handler(params, senderId);
      sendPeer(fromWire, {
        type: 'dht_rpc',
        isResponse: true,
        rpcId,
        result
      });
    }
  }
  
  // RPC Handlers
  handlePing(params, senderId) {
    return { alive: true, nodeId: this.uint8ArrayToHex(this.nodeId) };
  }
  
  handleFindNode(params, senderId) {
    const targetId = this.hexToUint8Array(params.targetId);
    const closest = this.findClosestPeers(targetId, this.k);
    
    return {
      peers: closest.map(p => ({
        id: this.uint8ArrayToHex(p.id)
      }))
    };
  }
  
  handleFindValue(params, senderId) {
    const key = params.key;
    
    // Check if we have the value
    if (this.storage.has(key)) {
      return {
        found: true,
        value: this.storage.get(key)
      };
    }
    
    // Return closest peers
    const keyId = this.hashToNodeId(key);
    const closest = this.findClosestPeers(keyId, this.k);
    
    return {
      found: false,
      peers: closest.map(p => ({
        id: this.uint8ArrayToHex(p.id)
      }))
    };
  }
  
  handleStore(params, senderId) {
    const { key, value } = params;
    this.storage.set(key, value);
    
    // Clean up old entries if storage is too large
    if (this.storage.size > 10000) {
      const entries = Array.from(this.storage.entries());
      entries.slice(0, 5000).forEach(([k]) => this.storage.delete(k));
    }
    
    return { stored: true };
  }
  
  // High-level operations
  async ping(peer) {
    try {
      const result = await this.sendRPC(peer, 'PING', {});
      peer.lastSeen = Date.now();
      peer.failures = 0;
      return true;
    } catch (e) {
      return false;
    }
  }
  
  // Iterative find node
  async findNode(targetId) {
    const seen = new Set();
    const shortlist = this.findClosestPeers(targetId, this.alpha);
    
    if (shortlist.length === 0) return [];
    
    let closestNode = shortlist[0];
    let closestDistance = this.distance(targetId, closestNode.id);
    
    while (true) {
      // Query alpha peers in parallel
      const queries = [];
      let queried = 0;
      
      for (const peer of shortlist) {
        const peerId = this.uint8ArrayToHex(peer.id);
        if (seen.has(peerId) || queried >= this.alpha) continue;
        
        seen.add(peerId);
        queried++;
        
        queries.push(
          this.sendRPC(peer, 'FIND_NODE', { 
            targetId: this.uint8ArrayToHex(targetId) 
          }).catch(() => null)
        );
      }
      
      if (queries.length === 0) break;
      
      const results = await Promise.all(queries);
      let improved = false;
      
      for (const result of results) {
        if (!result || !result.peers) continue;
        
        for (const peerInfo of result.peers) {
          const peerId = this.hexToUint8Array(peerInfo.id);
          
          // Check if we have this peer in our buckets
          let found = false;
          for (const bucket of this.buckets) {
            const peer = bucket.find(p => this.uint8ArrayEquals(p.id, peerId));
            if (peer && !seen.has(peerInfo.id)) {
              shortlist.push(peer);
              
              const distance = this.distance(targetId, peerId);
              if (Buffer.compare(distance, closestDistance) < 0) {
                closestDistance = distance;
                closestNode = peer;
                improved = true;
              }
              
              found = true;
              break;
            }
          }
        }
      }
      
      if (!improved) break;
      
      // Sort shortlist by distance
      shortlist.sort((a, b) => {
        const distA = this.distance(targetId, a.id);
        const distB = this.distance(targetId, b.id);
        for (let i = 0; i < 20; i++) {
          if (distA[i] !== distB[i]) {
            return distA[i] - distB[i];
          }
        }
        return 0;
      });
    }
    
    return shortlist.slice(0, this.k);
  }
  
  // Store a value in the DHT
  async store(key, value) {
    const keyId = await this.hashToNodeId(key);
    const closest = await this.findNode(keyId);
    
    const storePromises = closest.slice(0, this.k).map(peer =>
      this.sendRPC(peer, 'STORE', { key, value }).catch(() => false)
    );
    
    const results = await Promise.all(storePromises);
    const stored = results.filter(r => r && r.stored).length;
    
    console.log(`Stored key ${key} at ${stored}/${this.k} nodes`);
    return stored > 0;
  }
  
  // Retrieve a value from the DHT
  async get(key) {
    const keyId = await this.hashToNodeId(key);
    const seen = new Set();
    const shortlist = this.findClosestPeers(keyId, this.alpha);
    
    while (shortlist.length > 0) {
      const peer = shortlist.shift();
      const peerId = this.uint8ArrayToHex(peer.id);
      
      if (seen.has(peerId)) continue;
      seen.add(peerId);
      
      try {
        const result = await this.sendRPC(peer, 'FIND_VALUE', { key });
        
        if (result.found) {
          return result.value;
        }
        
        // Add returned peers to shortlist
        if (result.peers) {
          for (const peerInfo of result.peers) {
            if (!seen.has(peerInfo.id)) {
              // Find peer in our buckets
              for (const bucket of this.buckets) {
                const p = bucket.find(peer => 
                  this.uint8ArrayToHex(peer.id) === peerInfo.id
                );
                if (p) {
                  shortlist.push(p);
                  break;
                }
              }
            }
          }
        }
        
        // Sort by distance
        shortlist.sort((a, b) => {
          const distA = this.distance(keyId, a.id);
          const distB = this.distance(keyId, b.id);
          for (let i = 0; i < 20; i++) {
            if (distA[i] !== distB[i]) {
              return distA[i] - distB[i];
            }
          }
          return 0;
        });
        
      } catch (e) {
        // Continue with next peer
      }
    }
    
    return null;
  }
  
  // Bootstrap the DHT by finding our own node ID
  async bootstrap() {
    console.log("Bootstrapping DHT...");
    const closest = await this.findNode(this.nodeId);
    console.log(`DHT bootstrap complete, found ${closest.length} peers`);
  }
  
  // Get routing table statistics
  getStats() {
    let totalPeers = 0;
    let activeBuckets = 0;
    
    for (let i = 0; i < this.buckets.length; i++) {
      const bucketSize = this.buckets[i].length;
      totalPeers += bucketSize;
      if (bucketSize > 0) activeBuckets++;
    }
    
    return {
      totalPeers,
      activeBuckets,
      avgBucketSize: activeBuckets > 0 ? (totalPeers / activeBuckets).toFixed(2) : 0,
      storageSize: this.storage.size
    };
  }
}

// --- HYPARVIEW PROTOCOL IMPLEMENTATION ---
class HyParView {
  constructor(nodeId, dht) {
    this.nodeId = nodeId;
    this.dht = dht;
    
    // Protocol parameters
    this.activeViewSize = 5; // Small active view
    this.passiveViewSize = 30; // Larger passive view
    this.shuffleLength = 4; // Number of peers to exchange in shuffle
    this.shuffleInterval = 10000; // 10 seconds
    
    // Views
    this.activeView = new Map(); // peerId -> peer info
    this.passiveView = new Map(); // peerId -> peer info
    
    // Protocol state
    this.shuffleTimer = null;
    this.joinTimer = null;
    this.isBootstrapping = false;
    
    // Start periodic shuffle
    this.startShuffle();
  }
  
  // Add a peer to active view
  addToActiveView(peerId, peerInfo) {
    const peerIdStr = this.dht.uint8ArrayToHex(peerId);
    
    if (this.activeView.has(peerIdStr)) return true;
    
    // Check if active view is full
    if (this.activeView.size >= this.activeViewSize) {
      // Try to drop a peer
      const dropped = this.dropFromActiveView();
      if (!dropped) return false;
    }
    
    this.activeView.set(peerIdStr, {
      id: peerId,
      wire: peerInfo.wire,
      addedAt: Date.now(),
      isOutgoing: peerInfo.isOutgoing || false
    });
    
    console.log(`[HyParView] Added peer to active view. Active: ${this.activeView.size}/${this.activeViewSize}`);
    
    // Remove from passive view if present
    this.passiveView.delete(peerIdStr);
    
    return true;
  }
  
  // Add a peer to passive view
  addToPassiveView(peerId, peerInfo) {
    const peerIdStr = this.dht.uint8ArrayToHex(peerId);
    
    if (this.activeView.has(peerIdStr) || this.passiveView.has(peerIdStr)) {
      return false;
    }
    
    if (this.passiveView.size >= this.passiveViewSize) {
      // Drop random peer from passive view
      const keys = Array.from(this.passiveView.keys());
      const randomKey = keys[Math.floor(Math.random() * keys.length)];
      this.passiveView.delete(randomKey);
    }
    
    this.passiveView.set(peerIdStr, {
      id: peerId,
      wire: peerInfo.wire || null,
      addedAt: Date.now(),
      priority: peerInfo.priority || 0
    });
    
    console.log(`[HyParView] Added peer to passive view. Passive: ${this.passiveView.size}/${this.passiveViewSize}`);
    
    return true;
  }
  
  // Drop a peer from active view (prioritize dropping incoming connections)
  dropFromActiveView() {
    let candidates = [];
    
    // Prefer to drop incoming connections
    for (const [peerId, peer] of this.activeView) {
      if (!peer.isOutgoing) {
        candidates.push(peerId);
      }
    }
    
    // If no incoming connections, consider all
    if (candidates.length === 0) {
      candidates = Array.from(this.activeView.keys());
    }
    
    if (candidates.length === 0) return false;
    
    // Drop random candidate
    const toDrop = candidates[Math.floor(Math.random() * candidates.length)];
    const peer = this.activeView.get(toDrop);
    
    this.activeView.delete(toDrop);
    
    // Move to passive view
    this.addToPassiveView(peer.id, peer);
    
    // Send DISCONNECT message
    if (peer.wire && !peer.wire.destroyed) {
      sendPeer(peer.wire, {
        type: 'hyparview',
        subtype: 'DISCONNECT'
      });
    }
    
    return true;
  }
  
  // Handle peer failure
  handlePeerFailure(peerId) {
    const peerIdStr = this.dht.uint8ArrayToHex(peerId);
    
    if (!this.activeView.has(peerIdStr)) return;
    
    console.log(`[HyParView] Peer failed: ${peerIdStr.substring(0, 12)}...`);
    
    // Remove from active view
    this.activeView.delete(peerIdStr);
    
    // Try to replace with peer from passive view
    if (this.passiveView.size > 0) {
      const candidates = Array.from(this.passiveView.values())
        .filter(p => p.wire && !p.wire.destroyed)
        .sort((a, b) => b.priority - a.priority);
      
      if (candidates.length > 0) {
        const replacement = candidates[0];
        this.promoteToActiveView(replacement.id);
      }
    }
    
    // If active view is too small, trigger recovery
    if (this.activeView.size < Math.floor(this.activeViewSize / 2)) {
      this.triggerRecovery();
    }
  }
  
  // Promote a peer from passive to active view
  promoteToActiveView(peerId) {
    const peerIdStr = this.dht.uint8ArrayToHex(peerId);
    const peer = this.passiveView.get(peerIdStr);
    
    if (!peer) return false;
    
    // Send JOIN request
    if (peer.wire && !peer.wire.destroyed) {
      sendPeer(peer.wire, {
        type: 'hyparview',
        subtype: 'JOIN',
        ttl: 3,
        sender: this.dht.uint8ArrayToHex(this.nodeId)
      });
      
      return this.addToActiveView(peerId, { ...peer, isOutgoing: true });
    }
    
    return false;
  }
  
  // Handle incoming HyParView messages
  handleMessage(msg, fromWire) {
    switch (msg.subtype) {
      case 'JOIN':
        this.handleJoin(msg, fromWire);
        break;
      case 'FORWARD_JOIN':
        this.handleForwardJoin(msg, fromWire);
        break;
      case 'NEIGHBOR':
        this.handleNeighbor(msg, fromWire);
        break;
      case 'SHUFFLE':
        this.handleShuffle(msg, fromWire);
        break;
      case 'SHUFFLE_REPLY':
        this.handleShuffleReply(msg, fromWire);
        break;
      case 'DISCONNECT':
        this.handleDisconnect(msg, fromWire);
        break;
    }
  }
  
  // Handle JOIN request
  handleJoin(msg, fromWire) {
    const senderId = this.dht.hexToUint8Array(msg.sender);
    
    // Add to active view if possible
    const added = this.addToActiveView(senderId, { wire: fromWire, isOutgoing: false });
    
    if (added) {
      // Forward JOIN to other peers
      if (msg.ttl > 0) {
        const activeList = Array.from(this.activeView.values())
          .filter(p => this.dht.uint8ArrayToHex(p.id) !== msg.sender);
        
        if (activeList.length > 0) {
          const target = activeList[Math.floor(Math.random() * activeList.length)];
          
          sendPeer(target.wire, {
            type: 'hyparview',
            subtype: 'FORWARD_JOIN',
            ttl: msg.ttl - 1,
            sender: msg.sender,
            forwarder: this.dht.uint8ArrayToHex(this.nodeId)
          });
        }
      }
    } else {
      // Add to passive view
      this.addToPassiveView(senderId, { wire: fromWire });
    }
  }
  
  // Handle FORWARD_JOIN
  handleForwardJoin(msg, fromWire) {
    const senderId = this.dht.hexToUint8Array(msg.sender);
    
    if (msg.ttl === 0 || this.activeView.size >= this.activeViewSize) {
      // Send NEIGHBOR message back to original sender
      const senderPeer = this.findPeerByWire(fromWire);
      if (senderPeer) {
        sendPeer(fromWire, {
          type: 'hyparview',
          subtype: 'NEIGHBOR',
          target: msg.sender,
          priority: this.activeView.size < this.activeViewSize ? 'high' : 'low'
        });
      }
    } else {
      // Continue forwarding
      const activeList = Array.from(this.activeView.values())
        .filter(p => this.dht.uint8ArrayToHex(p.id) !== msg.sender && 
                    this.dht.uint8ArrayToHex(p.id) !== msg.forwarder);
      
      if (activeList.length > 0) {
        const target = activeList[Math.floor(Math.random() * activeList.length)];
        
        sendPeer(target.wire, {
          type: 'hyparview',
          subtype: 'FORWARD_JOIN',
          ttl: msg.ttl - 1,
          sender: msg.sender,
          forwarder: this.dht.uint8ArrayToHex(this.nodeId)
        });
      }
    }
  }
  
  // Handle NEIGHBOR message
  handleNeighbor(msg, fromWire) {
    const peerId = fromWire.peerId;
    
    if (msg.priority === 'high') {
      this.addToActiveView(peerId, { wire: fromWire, isOutgoing: false });
    } else {
      this.addToPassiveView(peerId, { wire: fromWire, priority: 1 });
    }
  }
  
  // Handle SHUFFLE request
  handleShuffle(msg, fromWire) {
    const senderId = fromWire.peerId;
    
    // Select random peers from passive view
    const passiveList = Array.from(this.passiveView.entries());
    const selected = [];
    
    for (let i = 0; i < this.shuffleLength && passiveList.length > 0; i++) {
      const index = Math.floor(Math.random() * passiveList.length);
      const [peerId, peer] = passiveList.splice(index, 1)[0];
      selected.push(peerId);
    }
    
    // Send reply
    sendPeer(fromWire, {
      type: 'hyparview',
      subtype: 'SHUFFLE_REPLY',
      peers: selected
    });
    
    // Add received peers to passive view
    if (msg.peers) {
      for (const peerId of msg.peers) {
        this.addToPassiveView(this.dht.hexToUint8Array(peerId), { priority: 0 });
      }
    }
  }
  
  // Handle SHUFFLE_REPLY
  handleShuffleReply(msg, fromWire) {
    if (msg.peers) {
      for (const peerId of msg.peers) {
        this.addToPassiveView(this.dht.hexToUint8Array(peerId), { priority: 0 });
      }
    }
  }
  
  // Handle DISCONNECT
  handleDisconnect(msg, fromWire) {
    const peer = this.findPeerByWire(fromWire);
    if (peer) {
      const peerIdStr = this.dht.uint8ArrayToHex(peer.id);
      this.activeView.delete(peerIdStr);
      console.log(`[HyParView] Peer disconnected: ${peerIdStr.substring(0, 12)}...`);
    }
  }
  
  // Find peer by wire connection
  findPeerByWire(wire) {
    for (const [peerId, peer] of this.activeView) {
      if (peer.wire === wire) return peer;
    }
    for (const [peerId, peer] of this.passiveView) {
      if (peer.wire === wire) return peer;
    }
    return null;
  }
  
  // Start periodic shuffle
  startShuffle() {
    this.shuffleTimer = setInterval(() => {
      this.performShuffle();
    }, this.shuffleInterval);
  }
  
  // Perform shuffle operation
  performShuffle() {
    if (this.activeView.size === 0) return;
    
    // Select random active peer
    const activePeers = Array.from(this.activeView.values());
    const target = activePeers[Math.floor(Math.random() * activePeers.length)];
    
    // Select random subset from active and passive views
    const toSend = [];
    const combined = [
      ...Array.from(this.activeView.keys()),
      ...Array.from(this.passiveView.keys())
    ];
    
    for (let i = 0; i < this.shuffleLength && combined.length > 0; i++) {
      const index = Math.floor(Math.random() * combined.length);
      toSend.push(combined.splice(index, 1)[0]);
    }
    
    if (toSend.length > 0 && target.wire && !target.wire.destroyed) {
      sendPeer(target.wire, {
        type: 'hyparview',
        subtype: 'SHUFFLE',
        peers: toSend
      });
    }
  }
  
  // Trigger recovery when active view is too small
  triggerRecovery() {
    console.log(`[HyParView] Triggering recovery. Active view size: ${this.activeView.size}`);
    
    // Try to promote peers from passive view
    const candidates = Array.from(this.passiveView.values())
      .filter(p => p.wire && !p.wire.destroyed);
    
    const needed = this.activeViewSize - this.activeView.size;
    for (let i = 0; i < needed && i < candidates.length; i++) {
      this.promoteToActiveView(candidates[i].id);
    }
    
    // If still not enough peers, use DHT to find more
    if (this.activeView.size < this.activeViewSize) {
      this.dht.findNode(this.nodeId).then(peers => {
        for (const peer of peers) {
          if (this.activeView.size >= this.activeViewSize) break;
          
          const peerId = peer.id;
          if (!this.activeView.has(this.dht.uint8ArrayToHex(peerId))) {
            this.addToActiveView(peerId, { wire: peer.wire, isOutgoing: true });
          }
        }
      });
    }
  }
  
  // Bootstrap the overlay
  async bootstrap() {
    console.log("[HyParView] Starting bootstrap...");
    this.isBootstrapping = true;
    
    // Use DHT to find initial peers
    const peers = await this.dht.findNode(this.nodeId);
    
    for (const peer of peers) {
      if (this.activeView.size >= this.activeViewSize) break;
      
      // Send JOIN request
      sendPeer(peer.wire, {
        type: 'hyparview',
        subtype: 'JOIN',
        ttl: 3,
        sender: this.dht.uint8ArrayToHex(this.nodeId)
      });
      
      this.addToActiveView(peer.id, { wire: peer.wire, isOutgoing: true });
    }
    
    this.isBootstrapping = false;
    console.log(`[HyParView] Bootstrap complete. Active: ${this.activeView.size}, Passive: ${this.passiveView.size}`);
  }
  
  // Get current statistics
  getStats() {
    return {
      activeView: this.activeView.size,
      passiveView: this.passiveView.size,
      activeCapacity: `${this.activeView.size}/${this.activeViewSize}`,
      passiveCapacity: `${this.passiveView.size}/${this.passiveViewSize}`
    };
  }
  
  // Get active peers for message propagation
  getActivePeers() {
    return Array.from(this.activeView.values())
      .filter(p => p.wire && !p.wire.destroyed);
  }
  
  // Cleanup on shutdown
  destroy() {
    if (this.shuffleTimer) {
      clearInterval(this.shuffleTimer);
    }
    
    // Send disconnect to all active peers
    for (const peer of this.activeView.values()) {
      if (peer.wire && !peer.wire.destroyed) {
        sendPeer(peer.wire, {
          type: 'hyparview',
          subtype: 'DISCONNECT'
        });
      }
    }
    
    this.activeView.clear();
    this.passiveView.clear();
  }
}

// --- SCRIBE MULTICAST PROTOCOL ---
class Scribe {
  constructor(nodeId, dht) {
    this.nodeId = nodeId;
    this.dht = dht;
    
    // Topic management
    this.subscribedTopics = new Map(); // topic -> { rendezvousId, parent, children, lastRefresh }
    this.topicMessages = new Map(); // topic -> recent message IDs (for dedup)
    
    // Protocol parameters
    this.heartbeatInterval = 30000; // 30 seconds
    this.treeRepairTimeout = 60000; // 60 seconds
    this.maxChildren = 16; // Max children per node in multicast tree
    
    // Start maintenance
    this.maintenanceTimer = null;
  }
  
  // Extract topics from post content
  extractTopics(content) {
    const topics = new Set();
    
    // Extract hashtags
    const hashtags = content.match(/#\w+/g) || [];
    hashtags.forEach(tag => topics.add(tag.toLowerCase()));
    
    // Extract keywords (simple approach)
    const keywords = ['tech', 'news', 'art', 'music', 'politics', 'science'];
    const contentLower = content.toLowerCase();
    keywords.forEach(keyword => {
      if (contentLower.includes(keyword)) {
        topics.add(`#${keyword}`);
      }
    });
    
    // Always include a default topic
    topics.add('#general');
    
    return Array.from(topics);
  }
  
  // Get rendezvous node for a topic
  async getRendezvousNode(topic) {
    return await this.dht.hashToNodeId(topic);
  }
  
  // Subscribe to a topic
  async subscribe(topic) {
    if (this.subscribedTopics.has(topic)) return;
    
    console.log(`[Scribe] Subscribing to topic: ${topic}`);
    
    const rendezvousId = await this.getRendezvousNode(topic);
    const topicInfo = {
      rendezvousId,
      parent: null,
      children: new Set(),
      lastRefresh: Date.now()
    };
    
    this.subscribedTopics.set(topic, topicInfo);
    
    // Find route to rendezvous node
    const route = await this.dht.findNode(rendezvousId);
    
    if (route.length === 0) {
      // We are the rendezvous node
      console.log(`[Scribe] We are the rendezvous node for ${topic}`);
      return;
    }
    
    // Send JOIN request along the route
    const nextHop = route[0];
    this.sendJoinRequest(topic, nextHop);
  }
  
  // Unsubscribe from a topic
  unsubscribe(topic) {
    const topicInfo = this.subscribedTopics.get(topic);
    if (!topicInfo) return;
    
    console.log(`[Scribe] Unsubscribing from topic: ${topic}`);
    
    // Notify parent
    if (topicInfo.parent) {
      sendPeer(topicInfo.parent.wire, {
        type: 'scribe',
        subtype: 'LEAVE',
        topic,
        childId: this.dht.uint8ArrayToHex(this.nodeId)
      });
    }
    
    // Notify children to find new parent
    topicInfo.children.forEach(child => {
      sendPeer(child.wire, {
        type: 'scribe',
        subtype: 'PARENT_FAILED',
        topic
      });
    });
    
    this.subscribedTopics.delete(topic);
    this.topicMessages.delete(topic);
  }
  
  // Send JOIN request
  sendJoinRequest(topic, peer) {
    sendPeer(peer.wire, {
      type: 'scribe',
      subtype: 'JOIN',
      topic,
      nodeId: this.dht.uint8ArrayToHex(this.nodeId)
    });
  }
  
  // Handle incoming Scribe messages
  handleMessage(msg, fromWire) {
    switch (msg.subtype) {
      case 'JOIN':
        this.handleJoin(msg, fromWire);
        break;
      case 'LEAVE':
        this.handleLeave(msg, fromWire);
        break;
      case 'MULTICAST':
        this.handleMulticast(msg, fromWire);
        break;
      case 'HEARTBEAT':
        this.handleHeartbeat(msg, fromWire);
        break;
      case 'PARENT_FAILED':
        this.handleParentFailed(msg, fromWire);
        break;
    }
  }
  
  // Handle JOIN request
  async handleJoin(msg, fromWire) {
    const { topic, nodeId } = msg;
    const senderId = this.dht.hexToUint8Array(nodeId);
    
    const topicInfo = this.subscribedTopics.get(topic);
    const rendezvousId = await this.getRendezvousNode(topic);
    
    // Check if we're closer to rendezvous than sender
    const ourDistance = this.dht.distance(this.nodeId, rendezvousId);
    const senderDistance = this.dht.distance(senderId, rendezvousId);
    
    if (!topicInfo && this.compareDistances(ourDistance, senderDistance) > 0) {
      // Forward JOIN to next hop
      const route = await this.dht.findNode(rendezvousId);
      if (route.length > 0) {
        sendPeer(route[0].wire, msg);
      }
      return;
    }
    
    // We're on the multicast tree - accept as child
    if (!topicInfo) {
      // Create topic subscription
      this.subscribedTopics.set(topic, {
        rendezvousId,
        parent: null,
        children: new Set(),
        lastRefresh: Date.now()
      });
    }
    
    const info = this.subscribedTopics.get(topic);
    
    if (info.children.size < this.maxChildren) {
      // Accept as child
      info.children.add({
        id: senderId,
        wire: fromWire,
        joinedAt: Date.now()
      });
      
      console.log(`[Scribe] Added child for topic ${topic}. Children: ${info.children.size}`);
      
      // Send acceptance
      sendPeer(fromWire, {
        type: 'scribe',
        subtype: 'JOIN_ACK',
        topic
      });
    } else {
      // Reject - tree node full
      sendPeer(fromWire, {
        type: 'scribe',
        subtype: 'JOIN_REJECT',
        topic
      });
    }
  }
  
  // Compare two distances
  compareDistances(dist1, dist2) {
    for (let i = 0; i < dist1.length; i++) {
      if (dist1[i] !== dist2[i]) {
        return dist1[i] - dist2[i];
      }
    }
    return 0;
  }
  
  // Handle LEAVE message
  handleLeave(msg, fromWire) {
    const { topic, childId } = msg;
    const topicInfo = this.subscribedTopics.get(topic);
    
    if (!topicInfo) return;
    
    // Remove child
    topicInfo.children = new Set(
      Array.from(topicInfo.children).filter(
        child => this.dht.uint8ArrayToHex(child.id) !== childId
      )
    );
    
    console.log(`[Scribe] Child left topic ${topic}. Children: ${topicInfo.children.size}`);
  }
  
  // Multicast a message to a topic
  async multicast(topic, message) {
    const topicInfo = this.subscribedTopics.get(topic);
    if (!topicInfo) {
      // Not subscribed - route to rendezvous
      const rendezvousId = await this.getRendezvousNode(topic);
      const route = await this.dht.findNode(rendezvousId);
      if (route.length > 0) {
        sendPeer(route[0].wire, {
          type: 'scribe',
          subtype: 'MULTICAST',
          topic,
          message,
          messageId: generateId(),
          origin: this.dht.uint8ArrayToHex(this.nodeId)
        });
      }
      return;
    }
    
    // We're on the tree - disseminate
    const messageId = generateId();
    this.disseminateMessage(topic, message, messageId, null);
  }
  
  // Disseminate message down the tree
  disseminateMessage(topic, message, messageId, fromWire) {
    const topicInfo = this.subscribedTopics.get(topic);
    if (!topicInfo) return;
    
    // Check for duplicate
    let recentMessages = this.topicMessages.get(topic);
    if (!recentMessages) {
      recentMessages = new Set();
      this.topicMessages.set(topic, recentMessages);
    }
    
    if (recentMessages.has(messageId)) return;
    recentMessages.add(messageId);
    
    // Clean old messages
    if (recentMessages.size > 1000) {
      const arr = Array.from(recentMessages);
      arr.slice(0, 500).forEach(id => recentMessages.delete(id));
    }
    
    // Forward to parent (if not from parent)
    if (topicInfo.parent && topicInfo.parent.wire !== fromWire) {
      sendPeer(topicInfo.parent.wire, {
        type: 'scribe',
        subtype: 'MULTICAST',
        topic,
        message,
        messageId
      });
    }
    
    // Forward to children (except sender)
    topicInfo.children.forEach(child => {
      if (child.wire !== fromWire && !child.wire.destroyed) {
        sendPeer(child.wire, {
          type: 'scribe',
          subtype: 'MULTICAST',
          topic,
          message,
          messageId
        });
      }
    });
    
    // Deliver locally
    this.deliverMessage(topic, message);
  }
  
  // Handle multicast message
  handleMulticast(msg, fromWire) {
    const { topic, message, messageId } = msg;
    this.disseminateMessage(topic, message, messageId, fromWire);
  }
  
  // Deliver message to local application
  deliverMessage(topic, message) {
    // For now, just log it - integrate with post handling later
    console.log(`[Scribe] Delivered message on topic ${topic}:`, message);
  }
  
  // Start maintenance tasks
  startMaintenance() {
    this.maintenanceTimer = setInterval(() => {
      this.sendHeartbeats();
      this.checkTreeHealth();
    }, this.heartbeatInterval);
  }
  
  // Send heartbeats to children
  sendHeartbeats() {
    this.subscribedTopics.forEach((info, topic) => {
      info.children.forEach(child => {
        if (!child.wire.destroyed) {
          sendPeer(child.wire, {
            type: 'scribe',
            subtype: 'HEARTBEAT',
            topic
          });
        } else {
          // Remove dead child
          info.children.delete(child);
        }
      });
    });
  }
  
  // Check tree health
  checkTreeHealth() {
    const now = Date.now();
    
    this.subscribedTopics.forEach((info, topic) => {
      // Check if parent is still alive
      if (info.parent && now - info.lastRefresh > this.treeRepairTimeout) {
        console.log(`[Scribe] Parent timeout for topic ${topic}, repairing...`);
        this.repairTree(topic);
      }
    });
  }
  
  // Handle heartbeat
  handleHeartbeat(msg, fromWire) {
    const { topic } = msg;
    const topicInfo = this.subscribedTopics.get(topic);
    
    if (topicInfo && topicInfo.parent && topicInfo.parent.wire === fromWire) {
      topicInfo.lastRefresh = Date.now();
    }
  }
  
  // Handle parent failure
  handleParentFailed(msg, fromWire) {
    const { topic } = msg;
    this.repairTree(topic);
  }
  
  // Repair tree after parent failure
  repairTree(topic) {
    const topicInfo = this.subscribedTopics.get(topic);
    if (!topicInfo) return;
    
    topicInfo.parent = null;
    
    // Re-subscribe
    this.subscribe(topic);
  }
  
  // Get statistics
  getStats() {
    const stats = {
      subscribedTopics: this.subscribedTopics.size,
      totalChildren: 0,
      topics: []
    };
    
    this.subscribedTopics.forEach((info, topic) => {
      stats.totalChildren += info.children.size;
      stats.topics.push({
        topic,
        children: info.children.size,
        hasParent: !!info.parent
      });
    });
    
    return stats;
  }
  
  // Cleanup on shutdown
  destroy() {
    if (this.maintenanceTimer) {
      clearInterval(this.maintenanceTimer);
    }
    
    // Unsubscribe from all topics
    Array.from(this.subscribedTopics.keys()).forEach(topic => {
      this.unsubscribe(topic);
    });
  }
}

// --- PLUMTREE GOSSIP PROTOCOL ---
class Plumtree {
  constructor(nodeId, hyparview) {
    this.nodeId = nodeId;
    this.hyparview = hyparview; // Use HyParView's active view as eager push peers
    
    // Protocol state
    this.eagerPushPeers = new Set(); // Peers we eagerly push to
    this.lazyPushPeers = new Set();  // Peers we only send IHAVE to
    this.missing = new Map(); // messageId -> { requestTime, timeout }
    this.receivedMessages = new Map(); // messageId -> { message, receivedFrom }
    
    // Protocol parameters
    this.lazyPushDelay = 100; // ms before sending IHAVE
    this.missingTimeout = 3000; // ms to wait for missing message
    this.pruneDelay = 1000; // ms before pruning eager peers
    this.messageHistorySize = 10000;
    
    // Optimization metrics
    this.metrics = {
      messagesReceived: 0,
      duplicatesReceived: 0,
      messagesRequested: 0,
      messagesPruned: 0
    };
    
    // Initialize eager peers from HyParView
    this.initializeEagerPeers();
  }
  
  // Initialize eager push peers from HyParView active view
  initializeEagerPeers() {
    const activePeers = this.hyparview.getActivePeers();
    activePeers.forEach(peer => {
      const peerIdStr = this.hyparview.dht.uint8ArrayToHex(peer.id);
      this.eagerPushPeers.add(peerIdStr);
    });
    console.log(`[Plumtree] Initialized with ${this.eagerPushPeers.size} eager peers`);
  }
  
  // Broadcast a new message
  broadcast(message, excludePeerId = null) {
    const messageId = message.id || generateId();
    message.id = messageId;
    message.originId = this.hyparview.dht.uint8ArrayToHex(this.nodeId);
    
    // Add to our received messages
    this.receivedMessages.set(messageId, {
      message,
      receivedFrom: null,
      timestamp: Date.now()
    });
    
    // Eager push to all eager peers
    this.eagerPush(message, excludePeerId);
    
    // Lazy push to all lazy peers
    setTimeout(() => {
      this.lazyPush(messageId, excludePeerId);
    }, this.lazyPushDelay);
    
    return messageId;
  }
  
  // Eager push - send full message
  eagerPush(message, excludePeerId = null) {
    const activePeers = this.hyparview.getActivePeers();
    
    activePeers.forEach(peer => {
      const peerIdStr = this.hyparview.dht.uint8ArrayToHex(peer.id);
      
      // Skip excluded peer and non-eager peers
      if (peerIdStr === excludePeerId || !this.eagerPushPeers.has(peerIdStr)) {
        return;
      }
      
      if (!peer.wire.destroyed) {
        sendPeer(peer.wire, {
          type: 'plumtree',
          subtype: 'GOSSIP',
          message
        });
      }
    });
  }
  
  // Lazy push - send only IHAVE
  lazyPush(messageId, excludePeerId = null) {
    const activePeers = this.hyparview.getActivePeers();
    
    activePeers.forEach(peer => {
      const peerIdStr = this.hyparview.dht.uint8ArrayToHex(peer.id);
      
      // Skip excluded peer and eager peers
      if (peerIdStr === excludePeerId || this.eagerPushPeers.has(peerIdStr)) {
        return;
      }
      
      if (!peer.wire.destroyed) {
        sendPeer(peer.wire, {
          type: 'plumtree',
          subtype: 'IHAVE',
          messageIds: [messageId]
        });
      }
    });
  }
  
  // Handle incoming Plumtree messages
  handleMessage(msg, fromWire) {
    const fromPeerId = fromWire.peerId ? 
      this.hyparview.dht.uint8ArrayToHex(fromWire.peerId) : null;
    
    switch (msg.subtype) {
      case 'GOSSIP':
        this.handleGossip(msg.message, fromPeerId, fromWire);
        break;
      case 'IHAVE':
        this.handleIHave(msg.messageIds, fromPeerId, fromWire);
        break;
      case 'GRAFT':
        this.handleGraft(fromPeerId, msg.messageId, fromWire);
        break;
      case 'PRUNE':
        this.handlePrune(fromPeerId);
        break;
    }
  }
  
  // Handle received gossip message
  handleGossip(message, fromPeerId, fromWire) {
    const messageId = message.id;
    
    // Check if we've seen this message
    if (this.receivedMessages.has(messageId)) {
      // Duplicate - consider pruning this eager peer
      this.metrics.duplicatesReceived++;
      
      // Prune after delay if we keep getting duplicates
      setTimeout(() => {
        if (this.eagerPushPeers.has(fromPeerId)) {
          this.prune(fromPeerId, fromWire);
        }
      }, this.pruneDelay);
      
      return;
    }
    
    // New message
    this.metrics.messagesReceived++;
    this.receivedMessages.set(messageId, {
      message,
      receivedFrom: fromPeerId,
      timestamp: Date.now()
    });
    
    // Cancel any pending request for this message
    if (this.missing.has(messageId)) {
      const { timeout } = this.missing.get(messageId);
      clearTimeout(timeout);
      this.missing.delete(messageId);
    }
    
    // Graft the sender as eager peer (they were first)
    if (!this.eagerPushPeers.has(fromPeerId)) {
      this.graft(fromPeerId);
    }
    
    // Deliver to application
    this.deliver(message);
    
    // Forward to other peers
    this.eagerPush(message, fromPeerId);
    setTimeout(() => {
      this.lazyPush(messageId, fromPeerId);
    }, this.lazyPushDelay);
    
    // Clean old messages periodically
    if (this.receivedMessages.size > this.messageHistorySize) {
      this.cleanupOldMessages();
    }
  }
  
  // Handle IHAVE announcements
  handleIHave(messageIds, fromPeerId, fromWire) {
    messageIds.forEach(messageId => {
      // If we don't have this message and haven't requested it
      if (!this.receivedMessages.has(messageId) && !this.missing.has(messageId)) {
        // Request the message
        this.requestMessage(messageId, fromPeerId, fromWire);
      }
    });
  }
  
  // Request a missing message
  requestMessage(messageId, fromPeerId, fromWire) {
    this.metrics.messagesRequested++;
    
    // Send GRAFT to request the message
    sendPeer(fromWire, {
      type: 'plumtree',
      subtype: 'GRAFT',
      messageId
    });
    
    // Set timeout for missing message
    const timeout = setTimeout(() => {
      this.missing.delete(messageId);
      // Could implement retry logic here
    }, this.missingTimeout);
    
    this.missing.set(messageId, {
      requestTime: Date.now(),
      timeout,
      requestedFrom: fromPeerId
    });
  }
  
  // Handle GRAFT request - add peer to eager set
  handleGraft(fromPeerId, messageId, fromWire) {
    this.eagerPushPeers.add(fromPeerId);
    this.lazyPushPeers.delete(fromPeerId);
    
    // If we have the requested message, send it
    if (messageId && this.receivedMessages.has(messageId)) {
      const { message } = this.receivedMessages.get(messageId);
      const peer = this.findPeerById(fromPeerId);
      
      if (peer && !peer.wire.destroyed) {
        sendPeer(peer.wire, {
          type: 'plumtree',
          subtype: 'GOSSIP',
          message
        });
      }
    }
    
    console.log(`[Plumtree] Grafted peer ${fromPeerId.substring(0, 12)}... as eager`);
  }
  
  // Handle PRUNE request - move peer to lazy set
  handlePrune(fromPeerId) {
    this.eagerPushPeers.delete(fromPeerId);
    this.lazyPushPeers.add(fromPeerId);
    this.metrics.messagesPruned++;
    
    console.log(`[Plumtree] Pruned peer ${fromPeerId.substring(0, 12)}... to lazy`);
  }
  
  // Graft a peer (make eager)
  graft(peerId) {
    this.eagerPushPeers.add(peerId);
    this.lazyPushPeers.delete(peerId);
  }
  
  // Prune a peer (make lazy)
  prune(peerId, wire) {
    this.eagerPushPeers.delete(peerId);
    this.lazyPushPeers.add(peerId);
    
    // Send PRUNE message
    if (wire && !wire.destroyed) {
      sendPeer(wire, {
        type: 'plumtree',
        subtype: 'PRUNE'
      });
    }
  }
  
  // Find peer by ID
  findPeerById(peerId) {
    const activePeers = this.hyparview.getActivePeers();
    return activePeers.find(p => this.hyparview.dht.uint8ArrayToHex(p.id) === peerId);
  }
  
  // Deliver message to application
  deliver(message) {
    // Override this method for application-specific delivery
    console.log(`[Plumtree] Delivered message: ${message.id}`);
  }
  
  // Clean up old messages
  cleanupOldMessages() {
    const cutoff = Date.now() - 3600000; // 1 hour
    const toDelete = [];
    
    this.receivedMessages.forEach((data, messageId) => {
      if (data.timestamp < cutoff) {
        toDelete.push(messageId);
      }
    });
    
    toDelete.forEach(messageId => {
      this.receivedMessages.delete(messageId);
    });
  }
  
  // Handle peer failure
  handlePeerFailure(peerId) {
    const peerIdStr = this.hyparview.dht.uint8ArrayToHex(peerId);
    this.eagerPushPeers.delete(peerIdStr);
    this.lazyPushPeers.delete(peerIdStr);
  }
  
  // Get statistics
  getStats() {
    return {
      eagerPeers: this.eagerPushPeers.size,
      lazyPeers: this.lazyPushPeers.size,
      messagesInHistory: this.receivedMessages.size,
      missingRequests: this.missing.size,
      metrics: { ...this.metrics }
    };
  }
}




  let maintenanceInterval;
let bonfireUpdateTimeout; 
function startMaintenanceLoop() {
  let tick = 0;
  
  console.log("Starting consolidated maintenance loop");
  
  maintenanceInterval = setInterval(() => {
    tick++;
    
    // Every 5 seconds - Traffic mixing
    if (tick % 5 === 0) {
      trafficMixer.mix();
    }
    
    // Every 10 seconds - Noise generation and age updates
    if (tick % 10 === 0) {
      updateAges();
      noiseGenerator.generateNoise();
    }
    
    // Every 30 seconds - Memory, GC, and state saves
    if (tick % 30 === 0) {
      memoryManager.checkMemory();
      garbageCollect();
      stateManager.savePosts();
      stateManager.saveUserState();
      stateManager.savePeerScores();
    }
    
    // Every 60 seconds - Peer exchange
    if (tick % 60 === 0 && state.hyparview) {
        const activePeers = state.hyparview.getActivePeers();
        if (activePeers.length > 0) {
            const target = activePeers[Math.floor(Math.random() * activePeers.length)];
            
            // Send some known peers
            const knownPeers = Array.from(state.peers.keys())
                .filter(id => typeof id === 'string') // Only string IDs for browser peers
                .slice(0, 10)
                .map(peerId => ({ id: peerId }));
            
            if (knownPeers.length > 0 && target.wire && !target.wire.destroyed) {
                sendPeer(target.wire, {
                    type: 'peer_exchange',
                    peers: knownPeers
                });
            }
        }
    }
    
    // Every 300 seconds (5 minutes) - Bloom filter stats
    if (tick % 300 === 0) {
      const stats = state.seenMessages.getStats();
      console.log("Bloom filter stats:", stats);
    }
    // Every hour - Database cleanup
    if (tick % 3600 === 0) {
      stateManager.cleanup();
      tick = 0; // Reset to prevent overflow
    }
    
  }, 1000); // Run every second
}

class EpidemicGossip {
  constructor() {
    this.messageTTL = new Map(); // Track message hops
    this.maxHops = 6;
  }
  
  selectRandomPeers(count, excludePeers = []) {
    const available = Array.from(state.peers.values())
      .filter(p => !excludePeers.includes(p.wire) && !p.wire.destroyed);
    
    // Fisher-Yates shuffle
    for (let i = available.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [available[i], available[j]] = [available[j], available[i]];
    }
    
    return available.slice(0, count);
  }
  
  sendWithExponentialBackoff(peer, msg, attempt = 0) {
    if (attempt > 3) return;
    
    const delay = Math.min(1000 * Math.pow(2, attempt), 5000);
    setTimeout(() => {
      if (!peer.wire.destroyed && peer.wire.ephemeral_msg?._ready) {
        sendPeer(peer.wire, msg);
      } else if (attempt < 3) {
        this.sendWithExponentialBackoff(peer, msg, attempt + 1);
      }
    }, delay + Math.random() * 100);
  }
}

class ProgressiveVDF extends BitQuillVDF {
  constructor() {
    super();
    this.spamCache = new Map();
    this.userPostTimes = new Map();
  }
  
  calculateDifficulty(content, userId) {
    const now = Date.now();
    let difficulty = 500; // Base difficulty (0.5 seconds)
    
    // Check user's recent posting frequency
    const userTimes = this.userPostTimes.get(userId) || [];
    const recentPosts = userTimes.filter(t => now - t < 3600000); // Last hour
    
    if (recentPosts.length > 10) {
      difficulty *= 4; // Heavy poster penalty
    } else if (recentPosts.length > 5) {
      difficulty *= 2;
    }
    
    // Check for spam patterns
    const contentLower = content.toLowerCase();
    const spamPatterns = [
      /(.)\1{4,}/, // Repeated characters
      /https?:\/\/[^\s]+/g, // Multiple URLs
      /\b(viagra|casino|forex|crypto)\b/i,
    ];
    
    const spamScore = spamPatterns.reduce((score, pattern) => {
      const matches = contentLower.match(pattern);
      return score + (matches ? matches.length : 0);
    }, 0);
    
    if (spamScore > 2) difficulty *= 3;
    
    // Short posts get higher difficulty
    if (content.length < 20) difficulty *= 2;
    
    // Cap difficulty
    return Math.min(difficulty, 10000);
  }
  
  async computeAdaptiveProof(content, userId) {
    const difficulty = this.calculateDifficulty(content, userId);
    
    // Update user post times
    const times = this.userPostTimes.get(userId) || [];
    times.push(Date.now());
    if (times.length > 20) times.shift(); // Keep last 20
    this.userPostTimes.set(userId, times);
    
    console.log(`VDF difficulty for user ${userId}: ${difficulty} iterations`);
    
    // Show appropriate message
    const estimatedTime = Math.round(difficulty / 100); // Rough estimate
    notify(`Computing proof of work... (~${estimatedTime}s)`, estimatedTime * 1000);
    
    return await this.computeVDFProofWithTimeout(
      content + userId + Date.now(),
      difficulty
    );
  }
}

const progressiveVDF = new ProgressiveVDF();
const imageStore = new ContentAddressedImageStore();

const epidemicGossip = new EpidemicGossip();

// Initialize the state manager
const stateManager = new StateManager();


const noiseGenerator = new NoiseGenerator();
const trafficMixer = new TrafficMixer();

const peerManager = new PeerManager();
const vdf = new BitQuillVDF();
const memoryManager = new MemoryManager();
const dandelion = new DandelionRouter();
    /* ---------- CONFIGURATION ---------- */
    const CONFIG = {
      MAX_POSTS: 1000,
      MAX_POST_SIZE: 500,
      MAX_PEERS: 50,
      MAX_MESSAGE_SIZE: 10048,
      RATE_LIMIT_MESSAGES: 300,
      RATE_LIMIT_WINDOW: 10_000,
      GARBAGE_COLLECT_INTERVAL: 30_000,
      CARRIER_UPDATE_INTERVAL: 30_000,
      TOXICITY_THRESHOLD: 0.9,
      LOCAL_MODE: false
    };
    
 class BloomFilter {
  constructor(size = 100000, numHashes = 4) {
    this.size = size;
    this.numHashes = numHashes;
    this.bits = new Uint8Array(Math.ceil(size / 8));
  }
  
  add(item) {
    for (let i = 0; i < this.numHashes; i++) {
      const hash = this.hash(item + i) % this.size;
      const byte = Math.floor(hash / 8);
      const bit = hash % 8;
      this.bits[byte] |= (1 << bit);
    }
  }
  
  has(item) {
    for (let i = 0; i < this.numHashes; i++) {
      const hash = this.hash(item + i) % this.size;
      const byte = Math.floor(hash / 8);
      const bit = hash % 8;
      if ((this.bits[byte] & (1 << bit)) === 0) return false;
    }
    return true;
  }
  
  hash(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      hash = ((hash << 5) - hash) + str.charCodeAt(i);
      hash = hash & hash;
    }
    return Math.abs(hash);
  }
}
    
    class HierarchicalBloomFilter {
  constructor() {
    this.levels = [
      { filter: new BloomFilter(10000, 3), maxAge: 3600000, name: 'recent' },     // 1 hour
      { filter: new BloomFilter(50000, 4), maxAge: 86400000, name: 'daily' },     // 24 hours
      { filter: new BloomFilter(100000, 5), maxAge: 604800000, name: 'weekly' }   // 7 days
    ];
    this.timestamps = new Map();
  }
  
  add(item) {
    const now = Date.now();
    
    // Add to all levels
    this.levels.forEach(level => {
      level.filter.add(item);
    });
    
    // Track timestamp
    this.timestamps.set(item, now);
    
    // Cleanup old timestamps periodically
    if (this.timestamps.size > 10000) {
      this.cleanup();
    }
  }
  
  has(item) {
    const timestamp = this.timestamps.get(item);
    if (!timestamp) return false;
    
    const age = Date.now() - timestamp;
    
    // Check appropriate level based on age
    for (const level of this.levels) {
      if (age <= level.maxAge) {
        return level.filter.has(item);
      }
    }
    
    return false;
  }
  
cleanup() {
  const now = Date.now();
  const maxAge = this.levels[this.levels.length - 1].maxAge;
  
  // Count items before cleanup
  const beforeSize = this.timestamps.size;
  
  // Remove old timestamps
  for (const [item, timestamp] of this.timestamps) {
    if (now - timestamp > maxAge) {
      this.timestamps.delete(item);
    }
  }
  
  // If we removed more than 50% of items, reset bloom filters
  if (this.timestamps.size < beforeSize / 2) {
    console.log(`Resetting bloom filters (cleaned ${beforeSize - this.timestamps.size} items)`);
    this.levels.forEach(level => {
      level.filter = new BloomFilter(
        level.filter.size, 
        level.filter.numHashes
      );
    });
  }
}

  
  reset() {
    this.levels.forEach(level => {
      level.filter = new BloomFilter(
        level.filter.size, 
        level.filter.numHashes
      );
    });
    this.timestamps.clear();
  }
  
  getStats() {
    return {
      totalItems: this.timestamps.size,
      levels: this.levels.map(level => ({
        name: level.name,
        size: level.filter.bits.length * 8,
        maxAge: level.maxAge
      }))
    };
  }
}
    
    const urlParams = new URLSearchParams(location.search);
    if (urlParams.get("local") === "true") CONFIG.LOCAL_MODE = true;

    /* ---------- UTILITIES ---------- */
    const wait = ms => new Promise(r => setTimeout(r, ms));
    async function waitForWebTorrent() {
      if (CONFIG.LOCAL_MODE) return;
      const t0 = performance.now();
      while (typeof WebTorrent === "undefined") {
        if (performance.now() - t0 > 10_000) throw new Error("WebTorrent failed to load in 10 s");
        await wait(100);
      }
    }
    const generateId = () => Math.random().toString(36).substr(2, 9);
function sanitize(content) {
  // 1 ¬∑ Trim early
  if (content.length > CONFIG.MAX_POST_SIZE) {
    content = content.slice(0, CONFIG.MAX_POST_SIZE);
  }

  // 2 ¬∑ Use DOMPurify when available
  if (window.DOMPurify) {
    const purified = DOMPurify.sanitize(content, {
      ALLOWED_TAGS: [ 'b', 'i', 'em', 'strong', 'a', 'code', 'br' ],
      ALLOWED_ATTR: [ 'href', 'target', 'rel' ],   // ‚Üê array form
      ALLOW_URI_WITHOUT_PROTOCOL: true,            // allow ‚Äúexample.com‚Äù
      RETURN_TRUSTED_TYPE: false
    });

    // 3 ¬∑ Optional: force safe link behaviour
    DOMPurify.addHook('afterSanitizeAttributes', node => {
      if (node.tagName === 'A' && node.hasAttribute('href')) {
        node.setAttribute('target', '_blank');
        node.setAttribute('rel',   'noopener noreferrer');
      }
    });

    return purified;
  }

  // 4 ¬∑ Fallback: plain-text escape
  const d = document.createElement('div');
  d.textContent = content;
  return d.innerHTML;
}
    function timeAgo(ts) {
      const s = ~~((Date.now() - ts) / 1000);
      if (s < 5) return "just now";
      if (s < 60) return `${s}s ago`;
      const m = ~~(s / 60);
      if (m < 60) return `${m}m ago`;
      const h = ~~(m / 60);
      if (h < 24) return `${h}h ago`;
      return `${~~(h / 24)}d ago`;
    }
    function notify(msg, dur = 3000) {
      const n = document.createElement("div");
      n.className = "notification";
      n.textContent = msg;
      document.body.appendChild(n);
      setTimeout(() => {
        n.style.animationDirection = "reverse";
        setTimeout(() => n.remove(), 300);
      }, dur);
    }

/* ---------- GLOBAL STATE ---------- */
const state = {
  posts: new Map(),
  peers: new Map(),
  myIdentity: null,
  client: null,
  explicitlyCarrying: new Set(),
  viewing: new Set(),
  toxicityClassifier: null,
  seenMessages: new HierarchicalBloomFilter(),
  seenPosts: new HierarchicalBloomFilter(),
  // Add protocol instances
  dht: null,
  hyparview: null,
  scribe: null,
  plumtree: null,
  subscribedTopics:  new Set(['#general', '#ember']),
  topicFilter : '',
  feedMode : 'all',
};

/* ---------- IDENTITY ---------- */
async function initIdentity() {
  const stored = localStorage.getItem("ephemeral-id");
  if (stored) {
    try {
      const identity = JSON.parse(stored);
      // **NEW**: Convert the stored secret key back to a Uint8Array
      if (identity.secretKey) {
          // If it's an array (from JSON.parse), directly map it.
          // If it somehow became a string, try splitting it as a fallback (though it shouldn't be).
          if (Array.isArray(identity.secretKey)) {
              identity.secretKey = new Uint8Array(identity.secretKey);
          } else if (typeof identity.secretKey === 'string') {
              // This path is for compatibility if a string was *somehow* stored.
              // In your current saving logic, it should always be an array.
              identity.secretKey = new Uint8Array(identity.secretKey.split(',').map(Number));
          } else {
              console.warn("Unexpected type for identity.secretKey during load:", typeof identity.secretKey);
              identity.secretKey = null; // Or handle as an invalid state
          }
      }
      // **NEW**: Convert the public key from base64 back to Uint8Array
      if (identity.publicKey) {
          identity.publicKey = base64ToArrayBuffer(identity.publicKey);
      }

      // Integrity check for the new identity format
      if (identity.publicKey && identity.secretKey && identity.handle) {
        state.myIdentity = identity;
        return;
      }
    } catch (e) {
      console.error("Failed to load identity, creating a new one.", e);
    }
  }


  // --- New VDF-based Identity Creation Flow ---
  // We wrap the interactive part in a promise so the main app startup will wait for it to complete.
  return new Promise(resolve => {
    // Get all the DOM elements for the modal
    const overlay = document.getElementById('identity-creation-overlay');
    const step0 = document.getElementById('identity-step-0-disclaimer');
    const acknowledgeButton = document.getElementById('acknowledge-button');
    const step1 = document.getElementById('identity-step-1-calibrate');
    const step2 = document.getElementById('identity-step-2-pow');
    const step3 = document.getElementById('identity-step-3-prompt');
    const statusText = document.getElementById('identity-status-text');

    // This function now holds all the logic for steps 1, 2, and 3
    async function startVdfProcess() {
      // --- Show Step 1: Calibration ---
      step1.style.display = 'block';
      const vdf = new BitQuillVDF();
      const calibrationDurationMs = 2000;
      const targetDurationSec = 30;
      statusText.innerHTML = `<strong>Step 1/2:</strong> Calibrating network difficulty...`;

      async function calibrateVdf(vdfInstance, durationMs) {
        let iterations = 0;
        const startTime = performance.now();
        let x = vdfInstance.hexToBigInt("C7970CEEDCC3B0754490201A7AA613CD73911081");
        while (performance.now() - startTime < durationMs) {
          for (let i = 0; i < 100; i++) {
            x = (x * x) % vdfInstance.modulus;
            iterations++;
          }
          await new Promise(r => setTimeout(r, 0));
        }
        return iterations / (durationMs / 1000);
      }

      const iterationsPerSecond = await calibrateVdf(vdf, calibrationDurationMs);
      const targetIterations = Math.floor(iterationsPerSecond * targetDurationSec);

      // --- Show Step 2: Proof-of-Work ---
      step1.style.display = 'none';
      step2.innerHTML = `
        <div id="identity-status-text-2"></div>
        <progress id="identity-progress-bar" value="0" max="100"></progress>
        <div id="identity-progress-percent">0%</div>
      `;
      // We query for these elements now because we just created them.
      const statusText2 = document.getElementById('identity-status-text-2');
      const progressBar = document.getElementById('identity-progress-bar');
      const progressPercent = document.getElementById('identity-progress-percent');
      
      statusText2.innerHTML = `<strong>Step 2/2:</strong> Generating your unique proof-of-work.<br/>This will take approximately ${targetDurationSec} seconds.`;
      step2.style.display = 'block';

      vdf.setProgressCallback((progress) => {
        const percent = Math.round(progress);
        progressBar.value = percent;
        progressPercent.textContent = `${percent}%`;
      });

   // Generate the unique ID *before* the proof is created.
    const uniqueId = Math.random().toString(36).substr(2, 8);
    const vdfInput = "ephemeral-identity-creation-" + uniqueId;
    
    const proof = await vdf.computeVDFProofWithTimeout(vdfInput, targetIterations);


      // --- Show Step 3: Finalize ---
      step2.style.display = 'none';
      step3.innerHTML = `
        <p>Proof-of-work complete! Please choose your handle.</p>
        <input type="text" id="identity-handle-input" placeholder="e.g., anon_user" />
        <button id="identity-confirm-button" class="primary-button">Create Identity</button>
      `;
      step3.style.display = 'block';
      
      const handleInput = document.getElementById('identity-handle-input');
      const confirmButton = document.getElementById('identity-confirm-button');

      const finalize = async () => {
          const handle = handleInput.value.trim() || "anon";

      // When creating new identity:
      const keyPair = nacl.sign.keyPair();
      
      // Generate node ID from public key (SHA-1 hash)
      const publicKeyData = new TextEncoder().encode(arrayBufferToBase64(keyPair.publicKey));
        const hashBuffer = await crypto.subtle.digest('SHA-1', keyPair.publicKey); 
        const nodeId = new Uint8Array(hashBuffer);
      
      state.myIdentity = {
        handle: handle,
        publicKey: keyPair.publicKey,
        secretKey: keyPair.secretKey,
        vdfProof: proof,
        vdfInput: vdfInput,
        uniqueId: uniqueId,
        nodeId: nodeId // Add this!
      };

          // **NEW**: Convert binary keys for JSON serialization
        const serializableIdentity = {
            ...state.myIdentity,
            publicKey: arrayBufferToBase64(keyPair.publicKey),
            secretKey: Array.from(keyPair.secretKey),
            vdfProof: proof, // proof itself is already serializable, no need to re-assign
            vdfInput: vdfInput // <-- Add this here as well
        };

          localStorage.setItem("ephemeral-id", JSON.stringify(serializableIdentity));
          overlay.style.display = 'none';
          resolve();
      };

      confirmButton.onclick = finalize;
      handleInput.onkeydown = (e) => {
        if (e.key === 'Enter') finalize();
      };
    }

    // Add the click listener for the acknowledgment button
    acknowledgeButton.onclick = () => {
      step0.style.display = 'none'; // Hide the disclaimer
      startVdfProcess();            // Begin the actual VDF process
    };

    // Finally, show the overlay to start the whole flow.
    overlay.style.display = 'flex';
  });
}


// Topic subscription management
async function subscribeToTopic() {
  const input = document.getElementById('topic-input');
  let topic = input.value.trim().toLowerCase();

  if (!topic) return;

  if (!topic.startsWith('#')) {
    topic = '#' + topic;
  }

  if (!/^#\w+$/.test(topic)) {
    notify('Invalid topic format. Use #alphanumeric');
    return;
  }

  if (state.subscribedTopics.has(topic)) {
    notify('Already subscribed to ' + topic);
    return;
  }

  // --- FIX: UI and State updates now happen immediately ---
  // 1. Add to the local state.
  state.subscribedTopics.add(topic);
  
  // 2. Update the UI components.
  addTopicToUI(topic);
  updateTopicFilter();
  
  // 3. Persist the change and clear the input.
  saveTopicSubscriptions();
  input.value = '';
  notify(`Subscribed to ${topic}`);

  // --- Network action happens when possible ---
  // 4. Tell the P2P network to join the topic.
  if (state.scribe) {
    await state.scribe.subscribe(topic);
  } else {
    // This warning is for developers; the user experience is already handled.
    console.warn("Scribe not ready, but UI has been updated. Network will join topic upon initialization.");
  }
}

function addTopicToUI(topic) {
  const container = document.getElementById('subscribed-topics');
  const existing = container.querySelector(`[data-topic="${topic}"]`);
  if (existing) return;
  
  const tag = document.createElement('div');
  tag.className = 'topic-tag active';
  tag.dataset.topic = topic;
  tag.textContent = topic;
  tag.onclick = () => toggleTopic(topic);
  
  container.appendChild(tag);
}

async function toggleTopic(topic) {
  const tag = document.querySelector(`[data-topic="${topic}"]`);
  
  if (state.subscribedTopics.has(topic)) {
    // Don't allow unsubscribing from #general
    if (topic === '#general') {
      notify("Cannot unsubscribe from #general");
      return;
    }
    
    // Unsubscribe
    if (state.scribe) {
      state.scribe.unsubscribe(topic);
    }
    state.subscribedTopics.delete(topic);
    tag.classList.remove('active');
    
    notify(`Unsubscribed from ${topic}`);
  } else {
    // Resubscribe
    if (state.scribe) {
      await state.scribe.subscribe(topic);
    }
    state.subscribedTopics.add(topic);
    tag.classList.add('active');
    
    notify(`Resubscribed to ${topic}`);
  }
  
  updateTopicFilter();
  saveTopicSubscriptions();
  applyTopicFilter();
}

function updateTopicFilter() {
  const select = document.getElementById('topic-filter');
  const currentValue = select.value;
  
  // Clear and rebuild options
  select.innerHTML = '<option value="">All Topics</option>';
  
  state.subscribedTopics.forEach(topic => {
    const option = document.createElement('option');
    option.value = topic;
    option.textContent = topic;
    select.appendChild(option);
  });
  
  // Restore previous selection if still valid
  if (currentValue && state.subscribedTopics.has(currentValue)) {
    select.value = currentValue;
  }
}

function filterByTopic() {
  const select = document.getElementById('topic-filter');
  state.topicFilter = select.value;
  applyTopicFilter();
}

function setFeedMode(mode) {
  state.feedMode = mode;
  
  // Update button states
  document.querySelectorAll('.mode-button').forEach(btn => {
    btn.classList.remove('active');
  });
  event.target.classList.add('active');
  
  applyTopicFilter();
}

function applyTopicFilter() {
  const posts = document.querySelectorAll('.post');
  let visibleCount = 0;
  
  // Get the values from the state
  const currentFeedMode = state.feedMode;
  const topicDropdownFilter = state.topicFilter;

  posts.forEach(postEl => {
    const postId = postEl.id.replace('post-', '');
    const post = state.posts.get(postId);
    if (!post) return;

    const postTopics = state.scribe ? state.scribe.extractTopics(post.content) : [];
    let isVisible = false; // Start by assuming the post is hidden

    // Step 1: Determine base visibility from the "All Posts" / "My Topics" buttons
    if (currentFeedMode === 'all') {
      // In 'all' mode, every post is a potential candidate to be shown.
      isVisible = true;
    } else { // feedMode is 'topics'
      // In 'topics' mode, only posts that have at least one of our subscribed topics are candidates.
      isVisible = postTopics.some(topic => state.subscribedTopics.has(topic));
    }

    // Step 2: If the post is still a candidate, apply the secondary dropdown filter.
    // This will only run if a specific topic is selected in the dropdown.
    if (isVisible && topicDropdownFilter) {
      isVisible = postTopics.includes(topicDropdownFilter);
    }

    // Step 3: Set the final visibility
    postEl.style.display = isVisible ? 'block' : 'none';
    if (isVisible) {
      visibleCount++;
    }
  });
  
  // This part for showing the "empty state" message remains the same and is still correct.
  let emptyMessage = document.getElementById('filter-empty-message');
  if (visibleCount === 0 && (currentFeedMode === 'topics' || topicDropdownFilter)) {
    if (!emptyMessage) {
        emptyMessage = document.createElement('div');
        emptyMessage.id = 'filter-empty-message';
        emptyMessage.className = 'empty-state';
        document.getElementById('posts').appendChild(emptyMessage);
    }
    emptyMessage.textContent = topicDropdownFilter ? 
      `No posts in ${topicDropdownFilter}` : 
      'No posts in your subscribed topics';
  } else if (emptyMessage) {
    emptyMessage.remove();
  }
}

function discoverAndFilterTopic(topic) {
  // First, check if the user is already subscribed.
  if (!state.subscribedTopics.has(topic)) {
    // If not, perform the subscription steps.
    console.log(`[Topics] User clicked to subscribe to new topic: ${topic}`);
    
    state.subscribedTopics.add(topic);
    if (state.scribe) {
      state.scribe.subscribe(topic);
    }
    addTopicToUI(topic);
    updateTopicFilter();
    saveTopicSubscriptions();
    notify(`Subscribed to ${topic}`); // Let the user know what happened.
  }
  
  // Now, perform the filtering action regardless of whether it was a new subscription.
  filterToTopic(topic);
}

function filterToTopic(topic) {
  document.getElementById('topic-filter').value = topic;
  state.topicFilter = topic;
  applyTopicFilter();
}

// Save/load topic subscriptions
function saveTopicSubscriptions() {
  localStorage.setItem('ember-topics', JSON.stringify(Array.from(state.subscribedTopics)));
}

function loadTopicSubscriptions() {
  const saved = localStorage.getItem('ember-topics');
  if (saved) {
    try {
      const topics = JSON.parse(saved);
      topics.forEach(topic => {
        state.subscribedTopics.add(topic);
        addTopicToUI(topic);
      });
    } catch (e) {
      console.error('Failed to load saved topics:', e);
    }
  }
}

// Update topic statistics periodically
function updateTopicStats() {
  if (!state.scribe) return;
  
  const stats = state.scribe.getStats();
  const statsEl = document.getElementById('topic-stats');
  
  if (stats.topics.length > 0) {
    const topicDetails = stats.topics.map(t => 
      `${t.topic}: ${t.children} children${t.hasParent ? ' (connected)' : ' (root)'}`
    ).join('<br>');
    
    statsEl.innerHTML = `
      <div>Connected to ${stats.subscribedTopics} topic trees</div>
      <div style="font-size: 11px; margin-top: 4px;">${topicDetails}</div>
    `;
  }
}


    /* ---------- TOXICITY FILTER ---------- */
    async function initContentFilter() {
      try {
        state.toxicityClassifier = await toxicity.load(CONFIG.TOXICITY_THRESHOLD);
        console.log("Toxicity model ready");
      } catch (e) {
        console.error("Toxicity model failed:", e);
      }
    }
    async function isToxic(text) {
      if (!state.toxicityClassifier) return false;
      try {
        const preds = await state.toxicityClassifier.classify([text]);
        for (const p of preds) if (p.results[0].match) return p.label;
        return false;
      } catch (e) {
        console.error("toxicity check failed:", e);
        return false;
      }
    }
    
    /*NSFW Image Filter*/
    async function initImageFilter() {
      try {
        state.imageClassifier = await nsfwjs.load('nsfwjs-model/'); 




        console.log("Image filter model ready");
      } catch (e) {
        console.error("Image filter failed to load:", e);
      }
    }

    async function isImageToxic(imageData) {
      if (!state.imageClassifier) return false;
      
      try {
        const img = new Image();
        img.src = imageData;
        await new Promise((resolve) => img.onload = resolve);
        
        const predictions = await state.imageClassifier.classify(img);
        
        const problematic = predictions.find(p => {
          if (p.className === 'Porn' && p.probability > 0.7) return true;
          if (p.className === 'Hentai' && p.probability > 0.7) return true;
          if (p.className === 'Sexy' && p.probability > 0.8) return true;
          return false;
        });
        
        return problematic ? problematic.className : false;
      } catch (e) {
        console.error("Image classification failed:", e);
        return false;
      }
    }

// Initialize topics on startup
async function initTopics() {
  loadTopicSubscriptions();
  updateTopicFilter();
  
  // Subscribe to saved topics via Scribe
  if (state.scribe) {
    for (const topic of state.subscribedTopics) {
      await state.scribe.subscribe(topic);
    }
  }
  
  // Update stats periodically
  setInterval(updateTopicStats, 5000);
}



/* ---------- UTILITY HELPERS ---------- */
// It's useful to have these available globally.
// Since they are already in your VDF class, you can move them out
// or just call them from the vdf instance, e.g., vdf.arrayBufferToBase64().
const arrayBufferToBase64 = (buffer) => {
    const binary = String.fromCharCode(...new Uint8Array(buffer));
    return btoa(binary);
};

const base64ToArrayBuffer = (base64) => {
    const binary = atob(base64);
    const bytes = new Uint8Array(binary.length);
    for (let i = 0; i < binary.length; i++) {
        bytes[i] = binary.charCodeAt(i);
    }
    return bytes;
};


/* ---------- POST CLASS WITH SIGNATURES ---------- */
/* ---------- POST CLASS WITH SIGNATURES ---------- */
class Post {
    constructor(content, parentId = null, imageData = null) {
        // Core post data
        this.id = generateId();
        this.content = sanitize(content);
        this.timestamp = Date.now();
        this.parentId = parentId;
        this.imageData = imageData; // Temporary storage for base64 before processing
        this.imageHash = null; // Will be populated by processImage()

        // Author's identity information
        this.author = state.myIdentity.handle;
        this.authorPublicKey = state.myIdentity.publicKey;
        this.authorUniqueId = state.myIdentity.uniqueId;
        this.authorVdfProof = state.myIdentity.vdfProof;
        this.authorVdfInput = state.myIdentity.vdfInput;

        this.signature = null;

        // Ephemeral state
        this.carriers = new Set([state.myIdentity.handle]);
        this.replies = new Set();
        this.depth = 0;
    }

    async processImage() {
        if (this.imageData && !this.imageHash) {
            const result = await imageStore.storeImage(this.imageData);
            this.imageHash = result.hash;
            // The Merkle root is part of imageStore.images.get(this.imageHash).merkleRoot
            this.imageData = null; // Clear raw data after processing
            console.log(`[Post] Image processed, hash: ${this.imageHash?.substring(0, 8)}...`);
        }
    }

    /**
     * Creates a consistent, stringified version of the post data for signing.
     * Includes imageHash for content integrity.
     * @returns {Uint8Array} - The byte array to be signed or verified.
     */
toSignable() {
  // Ensure publicKey is always converted to base64 string for consistent signing
  let publicKeyBase64;
  if (typeof this.authorPublicKey === 'string') {
    publicKeyBase64 = this.authorPublicKey;
  } else {
    publicKeyBase64 = arrayBufferToBase64(this.authorPublicKey);
  }
  
  const signableData = {
    id: this.id,
    content: this.content,
    timestamp: this.timestamp,
    parentId: this.parentId,
    imageHash: this.imageHash,
    authorPublicKey: publicKeyBase64
  };
  
  const signedString = JSON.stringify(signableData);
  console.log(`[Post] Data being signed: ${signedString}`);
  return new TextEncoder().encode(signedString);
}

    /**
     * Signs the post using the user's private key.
     * @param {Uint8Array} secretKey - The user's secret signing key.
     */
    sign(secretKey) {
        const messageBytes = this.toSignable();
        this.signature = nacl.sign(messageBytes, secretKey);
        console.log(`[Post] Post signed. Signature: ${arrayBufferToBase64(this.signature).substring(0, 16)}...`);
    }

    /**
     * Verifies the post's signature.
     * @returns {boolean} - True if the signature is valid, false otherwise.
     */
    verify() {
        if (!this.signature || !this.authorPublicKey) {
            console.warn("[Post] Verification failed: Post is missing signature or public key.");
            return false;
        }

        const messageToVerifyBytes = this.toSignable(); // Re-create signable data
        const originalMessage = nacl.sign.open(this.signature, this.authorPublicKey);

        if (originalMessage === null) {
            console.warn("[Post] Verification failed: nacl.sign.open returned null (invalid signature).");
            return false;
        }

        const decodedOriginal = new TextDecoder().decode(originalMessage);
        const decodedSignable = new TextDecoder().decode(messageToVerifyBytes);

        if (decodedOriginal !== decodedSignable) {
            console.error("[Post] Verification failed: Re-decoded message from signature does NOT match re-created signable data!");
            console.error("  Original from signature:", decodedOriginal);
            console.error("  Re-created signable data:", decodedSignable);
            return false;
        }
        
        console.log("[Post] Signature successfully verified.");
        return true;
    }

    /**
     * Prepares the entire Post object for network transmission.
     * Converts Uint8Array fields to Base64 strings for reliable JSON transport.
     * @returns {object} - A JSON-serializable object.
     */
    toJSON() {
        return {
            id: this.id,
            content: this.content,
            timestamp: this.timestamp,
            parentId: this.parentId,
            imageHash: this.imageHash,
            // Include ALL image metadata (hash, chunks list, merkleRoot)
            imageMeta: this.imageHash ? imageStore.images.get(this.imageHash) : null,
            author: this.author,
            authorPublicKey: arrayBufferToBase64(this.authorPublicKey),
            authorUniqueId: this.authorUniqueId,
            authorVdfProof: this.authorVdfProof,
            authorVdfInput: this.authorVdfInput,
            signature: this.signature ? arrayBufferToBase64(this.signature) : null,
            carriers: [...this.carriers],
            replies: [...this.replies],
            depth: this.depth
        };
    }

    /**
     * Reconstructs a Post object from incoming network data.
     * Converts Base64 string fields back into Uint8Arrays.
     * @param {object} j - The raw object from a JSON payload.
     * @returns {Post} - A complete Post instance.
     */
static fromJSON(j) {
    const p = Object.create(Post.prototype);
    
    // Copy all basic properties
    p.id = j.id;
    p.content = j.content;
    p.timestamp = j.timestamp;
    p.parentId = j.parentId;
    p.imageHash = j.imageHash;
    p.imageData = j.imageData; // Will usually be null for received posts, populated by render if image arrives
    p.author = j.author;
    p.authorUniqueId = j.authorUniqueId;
    p.authorVdfProof = j.authorVdfProof;
    p.authorVdfInput = j.authorVdfInput;
    p.depth = j.depth || 0;

    // Store image metadata if available and we don't have it already
    if (j.imageMeta && j.imageHash) {
        if (!imageStore.images.has(j.imageHash)) {
            imageStore.images.set(j.imageHash, j.imageMeta);
            console.log(`[Post.fromJSON] Stored image metadata for ${j.imageHash.substring(0, 8)}... (from incoming post)`);
        } else {
            console.log(`[Post.fromJSON] Image metadata for ${j.imageHash.substring(0, 8)}... already exists locally.`);
        }
    }

    // Handle public key conversion (with Buffer support)
    if (typeof j.authorPublicKey === 'string') {
        p.authorPublicKey = base64ToArrayBuffer(j.authorPublicKey);
    } else if (j.authorPublicKey && (j.authorPublicKey.type === 'Buffer' || j.authorPublicKey.data)) {
        // Handle Buffer objects from Node.js
        p.authorPublicKey = new Uint8Array(j.authorPublicKey.data || j.authorPublicKey);
    } else if (j.authorPublicKey instanceof Uint8Array) {
        p.authorPublicKey = j.authorPublicKey;
    }
    
    // Handle signature conversion (with Buffer support)
    if (typeof j.signature === 'string') {
        p.signature = base64ToArrayBuffer(j.signature);
    } else if (j.signature && (j.signature.type === 'Buffer' || j.signature.data)) {
        // Handle Buffer objects from Node.js
        p.signature = new Uint8Array(j.signature.data || j.signature);
    } else if (j.signature instanceof Uint8Array) {
        p.signature = j.signature;
    } else {
        p.signature = null;
    }
    
    // Convert arrays back to Sets
    p.carriers = new Set(j.carriers || []);
    p.replies = new Set(j.replies || []);
    
    console.log('[Post.fromJSON] Reconstructed post:', {
        id: p.id,
        author: p.author,
        hasPublicKey: !!p.authorPublicKey,
        hasSignature: !!p.signature,
        publicKeyType: p.authorPublicKey?.constructor?.name,
        signatureType: p.signature?.constructor?.name
    });
    
    return p;
}
}


   function hexToUint8Array (hex) {
  if (hex.length % 2) throw new Error('hex length must be even');
  const bytes = new Uint8Array(hex.length / 2);
  for (let i = 0; i < bytes.length; i++) {
    bytes[i] = parseInt(hex.substr(i * 2, 2), 16);
  }
  return bytes;
}

    
function handleBootstrapWire(wire, addr) {
  const id = wire.peerId;
  if (state.peers.has(id)) return;
  
  console.log(`Bootstrap peer connected: ${id.toString('hex').substring(0, 12)}...`);
  
  // Handle both Buffer (from Node.js) and string peer IDs
  let peerId;
  if (typeof wire.peerId === 'string') {
    peerId = hexToUint8Array(wire.peerId);
  } else if (wire.peerId instanceof Uint8Array) {
    peerId = wire.peerId;
  } else if (wire.peerId && (wire.peerId.type === 'Buffer' || wire.peerId.data)) {
    // Handle Buffer objects from Node.js
    peerId = new Uint8Array(wire.peerId.data || wire.peerId);
  } else {
    peerId = wire.peerId;
  }
  
  wire.peerId = peerId; // Normalize it
  
  const peerData = { 
    wire, 
    addr,
    id: peerId, // Use the normalized peerId
    messageTimestamps: [],
    shardIndex: 'bootstrap',
    connectedAt: Date.now(),
    bytesReceived: 0,
    bytesSent: 0
  };

  state.peers.set(peerId, peerData); // Use peerId as key
  
  // Add to DHT with proper ID handling
  if (state.dht) {
    state.dht.addPeer(peerId, peerData);
  }
  
  
  // Add to HyParView if room
  if (state.hyparview && state.hyparview.activeView.size < state.hyparview.activeViewSize) {
    state.hyparview.addToActiveView(id, { wire, isOutgoing: false });
  }
  
  attachEphemeralExtension(wire);
  
  wire.on('close', () => {
    console.log(`Bootstrap peer disconnected: ${id.toString('hex').substring(0, 12)}...`);
    state.peers.delete(id);
    
    if (state.dht) state.dht.removePeer(id);
    if (state.hyparview) state.hyparview.handlePeerFailure(id);
    
    updateStatus();
  });
  
  wire.on('error', err => console.error(`Bootstrap wire error:`, err.message));
}


    /* ---------- WEBTORRENT NETWORKING ---------- */
function initNetwork() {
  updateConnectionStatus("Initializing WebTorrent...");
  
  const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
  console.log("Initializing network... iOS:", isIOS);
  
  // Check WebRTC support
  if (!window.RTCPeerConnection) {
    console.error("WebRTC not supported!");
    updateConnectionStatus("WebRTC not supported on this device", 'error');
    notify("WebRTC not supported on this device");
    return;
  }
  
  updateConnectionStatus("Setting up peer connections...");
  
  const trackers = [
    'wss://tracker.openwebtorrent.com',
    'wss://tracker.webtorrent.dev',
    'wss://tracker.btorrent.xyz',
    'wss://tracker.files.fm:7073/announce',
    'wss://spacetradersapi-chatbox.herokuapp.com:443/announce'
  ];
  
  // Store trackers for later use
  state.trackers = trackers;
  
  try {
    state.client = new WebTorrent({
      dht: !isIOS, // Disable DHT on iOS
      maxConns: isIOS ? 20 : 100,
      tracker: {
        announce: trackers,
        rtcConfig: {
          iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:stun1.l.google.com:19302' }
          ]
        }
      },
      trickle: true
    });
    
    // Initialize protocols
    state.dht = new KademliaDHT(state.myIdentity.nodeId);
    state.hyparview = new HyParView(state.myIdentity.nodeId, state.dht);
    
    updateConnectionStatus("Joining DHT bootstrap network...");
    
    // CRITICAL: Join the same bootstrap torrent as headless nodes!
    const bootstrapData = new Blob(['Ember-DHT-Bootstrap-v1'], { type: 'text/plain' });
    state.client.seed(bootstrapData, { 
      name: 'ember-bootstrap.txt',
      announce: state.trackers || []
    }, torrent => {
      console.log(`Connected to bootstrap network: ${torrent.infoHash}`);
      updateConnectionStatus("Connected to Ember bootstrap network!");
      
      torrent.on('wire', (wire, addr) => {
        // Use a special handler for bootstrap connections
        handleBootstrapWire(wire, addr);
      });
    });
    

    
    // Bootstrap protocols after network is ready
    setTimeout(async () => {
      // Initialize Scribe after HyParView
      state.scribe = new Scribe(state.myIdentity.nodeId, state.dht);
      await state.scribe.subscribe('#general');
      await state.scribe.subscribe('#ember');
      
      // Initialize Plumtree
      state.plumtree = new Plumtree(state.myIdentity.nodeId, state.hyparview);
      state.plumtree.deliver = (message) => {
        if (message.type === 'post') {
          handleNewPost(message.data, null);
        }
      };
    state.scribe.deliverMessage = (topic, message) => {
          console.log(`[Scribe] Message on ${topic}:`, message);
          if (message.type === 'new_post' && message.post) {
              handleNewPost(message.post, null);
          }
      };

      console.log("P2P protocols initialized");
    }, 3000);
    
  } catch (e) {
    console.error("Failed to create WebTorrent client:", e);
    updateConnectionStatus(`Failed to initialize: ${e.message}`, 'error');
    throw e;
  }

  // Set up event handlers
  state.client.on("error", e => {
    console.error("Client error:", e.message);
    updateConnectionStatus(`Network error: ${e.message}`, 'error');
    if (!/Connection error|WebSocket/.test(e.message)) {
      notify("Network error: " + e.message);
    }
  });
  
  state.client.on('warning', (err) => {
    console.warn('WebTorrent warning:', err);
  });

   updateConnectionStatus("Network ready - using unified bootstrap");

 
  // Set up periodic status check
  let lastPeerCount = 0;
  const statusCheckInterval = setInterval(() => {
    const currentPeerCount = state.peers.size;
    
    if (currentPeerCount !== lastPeerCount) {
      console.log(`Peer count changed: ${lastPeerCount} ‚Üí ${currentPeerCount}`);
      
      if (currentPeerCount > 0 && lastPeerCount === 0) {
        updateConnectionStatus(`Connected! ${currentPeerCount} peer${currentPeerCount > 1 ? 's' : ''}`, 'success');
        // Clear the interval after successful connection
        setTimeout(() => clearInterval(statusCheckInterval), 3000);
      } else if (currentPeerCount > lastPeerCount) {
        updateConnectionStatus(`${currentPeerCount} peers connected`, 'success');
      }
      
      lastPeerCount = currentPeerCount;
    }
    
    // If still no peers after 10 seconds, show helpful message
    if (state.peers.size === 0 && document.getElementById("loading").style.display !== "none") {
      const timeSinceStart = Date.now() - (window.networkStartTime || Date.now());
      if (timeSinceStart > 10000) {
        updateConnectionStatus("Still searching for peers... This may take a moment if the network is quiet.", 'info');
      }
    }
  }, 1000);
  
  // Track when we started
  window.networkStartTime = Date.now();
  
  // Log initial state
console.log("Network initialization complete", {
  client: !!state.client,
  trackers: trackers.length
});
}

// Helper function to update connection status
function updateConnectionStatus(message, type = 'info') {
  console.log(`[Status] ${message}`);
  
  const loadingEl = document.getElementById("loading");
  if (!loadingEl || loadingEl.style.display === "none") return;
  
  const statusDiv = loadingEl.querySelector('div:last-child') || 
                   loadingEl.querySelector('.loading-content').lastElementChild;
  
  if (statusDiv) {
    const color = type === 'error' ? '#ff4444' : 
                  type === 'success' ? '#44ff44' : 
                  '#ff8c42';
    
    statusDiv.innerHTML = `<div style="font-size:12px;margin-top:10px;color:${color}">${message}</div>`;
    
    // For success messages, add a nice animation
    if (type === 'success') {
      statusDiv.style.animation = 'pulse 1s ease-in-out';
    }
  }
}

// Handle new wire connections with status updates
function handleWire(wire, addr) {
  const id = wire.peerId;
  if (state.peers.has(id)) return;
  
  // Update connection status if this is one of the first peers
  if (state.peers.size < 3) {
    updateConnectionStatus(`Connected to peer ${state.peers.size + 1}!`, 'success');
  }
  
  console.log(`New peer connection: ${id}`);
  
  const peerData = { 
    wire, 
    addr,
    id: id, 
    messageTimestamps: [], 
    connectedAt: Date.now(),
    bytesReceived: 0,
    bytesSent: 0
  };
  
  state.peers.set(id, peerData);
  
  // Add to DHT
  if (state.dht) {
    state.dht.addPeer(id, peerData);
  }
  
  // Add to HyParView if room
  if (state.hyparview && state.hyparview.activeView.size < state.hyparview.activeViewSize) {
    state.hyparview.addToActiveView(id, { wire, isOutgoing: false });
  }
  state.peers.set(id, peerData);
  peerManager.updateScore(id, 'connection', 1);
  updateStatus();
  
  // Monitor connection quality
  wire.on('download', (bytes) => {
    peerData.bytesReceived += bytes;
    peerManager.updateScore(id, 'data', bytes / 1000);
  });
  
  wire.on('upload', (bytes) => {
    peerData.bytesSent += bytes;
  });
  
  attachEphemeralExtension(wire);
  
  // Stagger initial requests
  const delay = Math.random() * 10000; // 0-10 seconds
  setTimeout(() => {
    if (!wire.destroyed) {
      sendPeer(wire, { type: 'request_posts' });
    }
  }, delay);

  wire.on('close', () => {
    console.log(`Disconnected from peer: ${id}`);
    state.peers.delete(id);
    
    // Notify protocols
    if (state.dht) state.dht.removePeer(id);
    if (state.hyparview) state.hyparview.handlePeerFailure(id);
    
    updateStatus();
  });
  
  wire.on('error', err => console.error(`Wire error ${id}:`, err.message));
};



const sendPeer = (wire, msg) => {
  if (!wire || wire.destroyed) return;
  
  try {
    const encoder = new TextEncoder();
    const data = encoder.encode(JSON.stringify(msg));
    
    if (wire.ephemeral_msg && wire.ephemeral_msg._ready && wire.ephemeral_msg.peerId !== undefined) {
      wire.extended(wire.ephemeral_msg.peerId, data);
    } else if (wire.extendedMapping && wire.extendedMapping.ephemeral_msg !== undefined) {
      wire.extended(wire.extendedMapping.ephemeral_msg, data);
    } else {
      // Queue the message for later (this was missing!)
      if (!wire._pendingMessages) wire._pendingMessages = [];
      wire._pendingMessages.push(msg);
      console.log('[Extension] Queued message for later delivery');
    }
  } catch (e) {
    console.warn("sendPeer fail", e.message);
  }
};

    
    /* ------------------------------------------------------------------ */
    /* Register our custom BitTorrent extension so both peers recognise  */
    /* the name "ephemeral_msg" and know how to handle its payloads.     */
    /* ------------------------------------------------------------------ */
    function attachEphemeralExtension(wire) {
      // Extension MUST be a constructor function
      function EphemeralExtension() {
        const self = this;
        self._ready = false;
      }
      
      // REQUIRED: Extension name must be on the prototype
      EphemeralExtension.prototype.name = 'ephemeral_msg';
      
      // Called when extended handshake completes
        EphemeralExtension.prototype.onExtendedHandshake = function(handshake) {
          console.log('Extension handshake received:', handshake);
          
          if (!handshake.m || typeof handshake.m.ephemeral_msg === 'undefined') {
            console.warn('Peer does not support ephemeral_msg');
            return;
          }
          
          this.peerId = handshake.m.ephemeral_msg;
          this._ready = true;
          
          // Store reference on wire (this was missing!)
          wire.ephemeral_msg = this;
          
          console.log('Extension ready! PeerID:', this.peerId);
          
          // Send any queued messages (this was missing!)
          if (wire._pendingMessages && wire._pendingMessages.length > 0) {
            console.log(`[Extension] Sending ${wire._pendingMessages.length} queued messages`);
            wire._pendingMessages.forEach(msg => sendPeer(wire, msg));
            wire._pendingMessages = [];
          }
          
          // Add delay before first message
          setTimeout(() => {
            if (!wire.destroyed && this._ready) {
              sendPeer(wire, { type: 'request_posts' });
              console.log('Sent initial request_posts');
            }
          }, 1000);
        };
      
      // Called when a message for this extension is received
      EphemeralExtension.prototype.onMessage = function(buf) {
        try {
          const msg = JSON.parse(new TextDecoder().decode(buf));
          console.log('Received message:', msg.type);
          handlePeerMessage(msg, wire);
        } catch (e) {
          console.error('Bad peer message:', e);
        }
      };
      
      // Register the extension
      wire.use(EphemeralExtension);
    }

    
function broadcast(msg, excludeWire = null) {
  // Add message ID if not present
  if (!msg.msgId) {
    msg.msgId = generateId();
    msg.hops = 0;
  }
  
  // Check TTL
  if (epidemicGossip.messageTTL.has(msg.msgId)) {
    const hops = epidemicGossip.messageTTL.get(msg.msgId);
    if (hops >= epidemicGossip.maxHops) return;
    msg.hops = hops + 1;
  }
  epidemicGossip.messageTTL.set(msg.msgId, msg.hops);
  
  // Use Plumtree for efficient dissemination
  if (state.plumtree && state.hyparview && state.hyparview.getActivePeers().length > 2) {
    state.plumtree.broadcast(msg, excludeWire?.peerId?.toString('hex'));
  } else {
    // Fallback for small networks or before Plumtree is ready
    const networkSize = state.peers.size;
    let fanout = Math.ceil(Math.log2(networkSize + 1)) + 2;
    fanout = Math.min(fanout, 8);
    
    const selected = epidemicGossip.selectRandomPeers(fanout, [excludeWire]);
    selected.forEach(peer => {
      epidemicGossip.sendWithExponentialBackoff(peer, msg);
    });
  }
}

async function handleImageRequest(imageHash, fromWire) {
    const metadata = imageStore.images.get(imageHash);
    if (!metadata) {
        console.log(`[ImageRequest] Peer requested image ${imageHash.substring(0, 8)}... but we don't have its metadata.`);
        return;
    }
    console.log(`[ImageRequest] Peer requested image ${imageHash.substring(0, 8)}.... We have metadata and will send available chunks.`);

    const chunks = [];
    for (const chunkMeta of metadata.chunks) {
        const chunkData = imageStore.chunks.get(chunkMeta.hash);
        if (chunkData) {
            chunks.push({ hash: chunkMeta.hash, data: chunkData });
            console.log(`[ImageRequest] Sending chunk ${chunkMeta.hash.substring(0, 8)}...`);
        } else {
            console.warn(`[ImageRequest] Missing chunk ${chunkMeta.hash.substring(0, 8)}... for image ${imageHash.substring(0, 8)}... that we should have.`);
        }
    }

    sendPeer(fromWire, {
        type: "image_response",
        imageHash: imageHash,
        metadata: metadata, // Send the full metadata including Merkle Root and chunk list
        chunks: chunks
    });
    console.log(`[ImageRequest] Sent image_response for ${imageHash.substring(0, 8)}... with ${chunks.length} chunks.`);
}

function handleImageResponse(msg) {
    console.log(`[ImageResponse] Received image response for hash: ${msg.imageHash.substring(0, 8)}...`);

    // Store the metadata if we don't have it already
    if (!imageStore.images.has(msg.imageHash)) {
        imageStore.images.set(msg.imageHash, msg.metadata);
        console.log(`[ImageResponse] Stored new image metadata for ${msg.imageHash.substring(0, 8)}...`);
    } else {
        console.log(`[ImageResponse] Image metadata for ${msg.imageHash.substring(0, 8)}... already exists.`);
    }

    // Store chunks
    let newChunksCount = 0;
    for (const chunk of msg.chunks) {
        if (!imageStore.chunks.has(chunk.hash)) {
            imageStore.chunks.set(chunk.hash, chunk.data);
            newChunksCount++;
            console.log(`[ImageResponse] Stored new chunk ${chunk.hash.substring(0, 8)}...`);
        } else {
            // console.log(`[ImageResponse] Chunk ${chunk.hash.substring(0, 8)}... already exists locally.`);
        }
    }
    console.log(`[ImageResponse] Stored ${newChunksCount} new chunks for image ${msg.imageHash.substring(0, 8)}...`);

    // Now attempt to retrieve the image using the store's method, which includes Merkle verification
    imageStore.retrieveImage(msg.imageHash).then(imageData => {
        if (imageData) {
            console.log(`[ImageResponse] Image ${msg.imageHash.substring(0, 8)}... successfully reassembled and verified.`);
            // Find and update any posts waiting for this image
            for (const [id, post] of state.posts) {
                if (post.imageHash === msg.imageHash && !post.imageData) {
                    post.imageData = imageData; // Cache for display
                    refreshPost(post);
                    console.log(`[ImageResponse] Updated post ${id} with image ${msg.imageHash.substring(0, 8)}...`);
                }
            }
        } else {
            console.warn(`[ImageResponse] Failed to reassemble or verify image ${msg.imageHash.substring(0, 8)}... after receiving chunks. It might be incomplete or corrupted.`);
            // Optional: Request missing chunks or re-request the image if verification fails
            const metadata = imageStore.images.get(msg.imageHash);
            if (metadata) {
                const missingChunkHashes = metadata.chunks
                    .filter(chunkMeta => !imageStore.chunks.has(chunkMeta.hash))
                    .map(chunkMeta => chunkMeta.hash);

                if (missingChunkHashes.length > 0) {
                    console.log(`[ImageResponse] Still missing ${missingChunkHashes.length} chunks for ${msg.imageHash.substring(0, 8)}... Requesting them.`);
                    const peers = Array.from(state.peers.values()).slice(0, 3);
                    for (const peer of peers) {
                        sendPeer(peer.wire, {
                            type: "request_chunks",
                            imageHash: msg.imageHash, // Include imageHash so receiver knows context
                            chunkHashes: missingChunkHashes
                        });
                    }
                }
            }
        }
    });
}

    /* ---------- MESSAGE / POST LOGIC ---------- */
    async function handlePeerMessage(msg, fromWire) {
      // Check message ID for deduplication
      if (msg.msgId && state.seenMessages.has(msg.msgId)) {
        return; // Already processed
      }
      
      if (msg.msgId) {
        state.seenMessages.add(msg.msgId);
      }
  
      // Rate limiting check
      const peerId = fromWire.peerId;
      const peerData = state.peers.get(peerId);
      
      if (peerData) {
        const now = Date.now();
        peerData.messageTimestamps.push(now);
        
        // Clean old timestamps
        peerData.messageTimestamps = peerData.messageTimestamps.filter(
          ts => now - ts < CONFIG.RATE_LIMIT_WINDOW
        );
        
        // Define message types that *should* be rate-limited (e.g., user-generated content)
        const rateLimitedMessageTypes = ['new_post', 'parent_update']; // Add other types that can be spammed

        if (rateLimitedMessageTypes.includes(msg.type)) {
            if (peerData.messageTimestamps.length > CONFIG.RATE_LIMIT_MESSAGES) {
                console.warn(`Rate limit exceeded for peer ${peerId} for message type: ${msg.type}. Dropping message.`);
                return; // Drop message if rate-limited
            }
        }
      }
        if (msg.type === "new_post" || msg.type === "carrier_update") {
            trafficMixer.addToMixPool(msg, fromWire);
          }
      switch (msg.type) {
        case "dht_rpc":
          if (state.dht) {
            state.dht.handleRPC(msg, fromWire);
          }
          break;
          
        case "hyparview":
          if (state.hyparview) {
            state.hyparview.handleMessage(msg, fromWire);
          }
          break;
          
        case "scribe":
          if (state.scribe) {
            state.scribe.handleMessage(msg, fromWire);
          }
          break;
          
        case "plumtree":
          if (state.plumtree) {
            state.plumtree.handleMessage(msg, fromWire);
          }
          break;
      case "onion_relay":
        dandelion.handleOnionRelay(msg, fromWire);
        break;
    case "peer_exchange":
      // Handle peer exchange messages from headless nodes
      if (msg.peers && Array.isArray(msg.peers)) {
        msg.peers.forEach(peerInfo => {
          try {
            let peerId;
            // Handle different ID formats
            if (typeof peerInfo.id === 'string') {
              // Hex string from headless node
              peerId = hexToUint8Array(peerInfo.id);
            } else if (peerInfo.id instanceof Uint8Array) {
              peerId = peerInfo.id;
            } else if (peerInfo.id && (peerInfo.id.type === 'Buffer' || peerInfo.id.data)) {
              // Buffer object
              peerId = new Uint8Array(peerInfo.id.data || peerInfo.id);
            }
            
            if (peerId && state.dht && !state.dht.uint8ArrayEquals(peerId, state.myIdentity.nodeId)) {
              state.dht.addPeer(peerId, { wire: null });
            }
          } catch (e) {
            console.error("Error in peer exchange:", e);
          }
        });
      }
      break;
      case "noise":
        // Silently drop noise messages
        return;
      case "new_post":
        // If the message has a 'phase', it's part of the Dandelion protocol.
        if (msg.phase === "stem" || msg.phase === "fluff") {
          // Delegate to the router to handle it properly.
          dandelion.handleRoutedPost(msg, fromWire);
        } else {
          // Handle posts that are not part of the Dandelion protocol (for backward compatibility).
            await handleNewPost(msg.post || msg, fromWire);
        }
        break;
        case "request_chunks":
          handleChunkRequest(msg.chunkHashes, fromWire);
          break;
          
        case "chunk_response":
          handleChunkResponse(msg.chunks);
          break;
        
        
        case "request_image":
            handleImageRequest(msg.imageHash, fromWire);
            break;
            
        case "image_response":
            handleImageResponse(msg);
            break;

        
        case "parent_update":
          handleParentUpdate(msg);
          break;
        case "request_posts":
          if (fromWire) {
            const list = [...state.posts.values()].map(p => p.toJSON());
            sendPeer(fromWire, { type: "posts_response", posts: list });
          }
          break;
        case "posts_response": await handlePostsResponse(msg.posts, fromWire); break;
        case "carrier_update": handleCarrierUpdate(msg); break;
      }
    }
    
function handleChunkRequest(requestedHashes, fromWire) {
  const chunks = [];
  for (const hash of requestedHashes) {
    const chunk = imageStore.chunks.get(hash);
    if (chunk) {
      chunks.push({ hash, data: chunk });
    }
  }
  
  if (chunks.length > 0) {
    sendPeer(fromWire, { 
      type: "chunk_response", 
      chunks: chunks 
    });
  }
}

function handleChunkResponse(msg) {
  // Quick check for valid message structure
  if (!msg || !msg.chunks || !msg.imageHash) {
    console.warn("Received an incomplete chunk response, ignoring.");
    return;
  }

  console.log(`Received chunks for image: ${msg.imageHash.substring(0, 8)}...`);

  let newChunksWereStored = false;
  for (const { hash, data } of msg.chunks) {
    if (!imageStore.chunks.has(hash)) {
      imageStore.chunks.set(hash, data);
      newChunksWereStored = true;
      console.log(`Stored new chunk: ${hash.substring(0, 8)}...`);
    }
  }

  // If we actually added new data, try to build the image and update posts
  if (newChunksWereStored) {
    imageStore.retrieveImage(msg.imageHash).then(imageData => {
      if (imageData) {
        console.log(`Image ${msg.imageHash.substring(0, 8)}... is now complete and verified.`);
        // Find any posts that need this image and refresh them
        for (const [id, post] of state.posts) {
          if (post.imageHash === msg.imageHash && !post.imageData) {
            post.imageData = imageData;
            refreshPost(post); // Update the UI
            console.log(`Updated post ${id} with image.`);
          }
        }
      } else {
        console.warn(`Could not fully reassemble image ${msg.imageHash.substring(0, 8)}... even after new chunks. Still missing pieces or verification failed.`);
      }
    }).catch(error => {
      console.error(`Error processing image ${msg.imageHash.substring(0, 8)}... from chunks:`, error);
    });
  }
}
    
function handleParentUpdate(msg) {
  const parent = state.posts.get(msg.parentId);
  const reply = state.posts.get(msg.replyId);
  
  if (parent && reply) {
    parent.replies.add(msg.replyId);
    // Re-render to show thread indicator
    refreshPost(parent);
  }
}
async function handleImageUpload(file) {
  return new Promise((resolve, reject) => {
    if (file.size > 50000 * 1024) { // 50000KB limit
      reject(new Error("Image too large. Max 50MB"));
      return;
    }
    
    const reader = new FileReader();
    reader.onload = (e) => {
      const img = new Image();
      img.onload = () => {
        // Resize if needed
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        let width = img.width;
        let height = img.height;
        const maxDim = 800;
        
        if (width > maxDim || height > maxDim) {
          if (width > height) {
            height = (height / width) * maxDim;
            width = maxDim;
          } else {
            width = (width / height) * maxDim;
            height = maxDim;
          }
        }
        
        canvas.width = width;
        canvas.height = height;
        ctx.drawImage(img, 0, 0, width, height);
        
        const base64 = canvas.toDataURL('image/jpeg', 0.7);
        resolve(base64);
      };
      img.src = e.target.result;
    };
    reader.readAsDataURL(file);
  });
}

async function handleImageSelect(input) {
  const file = input.files[0];
  if (!file) return;
  
  try {
    const base64 = await handleImageUpload(file);
    const toxic = await isImageToxic(base64);
    if (toxic) {
      notify(`Image appears to contain ${toxic.toLowerCase()} content`);
      input.value = '';
      return;
    }
    document.getElementById('preview-img').src = base64;
    document.getElementById('image-preview').style.display = 'block';
    document.getElementById('image-preview').dataset.imageData = base64;
  } catch (e) {
    notify(e.message);
  }
}

function removeImage() {
  document.getElementById('image-preview').style.display = 'none';
  document.getElementById('image-preview').dataset.imageData = '';
  document.getElementById('image-input').value = '';
}


async function handleNewPost(data, fromWire) {
    // Handle both browser format (with .post) and headless format (direct)
    const postData = data.post || data;
    
    // Deduplication check early
    if (!postData?.id || state.posts.has(postData.id) || state.seenPosts.has(postData.id)) {
        console.log(`[handleNewPost] Post ${postData?.id} already seen, skipping.`);
        return;
    }

    if (postData.content.length > CONFIG.MAX_POST_SIZE) {
        console.warn(`[handleNewPost] Post content too long (${postData.content.length} > ${CONFIG.MAX_POST_SIZE}), dropping.`);
        return;
    }
    
    // Identity and VDF proof verification
    if (!data.authorUniqueId || !data.authorVdfProof || !data.authorVdfInput) {
        console.warn(`[handleNewPost] Dropping post ${data.id}: Missing author identity proof components.`, data.author);
        return;
    }
    const isAuthorValid = await vdf.verifyVDFProofWithIntegrity(data.authorVdfInput, data.authorVdfProof);
    if (!isAuthorValid) {
        console.warn(`[handleNewPost] Dropping post ${data.id}: Invalid author identity proof.`, data.author);
        return;
    }
    if (data.vdfProof && data.vdfInput) {
        const isValid = await vdf.verifyVDFProofWithIntegrity(data.vdfInput, data.vdfProof);
        if (!isValid) {
            console.warn(`[handleNewPost] Invalid VDF proof for post ${data.id}, dropping.`);
            return;
        }
    }

    // Toxicity and NSFW checks
    if (await isToxic(data.content)) {
        console.log(`[handleNewPost] Filtered toxic text content for post ${data.id}.`);
        return;
    }
    if (data.imageData) { // Note: for content-addressed, data.imageData will likely be null here
        const imageToxic = await isImageToxic(data.imageData);
        if (imageToxic) {
            console.log(`[handleNewPost] Filtered toxic image (raw data) for post ${data.id}:`, imageToxic);
            return;
        }
    }

    // Add to bloom filter after initial checks
    state.seenPosts.add(data.id);

    // Sanitize content before creating Post object
    data.content = sanitize(data.content);
    const p = Post.fromJSON(data);

    // Verify the post's cryptographic signature
    if (!p.verify()) {
        console.warn(`[handleNewPost] Dropping post ${p.id} with invalid signature from author: ${p.author}.`);
        return;
    }

    // Handle content-addressed images: Request if we don't have it locally
    if (p.imageHash && !p.imageData) {
        const imageData = await imageStore.retrieveImage(p.imageHash); // This attempts retrieval and verifies Merkle root
        if (imageData) {
            p.imageData = imageData; // Cache for display
            console.log(`[handleNewPost] Image ${p.imageHash.substring(0, 8)}... found locally for post ${p.id}.`);
        } else {
            console.log(`[handleNewPost] Requesting image ${p.imageHash.substring(0, 8)}... from peers for post ${p.id}.`);
            const peers = Array.from(state.peers.values()).slice(0, 3);
            for (const peer of peers) {
                sendPeer(peer.wire, {
                    type: "request_image",
                    imageHash: p.imageHash
                });
            }
        }
    }

    // Handle replies
    if (p.parentId) {
        const parent = state.posts.get(p.parentId);
        if (!parent) {
            console.log(`[handleNewPost] Dropping reply ${p.id} - parent ${p.parentId} not found.`);
            return;
        }
        parent.replies.add(p.id);
        p.depth = Math.min(parent.depth + 1, 5);
        console.log(`[handleNewPost] Post ${p.id} is a reply to ${p.parentId}. Depth: ${p.depth}`);
    }

    p.carriers.add(state.myIdentity.handle);
    state.posts.set(p.id, p);
    console.log(`[handleNewPost] Added post ${p.id} to local state.`);

    renderPost(p); // Render the post to the UI

    // Broadcast the new post and carrier update
    broadcast({ type: "new_post", post: data }, fromWire);
    broadcast({
        type: "carrier_update",
        postId: p.id,
        peer: state.myIdentity.handle,
        carrying: true
    }, fromWire);
    console.log(`[handleNewPost] Broadcast new post ${p.id} and carrier update.`);
}

    async function handlePostsResponse(list, fromWire) {
      for (const d of list) await handleNewPost(d, fromWire);
    }
    
function handleCarrierUpdate(msg) {
  const p = state.posts.get(msg.postId);
  if (!p) return;
  const handle = msg.peer || msg.fromIdentityHandle;
  if (!handle) return;

  msg.carrying ? p.carriers.add(handle) : p.carriers.delete(handle);

  // A post dies if its carrier count is 0, regardless of author.
  if (p.carriers.size === 0) {
    state.posts.delete(p.id);
    dropPost(p.id);
  } else {
    refreshPost(p);
  }
}

    /* ---------- UI ---------- */
    
const animationObserver = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      entry.target.classList.add('animate');
    } else {
      entry.target.classList.remove('animate');
    }
  });
}, { threshold: 0.1 });    

async function renderPost(p, container = null) {
  if (document.getElementById("post-" + p.id)) return;

  const el = document.createElement("div");
  el.className = p.parentId ? `post reply depth-${Math.min(p.depth, 5)}` : "post";
  el.id = "post-" + p.id;
      animationObserver.observe(el);

  await updateInner(el, p); // Now async
  
  // Determine where to insert the post
  if (container) {
    container.appendChild(el);
  } else if (p.parentId) {
    // Find parent element and add to its replies container
    const parentEl = document.getElementById("post-" + p.parentId);
    if (parentEl) {
      let repliesContainer = parentEl.querySelector('.replies-container');
      if (!repliesContainer) {
        repliesContainer = document.createElement('div');
        repliesContainer.className = 'replies-container';
        parentEl.appendChild(repliesContainer);
      }
      repliesContainer.appendChild(el);
    } else {
      // Parent not found, add to main feed
      document.getElementById("posts").prepend(el);
    }
  } else {
    // Top-level post
    document.getElementById("posts").prepend(el);
  }
  
  state.viewing.add(p.id);
  updateStatus();
}

    function getHeatLevel(carrierCount) {
      if (carrierCount >= 20) return "üî• Inferno";
      if (carrierCount >= 15) return "üî• Blazing";
      if (carrierCount >= 10) return "üî• Burning";
      if (carrierCount >= 5) return "üåü Glowing";
      if (carrierCount >= 2) return "‚ú® Flickering";
      return "üí® Dying ember";
    }
    
async function updateInner(el, p) {
    const mine = p.carriers.has(state.myIdentity.handle);
    const isAuthor = p.author === state.myIdentity.handle;
    const carrierCount = p.carriers.size;

    const heatLevel = getHeatLevel(carrierCount);
    const heatOpacity = Math.min(0.1 + (carrierCount / 20), 1);

    const threadSize = getThreadSize(p.id);
    const hasReplies = p.replies.size > 0;

    let imageHtml = '';
    if (p.imageHash) {
        const imageData = await imageStore.retrieveImage(p.imageHash);
        if (imageData) {
            p.imageData = imageData;
            imageHtml = `<img src="${imageData}" class="post-image" alt="Posted image" />`;
        } else {
            imageHtml = `<div class="image-placeholder" style="width:100%;height:150px;background:#333;display:flex;align-items:center;justify-content:center;color:#fff;">Loading Image...</div>`;
        }
    }

    // This logic adds the topic tags to the post's HTML
    let topicsHtml = '';
    if (state.scribe) {
        const topics = state.scribe.extractTopics(p.content);
        if (topics.length > 0) {
            topicsHtml = `
                <div class="post-topics">
                    ${topics.map(topic => `<span class="post-topic-tag" onclick="discoverAndFilterTopic('${topic}')">${topic}</span>`).join('')}
                </div>`;
        }
    }

    el.innerHTML = `
        <div class="author">${(p.author)}</div>
        <div class="content">${(p.content)}</div>
        ${imageHtml}
        ${topicsHtml}
        <div class="post-footer">
            <div class="carriers">
                <span class="heat-level">${heatLevel}</span>
                <span class="carrier-count">${carrierCount}</span>&nbsp;${carrierCount === 1 ? 'breath' : 'breaths'}
                ${hasReplies ? `<span class="thread-stats"><span class="thread-ember">üî•</span> ${threadSize} in thread</span>` : ''}
            </div>
            <div class="post-actions">
                <button class="carry-button ${mine ? 'withdrawing' : 'blowing'}" onclick="toggleCarry('${p.id}')">
                    ${isAuthor ? "üî• Your Ember" : (mine ? "üí® Withdraw" : "üå¨Ô∏è Blow")}
                </button>
                <button class="reply-button" onclick="toggleReplyForm('${p.id}')">
                    üí¨ Reply
                </button>
                ${hasReplies ? `<span class="collapse-thread" onclick="toggleThread('${p.id}')">[${el.classList.contains('collapsed') ? '+' : '-'}]</span>` : ''}
            </div>
        </div>
        <div id="reply-form-${p.id}" class="reply-compose" style="display: none;">
            <textarea id="reply-input-${p.id}" class="reply-input" placeholder="Add to the conversation..." maxlength="300"></textarea>
            <div class="compose-footer">
                <span class="char-count"><span id="reply-char-${p.id}">0</span>/300</span>
                <button onclick="createReply('${p.id}')" class="primary-button">üî• Add Gas!</button>
            </div>
        </div>`;

    el.style.setProperty('--heat-opacity', heatOpacity);
    el.classList.toggle('inferno', carrierCount >= 20);
    el.classList.toggle('hot', carrierCount >= 10);
    el.classList.toggle('warm', carrierCount >= 5);
    el.classList.toggle('dying', carrierCount === 0);

    if (p.parentId && p.depth > 0) {
        const threadLine = document.createElement('div');
        threadLine.className = 'thread-line';
        el.appendChild(threadLine);
    }
}


    function toggleReplyForm(postId) {
  const form = document.getElementById(`reply-form-${postId}`);
  if (form) {
    form.style.display = form.style.display === 'none' ? 'block' : 'none';
    if (form.style.display === 'block') {
      const input = document.getElementById(`reply-input-${postId}`);
      input.focus();
      
      // Add character counter
      input.addEventListener('input', (e) => {
        document.getElementById(`reply-char-${postId}`).textContent = e.target.value.length;
      });
    }
  }
}

function toggleThread(postId) {
  const post = state.posts.get(postId);
  if (!post || post.replies.size === 0) return;
  
  const postEl = document.getElementById(`post-${postId}`);
  if (!postEl) return;
  
  const repliesContainer = postEl.querySelector('.replies-container');
  // Find the button itself within the post element
  const collapseButton = postEl.querySelector('.collapse-thread'); 
  
  if (repliesContainer && collapseButton) {
    const isCollapsed = repliesContainer.style.display === 'none';

    if (isCollapsed) {
      // --- EXPAND ---
      repliesContainer.style.display = 'block';
      postEl.classList.remove('collapsed');
      collapseButton.textContent = '[-]'; // Change the button text
    } else {
      // --- COLLAPSE ---
      repliesContainer.style.display = 'none';
      postEl.classList.add('collapsed');
      collapseButton.textContent = '[+]'; // Change the button text
    }
  }
}


async function createReply(parentId) {
  const input = document.getElementById(`reply-input-${parentId}`);
  if (!input) return;
  
  const txt = input.value.trim();
  if (!txt) return;
  
  const btn = input.parentElement.querySelector('button');
  btn.disabled = true;
  
  // Check parent still exists
  const parentPost = state.posts.get(parentId);
  if (!parentPost) {
    notify("Parent post no longer exists!");
    return;
  }
  
  const toxic = await isToxic(txt);
  if (toxic) { 
    notify(`Your reply may be seen as ${toxic.replace(/_/g, " ")}. Please rephrase.`); 
    btn.disabled = false; 
    return; 
  }
  
  // Create reply with parent reference
  const reply = new Post(txt, parentId);
  reply.depth = Math.min(parentPost.depth + 1, 5); // Max depth 5
  reply.sign(state.myIdentity.secretKey);
  
  // Add VDF if implemented
  if (window.vdf) {
        const vdfInput = txt + state.myIdentity.uniqueId + Date.now();

    const iterations = 1500; // Slightly less for replies
    
    try {
      const proof = await vdf.computeVDFProofWithTimeout(vdfInput, iterations);
      reply.vdfProof = proof;
      reply.vdfInput = vdfInput;
    } catch (e) {
      console.warn("VDF failed for reply:", e);
    }
  }
  
  // Update parent's replies list
  parentPost.replies.add(reply.id);
  
  // Automatically carry the parent post when replying
  if (!parentPost.carriers.has(state.myIdentity.handle)) {
    toggleCarry(parentId, false);
  }
  
  state.posts.set(reply.id, reply);
  renderPost(reply);
  
  // Broadcast the reply
  const replyData = reply.toJSON();
  if (reply.vdfProof) {
    replyData.vdfProof = reply.vdfProof;
    replyData.vdfInput = reply.vdfInput;
  }
  
  broadcast({ type: "new_post", post: replyData });
  
  // Also broadcast parent update
  broadcast({ 
    type: "parent_update", 
    parentId: parentId,
    replyId: reply.id
  });
  
  // Clear form
  input.value = "";
  document.getElementById(`reply-char-${parentId}`).textContent = 0;
  toggleReplyForm(parentId);
  
  btn.disabled = false;
  notify("Gas'd the thread!");
}
function getThreadSize(postId) {
  let count = 0;
  const post = state.posts.get(postId);
  if (!post) return 0;
  
  const visited = new Set();
  const queue = [postId];
  
  while (queue.length > 0) {
    const id = queue.shift();
    if (visited.has(id)) continue;
    visited.add(id);
    
    const p = state.posts.get(id);
    if (p) {
      count++;
      p.replies.forEach(replyId => queue.push(replyId));
    }
  }
  
  return count - 1; // Exclude the parent post itself
}
    async function refreshPost(p) { 
      const el = document.getElementById("post-" + p.id); 
      if (el) await updateInner(el, p); 
    }
    
function dropPost(id) {
  const el = document.getElementById("post-" + id);
  if (el) {
    // Stop observing for animations
    if (window.animationObserver) {
      animationObserver.unobserve(el);
    }
    
    el.classList.add("dying");
    setTimeout(() => el.remove(), 1000);
  }
  state.viewing.delete(id);
  updateStatus();
}

async function createPostWithTopics() {
  const input = document.getElementById("post-input");
  const txt = input.value.trim();
  if (!txt) return;

  // Extract topics from content
  const topics = state.scribe ? state.scribe.extractTopics(txt) : ['#general'];

  // ... existing post creation code starts here ...
  const imagePreview = document.getElementById('image-preview');
  const imageData = imagePreview.dataset.imageData || null;

  const btn = document.getElementById("send-button");
  btn.disabled = true;

  notify("Computing proof of work...", 10000);

  try {
    const vdfInput = txt + state.myIdentity.uniqueId + Date.now();
    const iterations = 2000; // Adjust based on reputation later

    vdf.setProgressCallback((progress) => {
      btn.textContent = `Computing... ${Math.round(progress)}%`;
    });

    const proof = await progressiveVDF.computeAdaptiveProof(
      txt,
      state.myIdentity.uniqueId
    );

    const toxic = await isToxic(txt);
    if (toxic) {
      notify(`Your post may be seen as ${toxic.replace(/_/g, " ")}. Please rephrase.`);
      btn.disabled = false;
      btn.textContent = "üî• Light it up";
      return;
    }
    if (imageData) {
      const imageToxic = await isImageToxic(imageData);
      if (imageToxic) {
        notify("Image content not allowed");
        btn.disabled = false;
        btn.textContent = "üî• Light it up";
        return;
      }
    }
    const p = new Post(txt, null, imageData);
    if (imageData) {
      console.log(`[createPost] Processing image for new post ${p.id}.`);
      await p.processImage(); // This will call imageStore.storeImage
    }
    p.vdfProof = proof; // Attach proof to post
    p.vdfInput = vdfInput; // Store input for verification
    p.sign(state.myIdentity.secretKey); // Sign AFTER imageHash is set by processImage

    state.posts.set(p.id, p);
    input.value = "";
    document.getElementById("char-current").textContent = 0;
    renderPost(p);

    // General broadcast via Dandelion routing
    if (state.peers.size >= 3) {
      dandelion.routePostSecure(p);
    } else {
      dandelion.routePost(p);
    }

    // After creating the post, multicast to relevant topics
    if (state.scribe) {
      topics.forEach(topic => {
        state.scribe.multicast(topic, {
          type: 'new_post',
          post: p.toJSON()
        });
      });
    }

    removeImage();

    btn.disabled = false;
    btn.textContent = "üî• Light it up";
    notify("Posted to the void");

  } catch (error) {
    console.error("VDF computation failed:", error);
    notify("Failed to compute proof of work", 5000);
    btn.disabled = false;
    btn.textContent = "üî• Light it up";
  }
}

//depreciated
async function createPost() {
  const input = document.getElementById("post-input");
  const txt = input.value.trim();
  if (!txt) return;
  
  const imagePreview = document.getElementById('image-preview');
const imageData = imagePreview.dataset.imageData || null;

  
  const btn = document.getElementById("send-button");
  btn.disabled = true;
  
  // Show VDF progress
  notify("Computing proof of work...", 10000);
  
  try {
    // Compute VDF proof
        const vdfInput = txt + state.myIdentity.uniqueId + Date.now();

    const iterations = 2000; // Adjust based on reputation later
    
    vdf.setProgressCallback((progress) => {
      btn.textContent = `Computing... ${Math.round(progress)}%`;
    });
    
  const proof = await progressiveVDF.computeAdaptiveProof(
    txt, 
    state.myIdentity.uniqueId
  );
  

    
    const toxic = await isToxic(txt);
    if (toxic) { 
      notify(`Your post may be seen as ${toxic.replace(/_/g, " ")}. Please rephrase.`); 
      btn.disabled = false; 
      btn.textContent = "üî• Light it up";
      return; 
    }
    if (imageData) {
      const imageToxic = await isImageToxic(imageData);
      if (imageToxic) {
        notify("Image content not allowed");
        btn.disabled = false;
        btn.textContent = "üî• Light it up";
        return;
      }
    }
const p = new Post(txt, null, imageData);
    if (imageData) {
        console.log(`[createPost] Processing image for new post ${p.id}.`);
        await p.processImage(); // This will call imageStore.storeImage
    }
    p.vdfProof = proof; // Attach proof to post
    p.vdfInput = vdfInput; // Store input for verification
    p.sign(state.myIdentity.secretKey); // Sign AFTER imageHash is set by processImage

    state.posts.set(p.id, p);
    input.value = ""; 
    document.getElementById("char-current").textContent = 0;
    renderPost(p);
    
    // Include VDF proof in broadcast
    const postData = p.toJSON();
    postData.vdfProof = proof;
    postData.vdfInput = vdfInput;
    
    if (state.peers.size >= 3) {
      dandelion.routePostSecure(p);
    } else {
      dandelion.routePost(p);
    }

    
  
    removeImage();

    btn.disabled = false;
    btn.textContent = "üî• Light it up";
    notify("Posted to the void");
    
  } catch (error) {
    console.error("VDF computation failed:", error);
    notify("Failed to compute proof of work", 5000);
    btn.disabled = false;
    btn.textContent = "üî• Light it up";
  }
}

function toggleCarry(id, isManual = true) {
  const p = state.posts.get(id);
  if (!p) return;
  const isCarrying = p.carriers.has(state.myIdentity.handle);

  // If the user is NOT currently carrying it, they are ADDING their "breath"
  if (!isCarrying) {
    p.carriers.add(state.myIdentity.handle);
    state.explicitlyCarrying.add(id);
    broadcast({ type: "carrier_update", postId: id, peer: state.myIdentity.handle, carrying: true });
    
    // Just refresh the post to update the button text to "Withdraw"
    refreshPost(p);
  } 
  // If the user IS carrying it, they are WITHDRAWING their "breath"
  else {
    p.carriers.delete(state.myIdentity.handle);
    state.explicitlyCarrying.delete(id);
    broadcast({ type: "carrier_update", postId: id, peer: state.myIdentity.handle, carrying: false });

    // Immediately remove the post from the current user's timeline.
    // This will not affect other peers who are still carrying it.
    dropPost(id);

    // If this withdrawal made this user the last carrier,
    // also delete the post from the state map entirely.
    if (p.carriers.size === 0) {
      state.posts.delete(p.id);
    }
  }
}

function updateBonfire() {
  const bonfireContentEl = document.getElementById('bonfire-content');
  if (!bonfireContentEl) return;
  
  // Get hot threads (root posts with many replies or carriers)
  const threads = new Map();
  
  for (const [id, post] of state.posts) {
    const rootId = post.parentId ? findRootPost(id) : id;
    if (!threads.has(rootId)) {
      threads.set(rootId, {
        root: state.posts.get(rootId),
        heat: 0,
        replyCount: 0,
        totalCarriers: new Set()
      });
    }
    
    const thread = threads.get(rootId);
    thread.replyCount++;
    post.carriers.forEach(c => thread.totalCarriers.add(c));
    thread.heat = thread.totalCarriers.size + thread.replyCount * 2;
  }
  
  const hottest = Array.from(threads.values())
    .filter(t => t.heat >= 10)
    .sort((a, b) => b.heat - a.heat)
    .slice(0, 10);
  
  if (hottest.length > 0) {
    const bonfireHtml = hottest.map(thread => `
      <div class="bonfire-item" onclick="scrollToPost('${thread.root.id}')">
        <span class="bonfire-heat">${thread.heat} üî•</span>
        <span class="thread-stats">${thread.replyCount} replies</span>
        <span class="bonfire-preview">${(thread.root.content.substring(0, 60))}...</span>
      </div>
    `).join('');
    bonfireContentEl.innerHTML = `<div class="bonfire-posts">${bonfireHtml}</div>`;
  } else {
    bonfireContentEl.innerHTML = '<div class="empty-state">No hot threads right now. Start a conversation!</div>';
  }
}

function scrollToPost(postId) {
  const el = document.getElementById(`post-${postId}`);
  if (el) {
    el.scrollIntoView({ behavior: 'smooth', block: 'center' });
    el.style.animation = 'pulse-border 2s ease-in-out';
    setTimeout(() => {
      el.style.animation = '';
    }, 2000);
  }
}

function updateStatus() {
  const pc = state.peers.size;
  document.getElementById("peer-count").textContent = pc;
  document.getElementById("post-count").textContent = state.posts.size;
  document.getElementById("status-dot").classList.toggle("connecting", pc === 0);
  
  // Add protocol stats
  const dhtStats = state.dht ? state.dht.getStats() : null;
  const hvStats = state.hyparview ? state.hyparview.getStats() : null;
  
  const protocolInfo = dhtStats ? `DHT: ${dhtStats.totalPeers} peers` : '';
  const overlayInfo = hvStats ? `HyParView: ${hvStats.activeView}/${hvStats.passiveView}` : '';
  
  // Update or add protocol indicator
  let protocolEl = document.getElementById("protocol-status");
  if (!protocolEl) {
    protocolEl = document.createElement("span");
    protocolEl.id = "protocol-status";
    document.getElementById("status").appendChild(protocolEl);
  }
  protocolEl.innerHTML = `<br/>${protocolInfo} | ${overlayInfo}`;
  
const privacyStatus = dandelion.onionLayers > 0 ? "üîí Onion Routing" : "‚ö†Ô∏è Direct";

// Update or add privacy indicator
let privacyEl = document.getElementById("privacy-status");
if (!privacyEl) {
  privacyEl = document.createElement("span");
  privacyEl.id = "privacy-status";
  document.getElementById("status").appendChild(privacyEl);
}
privacyEl.innerHTML = `<br/>${privacyStatus} | Unified Bootstrap`;
  
  // Debounce bonfire updates
  clearTimeout(bonfireUpdateTimeout);
  bonfireUpdateTimeout = setTimeout(() => {
    updateBonfire();
  }, 1000); // Only update after 1 second of no activity
}

// Add topic suggestions while typing
document.getElementById("post-input").addEventListener("input", e => {
  const text = e.target.value;
  const lastWord = text.split(/\s+/).pop();
  
  if (lastWord.startsWith('#') && lastWord.length > 1) {
    // Show topic autocomplete
    showTopicSuggestions(lastWord);
  } else {
    hideTopicSuggestions();
  }
  
  document.getElementById("char-current").textContent = e.target.value.length;
    });

    function showTopicSuggestions(partial) {
      const suggestions = [
        '#tech', '#news', '#art', '#music', '#politics', '#science',
        '#ember', '#random', '#help', '#dev', '#memes'
      ].filter(topic => topic.startsWith(partial));
      
      // Create or update suggestions UI
      let suggestionsEl = document.getElementById('topic-suggestions');
      if (!suggestionsEl) {
        suggestionsEl = document.createElement('div');
        suggestionsEl.id = 'topic-suggestions';
        suggestionsEl.className = 'topic-suggestions';
        document.getElementById('compose').appendChild(suggestionsEl);
      }
      
      suggestionsEl.innerHTML = suggestions.map(topic => 
        `<div class="suggestion" onclick="completeTopicSuggestion('${topic}')">${topic}</div>`
      ).join('');
      
      suggestionsEl.style.display = suggestions.length > 0 ? 'block' : 'none';
    }

    function completeTopicSuggestion(topic) {
      const input = document.getElementById("post-input");
      const text = input.value;
      const words = text.split(/\s+/);
      words[words.length - 1] = topic + ' ';
      input.value = words.join(' ');
      input.focus();
      hideTopicSuggestions();
    }

    function hideTopicSuggestions() {
      const el = document.getElementById('topic-suggestions');
      if (el) el.style.display = 'none';
    }
    document.getElementById("post-input").addEventListener("keydown", e => {
      if (e.key === "Enter" && (e.ctrlKey || e.metaKey)) createPostWithTopics();
    });

    function updateAges() {
      document.querySelectorAll(".post .age").forEach(el => {
        const id = el.closest(".post").id.replace("post-", "");
        const p = state.posts.get(id);
        if (p) el.textContent = timeAgo(p.timestamp);
      });
    }

    /* ---------- GARBAGE COLLECTION ---------- */
function garbageCollect() {
  const now = Date.now();
  
  // Collect all posts that form threads
  const threadsMap = new Map(); // root post ID -> all posts in thread
  
  for (const [id, p] of state.posts) {
    const rootId = findRootPost(id);
    if (!threadsMap.has(rootId)) {
      threadsMap.set(rootId, new Set());
    }
    threadsMap.get(rootId).add(id);
  }
  
  // Evaluate threads as units
  for (const [rootId, threadPosts] of threadsMap) {
    const threadCarriers = new Set();
    let newestTimestamp = 0;
    let hasExplicitlyCarried = false;
    
    // Aggregate thread stats
    threadPosts.forEach(postId => {
      const post = state.posts.get(postId);
      if (post) {
        post.carriers.forEach(c => threadCarriers.add(c));
        newestTimestamp = Math.max(newestTimestamp, post.timestamp);
        if (state.explicitlyCarrying.has(postId)) {
          hasExplicitlyCarried = true;
        }
      }
    });
    
    // Keep thread if it's active
    const threadAge = now - newestTimestamp;
    const shouldKeep = hasExplicitlyCarried || 
                      threadCarriers.size > 2 || 
                      threadAge < 3_600_000; // 1 hour
    
    if (!shouldKeep && threadCarriers.size === 1 && threadAge > 1_800_000) {
      // Remove entire thread
      threadPosts.forEach(postId => {
        toggleCarry(postId, false);
      });
    }
  }
  
  updateStatus();
}
async function clearLocalData() {
  if (confirm('This will clear all saved posts and reset your identity. Continue?')) {
    // Clear IndexedDB
    if (stateManager.db) {
      stateManager.db.close();
      await indexedDB.deleteDatabase('EmberNetwork');
    }
    
    // Clear localStorage
    localStorage.clear();
    
    // Reload the page
    location.reload();
  }
}
function findRootPost(postId) {
  let current = postId;
  let post = state.posts.get(current);
  
  while (post && post.parentId) {
    current = post.parentId;
    post = state.posts.get(current);
  }
  
  return current;
}

let showAllShards = true; // Default to showing all content


    /* ---------- THEME TOGGLING ---------- */
    function applyTheme(theme) {
      const button = document.getElementById('theme-toggle-button');
      if (theme === 'light') {
        document.body.classList.add('light-mode');
        if (button) button.textContent = 'üåô Dark Mode';
      } else {
        document.body.classList.remove('light-mode');
        if (button) button.textContent = '‚òÄÔ∏è Light Mode';
      }
    }

    function setupThemeToggle() {
      const themeToggleButton = document.getElementById('theme-toggle-button');
      if (!themeToggleButton) return;

      themeToggleButton.addEventListener('click', () => {
        // Toggle the class on the body
        document.body.classList.toggle('light-mode');
        
        // Check which theme is active and save to localStorage
        if (document.body.classList.contains('light-mode')) {
          localStorage.setItem('ephemeral-theme', 'light');
          themeToggleButton.textContent = 'üåô Dark Mode';
        } else {
          localStorage.setItem('ephemeral-theme', 'dark');
          themeToggleButton.textContent = '‚òÄÔ∏è Light Mode';
        }
      });
    }



    /* ---------- INIT ---------- */
async function init() {
  const savedTheme = localStorage.getItem('ephemeral-theme') || 'dark';
  applyTheme(savedTheme);
  setupThemeToggle();
  
  try {
    // Initialize state manager first
    await stateManager.init();
    
    // Try to load saved identity
    await stateManager.loadUserState();
    
    // If no saved identity, create new one
    if (!state.myIdentity) {
      await initIdentity();
    }
    
    await initContentFilter();
    await initImageFilter();
    await waitForWebTorrent();
    
    // Load saved posts before showing connect screen
    const loadedPosts = await stateManager.loadPosts();
    if (loadedPosts > 0) {
      // Render saved posts
      const renderFullThread = (post) => {
        renderPost(post);
        if (post.replies && post.replies.size > 0) {
          post.replies.forEach(replyId => {
            const replyPost = state.posts.get(replyId);
            if (replyPost) {
              renderFullThread(replyPost);
            }
          });
        }
      };

      state.posts.forEach(post => {
        if (!post.parentId) {
          renderFullThread(post);
        }
      });
      
      updateStatus();
    }
    
    // Load peer scores
    await stateManager.loadPeerScores();
    
    // Show connect screen instead of auto-connecting
    showConnectScreen(loadedPosts);
    
  } catch (e) {
    console.error("Init failed:", e);
    document.getElementById("loading").innerHTML =
      `<div class="loading-content"><h2>Init Failed</h2><p>${e.message}</p><button onclick="location.reload()">Try Again</button></div>`;
  }
}

function showConnectScreen(loadedPostCount) {
  const isReturningUser = loadedPostCount > 0;
  
  document.getElementById("loading").innerHTML = `
    <div class="loading-content" style="max-width: 400px; text-align: center;">
      <h1 style="font-size: 48px; margin-bottom: 20px;">üî•</h1>
      <h2>Welcome to Ember</h2>
      <p style="color: #888; margin-bottom: 20px;">
        ${isReturningUser 
          ? `Welcome back! ${loadedPostCount} embers still glow from your last visit.`
          : 'A decentralized network where posts live only as long as someone tends the flame.'
        }
      </p>
      <button onclick="connectToNetwork()" class="primary-button" style="font-size: 18px; padding: 12px 30px;">
        üî• Ignite Connection
      </button>
      <p style="font-size: 12px; color: #666; margin-top: 20px;">
        By connecting, you agree to participate in a public peer-to-peer network
      </p>
    </div>
  `;
}

window.connectToNetwork = async function() {
  // Update loading screen
  document.getElementById("loading").innerHTML = `
    <div class="loading-content">
      <div class="spinner"></div>
      <div>üî• Igniting the Ember Network...</div>
      <div style="font-size:12px;margin-top:10px;color:#ff8c42">Finding peers...</div>
    </div>
  `;
  
  // Small delay for UI feedback
  await new Promise(r => setTimeout(r, 500));
  
  try {
    // Initialize network
    initNetwork();
    
    // Start maintenance loop
    startMaintenanceLoop();
    initTopics();

    // Set up beforeunload handlers
    window.addEventListener("beforeunload", () => {
      if (maintenanceInterval) clearInterval(maintenanceInterval);
      
      // Save state before leaving
      stateManager.savePosts();
      stateManager.saveUserState();
      stateManager.savePeerScores();
      
      if (state.client) state.client.destroy();
    });
    
    // Hide loading screen after a moment
    setTimeout(() => {
      document.getElementById("loading").style.display = "none";
      
      // Show tips for new users
      if (!localStorage.getItem("ephemeral-tips")) {
        setTimeout(() => notify("üí° Tip: Posts live only while carried by peers"), 1000);
        setTimeout(() => notify("üí° Tip: Ctrl+Enter to post quickly"), 6000);
        localStorage.setItem("ephemeral-tips", "yes");
      }
      
      // If returning user with posts, show a welcome back message
      if (state.posts.size > 0) {
        notify(`Welcome back! ${state.posts.size} embers still burning üî•`);
      }
    }, 1500);
    
  } catch (error) {
    console.error("Network initialization failed:", error);
    document.getElementById("loading").innerHTML = `
      <div class="loading-content">
        <h2>Connection Failed</h2>
        <p>${error.message}</p>
        <button onclick="connectToNetwork()" class="primary-button">Try Again</button>
      </div>
    `;
  }
};
    window.addEventListener("load", init);

    /* ---------- DEBUG ---------- */
    window.ephemeralDebug = {
      posts: () => state.posts, peers: () => state.peers,
      localPeers: () => state.localPeers, id: () => state.myIdentity,
      stats: () => ({ posts: state.posts.size, peers: CONFIG.LOCAL_MODE ? state.localPeers.size : state.peers.size })
    };
    
    
  </script>
</body>
</html>
